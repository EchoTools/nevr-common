// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: telemetry/v1/telemetry.proto
// Protobuf C++ Version: 6.33.1

#ifndef telemetry_2fv1_2ftelemetry_2eproto_2epb_2eh
#define telemetry_2fv1_2ftelemetry_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/runtime_version.h"
#if PROTOBUF_VERSION != 6033001
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/message_lite.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/map.h"  // IWYU pragma: export
#include "google/protobuf/map_type_handler.h"  // IWYU pragma: export
#include "google/protobuf/map_entry.h"
#include "google/protobuf/map_field.h"
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
#include "apigame/http_v1.pb.h"
#include "google/protobuf/timestamp.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_telemetry_2fv1_2ftelemetry_2eproto

namespace google {
namespace protobuf {
namespace internal {
template <typename T>
::absl::string_view GetAnyMessageName();
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_telemetry_2fv1_2ftelemetry_2eproto {
  static const ::uint32_t offsets[];
};
extern "C" {
extern const ::google::protobuf::internal::DescriptorTable descriptor_table_telemetry_2fv1_2ftelemetry_2eproto;
}  // extern "C"
namespace telemetry {
namespace v1 {
enum EmotePlayed_EmoteType : int;
extern const uint32_t EmotePlayed_EmoteType_internal_data_[];
enum Role : int;
extern const uint32_t Role_internal_data_[];
class DiscCaught;
struct DiscCaughtDefaultTypeInternal;
extern DiscCaughtDefaultTypeInternal _DiscCaught_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull DiscCaught_class_data_;
class DiscPossessionChanged;
struct DiscPossessionChangedDefaultTypeInternal;
extern DiscPossessionChangedDefaultTypeInternal _DiscPossessionChanged_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull DiscPossessionChanged_class_data_;
class DiscThrown;
struct DiscThrownDefaultTypeInternal;
extern DiscThrownDefaultTypeInternal _DiscThrown_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull DiscThrown_class_data_;
class EmotePlayed;
struct EmotePlayedDefaultTypeInternal;
extern EmotePlayedDefaultTypeInternal _EmotePlayed_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull EmotePlayed_class_data_;
class Envelope;
struct EnvelopeDefaultTypeInternal;
extern EnvelopeDefaultTypeInternal _Envelope_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull Envelope_class_data_;
class GoalScored;
struct GoalScoredDefaultTypeInternal;
extern GoalScoredDefaultTypeInternal _GoalScored_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull GoalScored_class_data_;
class LobbySessionEvent;
struct LobbySessionEventDefaultTypeInternal;
extern LobbySessionEventDefaultTypeInternal _LobbySessionEvent_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull LobbySessionEvent_class_data_;
class LobbySessionStateFrame;
struct LobbySessionStateFrameDefaultTypeInternal;
extern LobbySessionStateFrameDefaultTypeInternal _LobbySessionStateFrame_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull LobbySessionStateFrame_class_data_;
class MatchEnded;
struct MatchEndedDefaultTypeInternal;
extern MatchEndedDefaultTypeInternal _MatchEnded_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull MatchEnded_class_data_;
class PlayerAssist;
struct PlayerAssistDefaultTypeInternal;
extern PlayerAssistDefaultTypeInternal _PlayerAssist_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull PlayerAssist_class_data_;
class PlayerBlock;
struct PlayerBlockDefaultTypeInternal;
extern PlayerBlockDefaultTypeInternal _PlayerBlock_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull PlayerBlock_class_data_;
class PlayerGoal;
struct PlayerGoalDefaultTypeInternal;
extern PlayerGoalDefaultTypeInternal _PlayerGoal_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull PlayerGoal_class_data_;
class PlayerInterception;
struct PlayerInterceptionDefaultTypeInternal;
extern PlayerInterceptionDefaultTypeInternal _PlayerInterception_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull PlayerInterception_class_data_;
class PlayerJoined;
struct PlayerJoinedDefaultTypeInternal;
extern PlayerJoinedDefaultTypeInternal _PlayerJoined_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull PlayerJoined_class_data_;
class PlayerLeft;
struct PlayerLeftDefaultTypeInternal;
extern PlayerLeftDefaultTypeInternal _PlayerLeft_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull PlayerLeft_class_data_;
class PlayerPass;
struct PlayerPassDefaultTypeInternal;
extern PlayerPassDefaultTypeInternal _PlayerPass_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull PlayerPass_class_data_;
class PlayerSave;
struct PlayerSaveDefaultTypeInternal;
extern PlayerSaveDefaultTypeInternal _PlayerSave_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull PlayerSave_class_data_;
class PlayerShotTaken;
struct PlayerShotTakenDefaultTypeInternal;
extern PlayerShotTakenDefaultTypeInternal _PlayerShotTaken_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull PlayerShotTaken_class_data_;
class PlayerSteal;
struct PlayerStealDefaultTypeInternal;
extern PlayerStealDefaultTypeInternal _PlayerSteal_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull PlayerSteal_class_data_;
class PlayerStun;
struct PlayerStunDefaultTypeInternal;
extern PlayerStunDefaultTypeInternal _PlayerStun_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull PlayerStun_class_data_;
class PlayerSwitchedTeam;
struct PlayerSwitchedTeamDefaultTypeInternal;
extern PlayerSwitchedTeamDefaultTypeInternal _PlayerSwitchedTeam_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull PlayerSwitchedTeam_class_data_;
class RoundEnded;
struct RoundEndedDefaultTypeInternal;
extern RoundEndedDefaultTypeInternal _RoundEnded_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull RoundEnded_class_data_;
class RoundPaused;
struct RoundPausedDefaultTypeInternal;
extern RoundPausedDefaultTypeInternal _RoundPaused_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull RoundPaused_class_data_;
class RoundStarted;
struct RoundStartedDefaultTypeInternal;
extern RoundStartedDefaultTypeInternal _RoundStarted_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull RoundStarted_class_data_;
class RoundUnpaused;
struct RoundUnpausedDefaultTypeInternal;
extern RoundUnpausedDefaultTypeInternal _RoundUnpaused_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull RoundUnpaused_class_data_;
class ScoreboardUpdated;
struct ScoreboardUpdatedDefaultTypeInternal;
extern ScoreboardUpdatedDefaultTypeInternal _ScoreboardUpdated_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull ScoreboardUpdated_class_data_;
class TelemetryHeader;
struct TelemetryHeaderDefaultTypeInternal;
extern TelemetryHeaderDefaultTypeInternal _TelemetryHeader_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull TelemetryHeader_class_data_;
class TelemetryHeader_MetadataEntry_DoNotUse;
struct TelemetryHeader_MetadataEntry_DoNotUseDefaultTypeInternal;
extern TelemetryHeader_MetadataEntry_DoNotUseDefaultTypeInternal _TelemetryHeader_MetadataEntry_DoNotUse_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull TelemetryHeader_MetadataEntry_DoNotUse_class_data_;
}  // namespace v1
}  // namespace telemetry
namespace google {
namespace protobuf {
template <>
internal::EnumTraitsT<::telemetry::v1::EmotePlayed_EmoteType_internal_data_>
    internal::EnumTraitsImpl::value<::telemetry::v1::EmotePlayed_EmoteType>;
template <>
internal::EnumTraitsT<::telemetry::v1::Role_internal_data_>
    internal::EnumTraitsImpl::value<::telemetry::v1::Role>;
}  // namespace protobuf
}  // namespace google

namespace telemetry {
namespace v1 {
enum EmotePlayed_EmoteType : int {
  EmotePlayed_EmoteType_EMOTE_TYPE_UNSPECIFIED = 0,
  EmotePlayed_EmoteType_EMOTE_TYPE_PRIMARY = 1,
  EmotePlayed_EmoteType_EMOTE_TYPE_SECONDARY = 2,
  EmotePlayed_EmoteType_EmotePlayed_EmoteType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  EmotePlayed_EmoteType_EmotePlayed_EmoteType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t EmotePlayed_EmoteType_internal_data_[];
inline constexpr EmotePlayed_EmoteType EmotePlayed_EmoteType_EmoteType_MIN =
    static_cast<EmotePlayed_EmoteType>(0);
inline constexpr EmotePlayed_EmoteType EmotePlayed_EmoteType_EmoteType_MAX =
    static_cast<EmotePlayed_EmoteType>(2);
inline bool EmotePlayed_EmoteType_IsValid(int value) {
  return 0 <= value && value <= 2;
}
inline constexpr int EmotePlayed_EmoteType_EmoteType_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL EmotePlayed_EmoteType_descriptor();
template <typename T>
const ::std::string& EmotePlayed_EmoteType_Name(T value) {
  static_assert(::std::is_same<T, EmotePlayed_EmoteType>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to EmoteType_Name().");
  return EmotePlayed_EmoteType_Name(static_cast<EmotePlayed_EmoteType>(value));
}
template <>
inline const ::std::string& EmotePlayed_EmoteType_Name(EmotePlayed_EmoteType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<EmotePlayed_EmoteType_descriptor, 0, 2>(
      static_cast<int>(value));
}
inline bool EmotePlayed_EmoteType_Parse(
    ::absl::string_view name, EmotePlayed_EmoteType* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<EmotePlayed_EmoteType>(EmotePlayed_EmoteType_descriptor(), name,
                                           value);
}
enum Role : int {
  ROLE_UNSPECIFIED = 0,
  ROLE_BLUE_TEAM = 1,
  ROLE_ORANGE_TEAM = 2,
  ROLE_SPECTATOR = 3,
  ROLE_SOCIAL_PARTICIPANT = 4,
  ROLE_MODERATOR = 5,
  Role_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  Role_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t Role_internal_data_[];
inline constexpr Role Role_MIN =
    static_cast<Role>(0);
inline constexpr Role Role_MAX =
    static_cast<Role>(5);
inline bool Role_IsValid(int value) {
  return 0 <= value && value <= 5;
}
inline constexpr int Role_ARRAYSIZE = 5 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL Role_descriptor();
template <typename T>
const ::std::string& Role_Name(T value) {
  static_assert(::std::is_same<T, Role>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to Role_Name().");
  return Role_Name(static_cast<Role>(value));
}
template <>
inline const ::std::string& Role_Name(Role value) {
  return ::google::protobuf::internal::NameOfDenseEnum<Role_descriptor, 0, 5>(
      static_cast<int>(value));
}
inline bool Role_Parse(
    ::absl::string_view name, Role* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<Role>(Role_descriptor(), name,
                                           value);
}

// ===================================================================


// -------------------------------------------------------------------

class TelemetryHeader_MetadataEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<::std::string, ::std::string,
                             ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                             ::google::protobuf::internal::WireFormatLite::TYPE_STRING> {
 public:
  using SuperType =
      ::google::protobuf::internal::MapEntry<::std::string, ::std::string,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>;
  TelemetryHeader_MetadataEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR TelemetryHeader_MetadataEntry_DoNotUse(::google::protobuf::internal::ConstantInitialized);
  explicit TelemetryHeader_MetadataEntry_DoNotUse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr const void* PROTOBUF_NONNULL internal_default_instance() {
    return &_TelemetryHeader_MetadataEntry_DoNotUse_default_instance_;
  }


  static constexpr auto InternalGenerateClassData_();

 private:
  friend class ::google::protobuf::MessageLite;
  friend struct ::TableStruct_telemetry_2fv1_2ftelemetry_2eproto;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   0, 59,
                                   2>
      _table_;

  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();
};
extern const ::google::protobuf::internal::ClassDataFull TelemetryHeader_MetadataEntry_DoNotUse_class_data_;
// -------------------------------------------------------------------

class ScoreboardUpdated final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:telemetry.v1.ScoreboardUpdated) */ {
 public:
  inline ScoreboardUpdated() : ScoreboardUpdated(nullptr) {}
  ~ScoreboardUpdated() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ScoreboardUpdated* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ScoreboardUpdated));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ScoreboardUpdated(::google::protobuf::internal::ConstantInitialized);

  inline ScoreboardUpdated(const ScoreboardUpdated& from) : ScoreboardUpdated(nullptr, from) {}
  inline ScoreboardUpdated(ScoreboardUpdated&& from) noexcept
      : ScoreboardUpdated(nullptr, ::std::move(from)) {}
  inline ScoreboardUpdated& operator=(const ScoreboardUpdated& from) {
    CopyFrom(from);
    return *this;
  }
  inline ScoreboardUpdated& operator=(ScoreboardUpdated&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ScoreboardUpdated& default_instance() {
    return *reinterpret_cast<const ScoreboardUpdated*>(
        &_ScoreboardUpdated_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 10;
  friend void swap(ScoreboardUpdated& a, ScoreboardUpdated& b) { a.Swap(&b); }
  inline void Swap(ScoreboardUpdated* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ScoreboardUpdated* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ScoreboardUpdated* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ScoreboardUpdated>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ScoreboardUpdated& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ScoreboardUpdated& from) { ScoreboardUpdated::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ScoreboardUpdated* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "telemetry.v1.ScoreboardUpdated"; }

  explicit ScoreboardUpdated(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  ScoreboardUpdated(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const ScoreboardUpdated& from);
  ScoreboardUpdated(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, ScoreboardUpdated&& from) noexcept
      : ScoreboardUpdated(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kGameClockDisplayFieldNumber = 5,
    kBluePointsFieldNumber = 1,
    kOrangePointsFieldNumber = 2,
    kBlueRoundScoreFieldNumber = 3,
    kOrangeRoundScoreFieldNumber = 4,
  };
  // string game_clock_display = 5 [json_name = "gameClockDisplay"];
  void clear_game_clock_display() ;
  const ::std::string& game_clock_display() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_game_clock_display(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_game_clock_display();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_game_clock_display();
  void set_allocated_game_clock_display(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_game_clock_display() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_game_clock_display(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_game_clock_display();

  public:
  // int32 blue_points = 1 [json_name = "bluePoints"];
  void clear_blue_points() ;
  ::int32_t blue_points() const;
  void set_blue_points(::int32_t value);

  private:
  ::int32_t _internal_blue_points() const;
  void _internal_set_blue_points(::int32_t value);

  public:
  // int32 orange_points = 2 [json_name = "orangePoints"];
  void clear_orange_points() ;
  ::int32_t orange_points() const;
  void set_orange_points(::int32_t value);

  private:
  ::int32_t _internal_orange_points() const;
  void _internal_set_orange_points(::int32_t value);

  public:
  // int32 blue_round_score = 3 [json_name = "blueRoundScore"];
  void clear_blue_round_score() ;
  ::int32_t blue_round_score() const;
  void set_blue_round_score(::int32_t value);

  private:
  ::int32_t _internal_blue_round_score() const;
  void _internal_set_blue_round_score(::int32_t value);

  public:
  // int32 orange_round_score = 4 [json_name = "orangeRoundScore"];
  void clear_orange_round_score() ;
  ::int32_t orange_round_score() const;
  void set_orange_round_score(::int32_t value);

  private:
  ::int32_t _internal_orange_round_score() const;
  void _internal_set_orange_round_score(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:telemetry.v1.ScoreboardUpdated)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 5,
                                   0, 57,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const ScoreboardUpdated& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr game_clock_display_;
    ::int32_t blue_points_;
    ::int32_t orange_points_;
    ::int32_t blue_round_score_;
    ::int32_t orange_round_score_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_telemetry_2fv1_2ftelemetry_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull ScoreboardUpdated_class_data_;
// -------------------------------------------------------------------

class RoundStarted final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:telemetry.v1.RoundStarted) */ {
 public:
  inline RoundStarted() : RoundStarted(nullptr) {}
  ~RoundStarted() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(RoundStarted* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(RoundStarted));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RoundStarted(::google::protobuf::internal::ConstantInitialized);

  inline RoundStarted(const RoundStarted& from) : RoundStarted(nullptr, from) {}
  inline RoundStarted(RoundStarted&& from) noexcept
      : RoundStarted(nullptr, ::std::move(from)) {}
  inline RoundStarted& operator=(const RoundStarted& from) {
    CopyFrom(from);
    return *this;
  }
  inline RoundStarted& operator=(RoundStarted&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RoundStarted& default_instance() {
    return *reinterpret_cast<const RoundStarted*>(
        &_RoundStarted_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 5;
  friend void swap(RoundStarted& a, RoundStarted& b) { a.Swap(&b); }
  inline void Swap(RoundStarted* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RoundStarted* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RoundStarted* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<RoundStarted>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RoundStarted& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RoundStarted& from) { RoundStarted::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(RoundStarted* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "telemetry.v1.RoundStarted"; }

  explicit RoundStarted(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  RoundStarted(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const RoundStarted& from);
  RoundStarted(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, RoundStarted&& from) noexcept
      : RoundStarted(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kRoundNumberFieldNumber = 1,
  };
  // int32 round_number = 1 [json_name = "roundNumber"];
  void clear_round_number() ;
  ::int32_t round_number() const;
  void set_round_number(::int32_t value);

  private:
  ::int32_t _internal_round_number() const;
  void _internal_set_round_number(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:telemetry.v1.RoundStarted)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const RoundStarted& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::int32_t round_number_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_telemetry_2fv1_2ftelemetry_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull RoundStarted_class_data_;
// -------------------------------------------------------------------

class RoundEnded final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:telemetry.v1.RoundEnded) */ {
 public:
  inline RoundEnded() : RoundEnded(nullptr) {}
  ~RoundEnded() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(RoundEnded* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(RoundEnded));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RoundEnded(::google::protobuf::internal::ConstantInitialized);

  inline RoundEnded(const RoundEnded& from) : RoundEnded(nullptr, from) {}
  inline RoundEnded(RoundEnded&& from) noexcept
      : RoundEnded(nullptr, ::std::move(from)) {}
  inline RoundEnded& operator=(const RoundEnded& from) {
    CopyFrom(from);
    return *this;
  }
  inline RoundEnded& operator=(RoundEnded&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RoundEnded& default_instance() {
    return *reinterpret_cast<const RoundEnded*>(
        &_RoundEnded_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 8;
  friend void swap(RoundEnded& a, RoundEnded& b) { a.Swap(&b); }
  inline void Swap(RoundEnded* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RoundEnded* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RoundEnded* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<RoundEnded>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RoundEnded& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RoundEnded& from) { RoundEnded::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(RoundEnded* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "telemetry.v1.RoundEnded"; }

  explicit RoundEnded(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  RoundEnded(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const RoundEnded& from);
  RoundEnded(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, RoundEnded&& from) noexcept
      : RoundEnded(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kRoundNumberFieldNumber = 1,
    kWinningTeamFieldNumber = 2,
  };
  // int32 round_number = 1 [json_name = "roundNumber"];
  void clear_round_number() ;
  ::int32_t round_number() const;
  void set_round_number(::int32_t value);

  private:
  ::int32_t _internal_round_number() const;
  void _internal_set_round_number(::int32_t value);

  public:
  // .telemetry.v1.Role winning_team = 2 [json_name = "winningTeam"];
  void clear_winning_team() ;
  ::telemetry::v1::Role winning_team() const;
  void set_winning_team(::telemetry::v1::Role value);

  private:
  ::telemetry::v1::Role _internal_winning_team() const;
  void _internal_set_winning_team(::telemetry::v1::Role value);

  public:
  // @@protoc_insertion_point(class_scope:telemetry.v1.RoundEnded)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const RoundEnded& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::int32_t round_number_;
    int winning_team_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_telemetry_2fv1_2ftelemetry_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull RoundEnded_class_data_;
// -------------------------------------------------------------------

class PlayerSwitchedTeam final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:telemetry.v1.PlayerSwitchedTeam) */ {
 public:
  inline PlayerSwitchedTeam() : PlayerSwitchedTeam(nullptr) {}
  ~PlayerSwitchedTeam() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(PlayerSwitchedTeam* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(PlayerSwitchedTeam));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PlayerSwitchedTeam(::google::protobuf::internal::ConstantInitialized);

  inline PlayerSwitchedTeam(const PlayerSwitchedTeam& from) : PlayerSwitchedTeam(nullptr, from) {}
  inline PlayerSwitchedTeam(PlayerSwitchedTeam&& from) noexcept
      : PlayerSwitchedTeam(nullptr, ::std::move(from)) {}
  inline PlayerSwitchedTeam& operator=(const PlayerSwitchedTeam& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayerSwitchedTeam& operator=(PlayerSwitchedTeam&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlayerSwitchedTeam& default_instance() {
    return *reinterpret_cast<const PlayerSwitchedTeam*>(
        &_PlayerSwitchedTeam_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 13;
  friend void swap(PlayerSwitchedTeam& a, PlayerSwitchedTeam& b) { a.Swap(&b); }
  inline void Swap(PlayerSwitchedTeam* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlayerSwitchedTeam* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PlayerSwitchedTeam* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<PlayerSwitchedTeam>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PlayerSwitchedTeam& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const PlayerSwitchedTeam& from) { PlayerSwitchedTeam::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(PlayerSwitchedTeam* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "telemetry.v1.PlayerSwitchedTeam"; }

  explicit PlayerSwitchedTeam(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  PlayerSwitchedTeam(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const PlayerSwitchedTeam& from);
  PlayerSwitchedTeam(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, PlayerSwitchedTeam&& from) noexcept
      : PlayerSwitchedTeam(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPlayerSlotFieldNumber = 1,
    kNewRoleFieldNumber = 2,
    kPrevRoleFieldNumber = 3,
  };
  // int32 player_slot = 1 [json_name = "playerSlot"];
  void clear_player_slot() ;
  ::int32_t player_slot() const;
  void set_player_slot(::int32_t value);

  private:
  ::int32_t _internal_player_slot() const;
  void _internal_set_player_slot(::int32_t value);

  public:
  // .telemetry.v1.Role new_role = 2 [json_name = "newRole"];
  void clear_new_role() ;
  ::telemetry::v1::Role new_role() const;
  void set_new_role(::telemetry::v1::Role value);

  private:
  ::telemetry::v1::Role _internal_new_role() const;
  void _internal_set_new_role(::telemetry::v1::Role value);

  public:
  // .telemetry.v1.Role prev_role = 3 [json_name = "prevRole"];
  void clear_prev_role() ;
  ::telemetry::v1::Role prev_role() const;
  void set_prev_role(::telemetry::v1::Role value);

  private:
  ::telemetry::v1::Role _internal_prev_role() const;
  void _internal_set_prev_role(::telemetry::v1::Role value);

  public:
  // @@protoc_insertion_point(class_scope:telemetry.v1.PlayerSwitchedTeam)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const PlayerSwitchedTeam& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::int32_t player_slot_;
    int new_role_;
    int prev_role_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_telemetry_2fv1_2ftelemetry_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull PlayerSwitchedTeam_class_data_;
// -------------------------------------------------------------------

class PlayerStun final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:telemetry.v1.PlayerStun) */ {
 public:
  inline PlayerStun() : PlayerStun(nullptr) {}
  ~PlayerStun() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(PlayerStun* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(PlayerStun));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PlayerStun(::google::protobuf::internal::ConstantInitialized);

  inline PlayerStun(const PlayerStun& from) : PlayerStun(nullptr, from) {}
  inline PlayerStun(PlayerStun&& from) noexcept
      : PlayerStun(nullptr, ::std::move(from)) {}
  inline PlayerStun& operator=(const PlayerStun& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayerStun& operator=(PlayerStun&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlayerStun& default_instance() {
    return *reinterpret_cast<const PlayerStun*>(
        &_PlayerStun_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 21;
  friend void swap(PlayerStun& a, PlayerStun& b) { a.Swap(&b); }
  inline void Swap(PlayerStun* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlayerStun* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PlayerStun* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<PlayerStun>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PlayerStun& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const PlayerStun& from) { PlayerStun::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(PlayerStun* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "telemetry.v1.PlayerStun"; }

  explicit PlayerStun(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  PlayerStun(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const PlayerStun& from);
  PlayerStun(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, PlayerStun&& from) noexcept
      : PlayerStun(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPlayerSlotFieldNumber = 1,
    kTotalStunsFieldNumber = 2,
  };
  // int32 player_slot = 1 [json_name = "playerSlot"];
  void clear_player_slot() ;
  ::int32_t player_slot() const;
  void set_player_slot(::int32_t value);

  private:
  ::int32_t _internal_player_slot() const;
  void _internal_set_player_slot(::int32_t value);

  public:
  // int32 total_stuns = 2 [json_name = "totalStuns"];
  void clear_total_stuns() ;
  ::int32_t total_stuns() const;
  void set_total_stuns(::int32_t value);

  private:
  ::int32_t _internal_total_stuns() const;
  void _internal_set_total_stuns(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:telemetry.v1.PlayerStun)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const PlayerStun& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::int32_t player_slot_;
    ::int32_t total_stuns_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_telemetry_2fv1_2ftelemetry_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull PlayerStun_class_data_;
// -------------------------------------------------------------------

class PlayerSteal final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:telemetry.v1.PlayerSteal) */ {
 public:
  inline PlayerSteal() : PlayerSteal(nullptr) {}
  ~PlayerSteal() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(PlayerSteal* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(PlayerSteal));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PlayerSteal(::google::protobuf::internal::ConstantInitialized);

  inline PlayerSteal(const PlayerSteal& from) : PlayerSteal(nullptr, from) {}
  inline PlayerSteal(PlayerSteal&& from) noexcept
      : PlayerSteal(nullptr, ::std::move(from)) {}
  inline PlayerSteal& operator=(const PlayerSteal& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayerSteal& operator=(PlayerSteal&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlayerSteal& default_instance() {
    return *reinterpret_cast<const PlayerSteal*>(
        &_PlayerSteal_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 23;
  friend void swap(PlayerSteal& a, PlayerSteal& b) { a.Swap(&b); }
  inline void Swap(PlayerSteal* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlayerSteal* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PlayerSteal* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<PlayerSteal>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PlayerSteal& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const PlayerSteal& from) { PlayerSteal::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(PlayerSteal* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "telemetry.v1.PlayerSteal"; }

  explicit PlayerSteal(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  PlayerSteal(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const PlayerSteal& from);
  PlayerSteal(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, PlayerSteal&& from) noexcept
      : PlayerSteal(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPlayerSlotFieldNumber = 1,
    kTotalStealsFieldNumber = 2,
  };
  // int32 player_slot = 1 [json_name = "playerSlot"];
  void clear_player_slot() ;
  ::int32_t player_slot() const;
  void set_player_slot(::int32_t value);

  private:
  ::int32_t _internal_player_slot() const;
  void _internal_set_player_slot(::int32_t value);

  public:
  // int32 total_steals = 2 [json_name = "totalSteals"];
  void clear_total_steals() ;
  ::int32_t total_steals() const;
  void set_total_steals(::int32_t value);

  private:
  ::int32_t _internal_total_steals() const;
  void _internal_set_total_steals(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:telemetry.v1.PlayerSteal)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const PlayerSteal& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::int32_t player_slot_;
    ::int32_t total_steals_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_telemetry_2fv1_2ftelemetry_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull PlayerSteal_class_data_;
// -------------------------------------------------------------------

class PlayerShotTaken final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:telemetry.v1.PlayerShotTaken) */ {
 public:
  inline PlayerShotTaken() : PlayerShotTaken(nullptr) {}
  ~PlayerShotTaken() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(PlayerShotTaken* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(PlayerShotTaken));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PlayerShotTaken(::google::protobuf::internal::ConstantInitialized);

  inline PlayerShotTaken(const PlayerShotTaken& from) : PlayerShotTaken(nullptr, from) {}
  inline PlayerShotTaken(PlayerShotTaken&& from) noexcept
      : PlayerShotTaken(nullptr, ::std::move(from)) {}
  inline PlayerShotTaken& operator=(const PlayerShotTaken& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayerShotTaken& operator=(PlayerShotTaken&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlayerShotTaken& default_instance() {
    return *reinterpret_cast<const PlayerShotTaken*>(
        &_PlayerShotTaken_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 27;
  friend void swap(PlayerShotTaken& a, PlayerShotTaken& b) { a.Swap(&b); }
  inline void Swap(PlayerShotTaken* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlayerShotTaken* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PlayerShotTaken* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<PlayerShotTaken>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PlayerShotTaken& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const PlayerShotTaken& from) { PlayerShotTaken::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(PlayerShotTaken* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "telemetry.v1.PlayerShotTaken"; }

  explicit PlayerShotTaken(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  PlayerShotTaken(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const PlayerShotTaken& from);
  PlayerShotTaken(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, PlayerShotTaken&& from) noexcept
      : PlayerShotTaken(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPlayerSlotFieldNumber = 1,
    kTotalShotsFieldNumber = 2,
  };
  // int32 player_slot = 1 [json_name = "playerSlot"];
  void clear_player_slot() ;
  ::int32_t player_slot() const;
  void set_player_slot(::int32_t value);

  private:
  ::int32_t _internal_player_slot() const;
  void _internal_set_player_slot(::int32_t value);

  public:
  // int32 total_shots = 2 [json_name = "totalShots"];
  void clear_total_shots() ;
  ::int32_t total_shots() const;
  void set_total_shots(::int32_t value);

  private:
  ::int32_t _internal_total_shots() const;
  void _internal_set_total_shots(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:telemetry.v1.PlayerShotTaken)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const PlayerShotTaken& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::int32_t player_slot_;
    ::int32_t total_shots_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_telemetry_2fv1_2ftelemetry_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull PlayerShotTaken_class_data_;
// -------------------------------------------------------------------

class PlayerSave final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:telemetry.v1.PlayerSave) */ {
 public:
  inline PlayerSave() : PlayerSave(nullptr) {}
  ~PlayerSave() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(PlayerSave* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(PlayerSave));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PlayerSave(::google::protobuf::internal::ConstantInitialized);

  inline PlayerSave(const PlayerSave& from) : PlayerSave(nullptr, from) {}
  inline PlayerSave(PlayerSave&& from) noexcept
      : PlayerSave(nullptr, ::std::move(from)) {}
  inline PlayerSave& operator=(const PlayerSave& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayerSave& operator=(PlayerSave&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlayerSave& default_instance() {
    return *reinterpret_cast<const PlayerSave*>(
        &_PlayerSave_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 20;
  friend void swap(PlayerSave& a, PlayerSave& b) { a.Swap(&b); }
  inline void Swap(PlayerSave* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlayerSave* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PlayerSave* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<PlayerSave>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PlayerSave& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const PlayerSave& from) { PlayerSave::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(PlayerSave* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "telemetry.v1.PlayerSave"; }

  explicit PlayerSave(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  PlayerSave(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const PlayerSave& from);
  PlayerSave(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, PlayerSave&& from) noexcept
      : PlayerSave(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPlayerSlotFieldNumber = 1,
    kTotalSavesFieldNumber = 2,
  };
  // int32 player_slot = 1 [json_name = "playerSlot"];
  void clear_player_slot() ;
  ::int32_t player_slot() const;
  void set_player_slot(::int32_t value);

  private:
  ::int32_t _internal_player_slot() const;
  void _internal_set_player_slot(::int32_t value);

  public:
  // int32 total_saves = 2 [json_name = "totalSaves"];
  void clear_total_saves() ;
  ::int32_t total_saves() const;
  void set_total_saves(::int32_t value);

  private:
  ::int32_t _internal_total_saves() const;
  void _internal_set_total_saves(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:telemetry.v1.PlayerSave)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const PlayerSave& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::int32_t player_slot_;
    ::int32_t total_saves_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_telemetry_2fv1_2ftelemetry_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull PlayerSave_class_data_;
// -------------------------------------------------------------------

class PlayerPass final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:telemetry.v1.PlayerPass) */ {
 public:
  inline PlayerPass() : PlayerPass(nullptr) {}
  ~PlayerPass() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(PlayerPass* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(PlayerPass));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PlayerPass(::google::protobuf::internal::ConstantInitialized);

  inline PlayerPass(const PlayerPass& from) : PlayerPass(nullptr, from) {}
  inline PlayerPass(PlayerPass&& from) noexcept
      : PlayerPass(nullptr, ::std::move(from)) {}
  inline PlayerPass& operator=(const PlayerPass& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayerPass& operator=(PlayerPass&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlayerPass& default_instance() {
    return *reinterpret_cast<const PlayerPass*>(
        &_PlayerPass_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 22;
  friend void swap(PlayerPass& a, PlayerPass& b) { a.Swap(&b); }
  inline void Swap(PlayerPass* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlayerPass* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PlayerPass* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<PlayerPass>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PlayerPass& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const PlayerPass& from) { PlayerPass::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(PlayerPass* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "telemetry.v1.PlayerPass"; }

  explicit PlayerPass(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  PlayerPass(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const PlayerPass& from);
  PlayerPass(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, PlayerPass&& from) noexcept
      : PlayerPass(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPlayerSlotFieldNumber = 1,
    kTotalPassesFieldNumber = 2,
  };
  // int32 player_slot = 1 [json_name = "playerSlot"];
  void clear_player_slot() ;
  ::int32_t player_slot() const;
  void set_player_slot(::int32_t value);

  private:
  ::int32_t _internal_player_slot() const;
  void _internal_set_player_slot(::int32_t value);

  public:
  // int32 total_passes = 2 [json_name = "totalPasses"];
  void clear_total_passes() ;
  ::int32_t total_passes() const;
  void set_total_passes(::int32_t value);

  private:
  ::int32_t _internal_total_passes() const;
  void _internal_set_total_passes(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:telemetry.v1.PlayerPass)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const PlayerPass& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::int32_t player_slot_;
    ::int32_t total_passes_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_telemetry_2fv1_2ftelemetry_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull PlayerPass_class_data_;
// -------------------------------------------------------------------

class PlayerLeft final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:telemetry.v1.PlayerLeft) */ {
 public:
  inline PlayerLeft() : PlayerLeft(nullptr) {}
  ~PlayerLeft() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(PlayerLeft* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(PlayerLeft));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PlayerLeft(::google::protobuf::internal::ConstantInitialized);

  inline PlayerLeft(const PlayerLeft& from) : PlayerLeft(nullptr, from) {}
  inline PlayerLeft(PlayerLeft&& from) noexcept
      : PlayerLeft(nullptr, ::std::move(from)) {}
  inline PlayerLeft& operator=(const PlayerLeft& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayerLeft& operator=(PlayerLeft&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlayerLeft& default_instance() {
    return *reinterpret_cast<const PlayerLeft*>(
        &_PlayerLeft_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 12;
  friend void swap(PlayerLeft& a, PlayerLeft& b) { a.Swap(&b); }
  inline void Swap(PlayerLeft* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlayerLeft* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PlayerLeft* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<PlayerLeft>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PlayerLeft& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const PlayerLeft& from) { PlayerLeft::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(PlayerLeft* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "telemetry.v1.PlayerLeft"; }

  explicit PlayerLeft(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  PlayerLeft(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const PlayerLeft& from);
  PlayerLeft(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, PlayerLeft&& from) noexcept
      : PlayerLeft(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kDisplayNameFieldNumber = 2,
    kPlayerSlotFieldNumber = 1,
  };
  // string display_name = 2 [json_name = "displayName"];
  void clear_display_name() ;
  const ::std::string& display_name() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_display_name(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_display_name();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_display_name();
  void set_allocated_display_name(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_display_name() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_display_name(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_display_name();

  public:
  // int32 player_slot = 1 [json_name = "playerSlot"];
  void clear_player_slot() ;
  ::int32_t player_slot() const;
  void set_player_slot(::int32_t value);

  private:
  ::int32_t _internal_player_slot() const;
  void _internal_set_player_slot(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:telemetry.v1.PlayerLeft)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   0, 44,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const PlayerLeft& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr display_name_;
    ::int32_t player_slot_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_telemetry_2fv1_2ftelemetry_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull PlayerLeft_class_data_;
// -------------------------------------------------------------------

class PlayerInterception final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:telemetry.v1.PlayerInterception) */ {
 public:
  inline PlayerInterception() : PlayerInterception(nullptr) {}
  ~PlayerInterception() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(PlayerInterception* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(PlayerInterception));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PlayerInterception(::google::protobuf::internal::ConstantInitialized);

  inline PlayerInterception(const PlayerInterception& from) : PlayerInterception(nullptr, from) {}
  inline PlayerInterception(PlayerInterception&& from) noexcept
      : PlayerInterception(nullptr, ::std::move(from)) {}
  inline PlayerInterception& operator=(const PlayerInterception& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayerInterception& operator=(PlayerInterception&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlayerInterception& default_instance() {
    return *reinterpret_cast<const PlayerInterception*>(
        &_PlayerInterception_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 25;
  friend void swap(PlayerInterception& a, PlayerInterception& b) { a.Swap(&b); }
  inline void Swap(PlayerInterception* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlayerInterception* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PlayerInterception* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<PlayerInterception>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PlayerInterception& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const PlayerInterception& from) { PlayerInterception::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(PlayerInterception* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "telemetry.v1.PlayerInterception"; }

  explicit PlayerInterception(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  PlayerInterception(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const PlayerInterception& from);
  PlayerInterception(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, PlayerInterception&& from) noexcept
      : PlayerInterception(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPlayerSlotFieldNumber = 1,
    kTotalInterceptionsFieldNumber = 2,
  };
  // int32 player_slot = 1 [json_name = "playerSlot"];
  void clear_player_slot() ;
  ::int32_t player_slot() const;
  void set_player_slot(::int32_t value);

  private:
  ::int32_t _internal_player_slot() const;
  void _internal_set_player_slot(::int32_t value);

  public:
  // int32 total_interceptions = 2 [json_name = "totalInterceptions"];
  void clear_total_interceptions() ;
  ::int32_t total_interceptions() const;
  void set_total_interceptions(::int32_t value);

  private:
  ::int32_t _internal_total_interceptions() const;
  void _internal_set_total_interceptions(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:telemetry.v1.PlayerInterception)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const PlayerInterception& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::int32_t player_slot_;
    ::int32_t total_interceptions_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_telemetry_2fv1_2ftelemetry_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull PlayerInterception_class_data_;
// -------------------------------------------------------------------

class PlayerGoal final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:telemetry.v1.PlayerGoal) */ {
 public:
  inline PlayerGoal() : PlayerGoal(nullptr) {}
  ~PlayerGoal() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(PlayerGoal* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(PlayerGoal));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PlayerGoal(::google::protobuf::internal::ConstantInitialized);

  inline PlayerGoal(const PlayerGoal& from) : PlayerGoal(nullptr, from) {}
  inline PlayerGoal(PlayerGoal&& from) noexcept
      : PlayerGoal(nullptr, ::std::move(from)) {}
  inline PlayerGoal& operator=(const PlayerGoal& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayerGoal& operator=(PlayerGoal&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlayerGoal& default_instance() {
    return *reinterpret_cast<const PlayerGoal*>(
        &_PlayerGoal_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 19;
  friend void swap(PlayerGoal& a, PlayerGoal& b) { a.Swap(&b); }
  inline void Swap(PlayerGoal* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlayerGoal* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PlayerGoal* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<PlayerGoal>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PlayerGoal& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const PlayerGoal& from) { PlayerGoal::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(PlayerGoal* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "telemetry.v1.PlayerGoal"; }

  explicit PlayerGoal(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  PlayerGoal(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const PlayerGoal& from);
  PlayerGoal(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, PlayerGoal&& from) noexcept
      : PlayerGoal(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPlayerSlotFieldNumber = 1,
    kTotalGoalsFieldNumber = 2,
    kPointsFieldNumber = 3,
  };
  // int32 player_slot = 1 [json_name = "playerSlot"];
  void clear_player_slot() ;
  ::int32_t player_slot() const;
  void set_player_slot(::int32_t value);

  private:
  ::int32_t _internal_player_slot() const;
  void _internal_set_player_slot(::int32_t value);

  public:
  // int32 total_goals = 2 [json_name = "totalGoals"];
  void clear_total_goals() ;
  ::int32_t total_goals() const;
  void set_total_goals(::int32_t value);

  private:
  ::int32_t _internal_total_goals() const;
  void _internal_set_total_goals(::int32_t value);

  public:
  // int32 points = 3 [json_name = "points"];
  void clear_points() ;
  ::int32_t points() const;
  void set_points(::int32_t value);

  private:
  ::int32_t _internal_points() const;
  void _internal_set_points(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:telemetry.v1.PlayerGoal)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const PlayerGoal& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::int32_t player_slot_;
    ::int32_t total_goals_;
    ::int32_t points_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_telemetry_2fv1_2ftelemetry_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull PlayerGoal_class_data_;
// -------------------------------------------------------------------

class PlayerBlock final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:telemetry.v1.PlayerBlock) */ {
 public:
  inline PlayerBlock() : PlayerBlock(nullptr) {}
  ~PlayerBlock() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(PlayerBlock* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(PlayerBlock));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PlayerBlock(::google::protobuf::internal::ConstantInitialized);

  inline PlayerBlock(const PlayerBlock& from) : PlayerBlock(nullptr, from) {}
  inline PlayerBlock(PlayerBlock&& from) noexcept
      : PlayerBlock(nullptr, ::std::move(from)) {}
  inline PlayerBlock& operator=(const PlayerBlock& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayerBlock& operator=(PlayerBlock&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlayerBlock& default_instance() {
    return *reinterpret_cast<const PlayerBlock*>(
        &_PlayerBlock_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 24;
  friend void swap(PlayerBlock& a, PlayerBlock& b) { a.Swap(&b); }
  inline void Swap(PlayerBlock* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlayerBlock* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PlayerBlock* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<PlayerBlock>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PlayerBlock& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const PlayerBlock& from) { PlayerBlock::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(PlayerBlock* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "telemetry.v1.PlayerBlock"; }

  explicit PlayerBlock(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  PlayerBlock(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const PlayerBlock& from);
  PlayerBlock(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, PlayerBlock&& from) noexcept
      : PlayerBlock(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPlayerSlotFieldNumber = 1,
    kTotalBlocksFieldNumber = 2,
  };
  // int32 player_slot = 1 [json_name = "playerSlot"];
  void clear_player_slot() ;
  ::int32_t player_slot() const;
  void set_player_slot(::int32_t value);

  private:
  ::int32_t _internal_player_slot() const;
  void _internal_set_player_slot(::int32_t value);

  public:
  // int32 total_blocks = 2 [json_name = "totalBlocks"];
  void clear_total_blocks() ;
  ::int32_t total_blocks() const;
  void set_total_blocks(::int32_t value);

  private:
  ::int32_t _internal_total_blocks() const;
  void _internal_set_total_blocks(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:telemetry.v1.PlayerBlock)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const PlayerBlock& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::int32_t player_slot_;
    ::int32_t total_blocks_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_telemetry_2fv1_2ftelemetry_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull PlayerBlock_class_data_;
// -------------------------------------------------------------------

class PlayerAssist final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:telemetry.v1.PlayerAssist) */ {
 public:
  inline PlayerAssist() : PlayerAssist(nullptr) {}
  ~PlayerAssist() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(PlayerAssist* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(PlayerAssist));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PlayerAssist(::google::protobuf::internal::ConstantInitialized);

  inline PlayerAssist(const PlayerAssist& from) : PlayerAssist(nullptr, from) {}
  inline PlayerAssist(PlayerAssist&& from) noexcept
      : PlayerAssist(nullptr, ::std::move(from)) {}
  inline PlayerAssist& operator=(const PlayerAssist& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayerAssist& operator=(PlayerAssist&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlayerAssist& default_instance() {
    return *reinterpret_cast<const PlayerAssist*>(
        &_PlayerAssist_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 26;
  friend void swap(PlayerAssist& a, PlayerAssist& b) { a.Swap(&b); }
  inline void Swap(PlayerAssist* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlayerAssist* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PlayerAssist* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<PlayerAssist>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PlayerAssist& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const PlayerAssist& from) { PlayerAssist::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(PlayerAssist* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "telemetry.v1.PlayerAssist"; }

  explicit PlayerAssist(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  PlayerAssist(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const PlayerAssist& from);
  PlayerAssist(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, PlayerAssist&& from) noexcept
      : PlayerAssist(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPlayerSlotFieldNumber = 1,
    kTotalAssistsFieldNumber = 2,
  };
  // int32 player_slot = 1 [json_name = "playerSlot"];
  void clear_player_slot() ;
  ::int32_t player_slot() const;
  void set_player_slot(::int32_t value);

  private:
  ::int32_t _internal_player_slot() const;
  void _internal_set_player_slot(::int32_t value);

  public:
  // int32 total_assists = 2 [json_name = "totalAssists"];
  void clear_total_assists() ;
  ::int32_t total_assists() const;
  void set_total_assists(::int32_t value);

  private:
  ::int32_t _internal_total_assists() const;
  void _internal_set_total_assists(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:telemetry.v1.PlayerAssist)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const PlayerAssist& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::int32_t player_slot_;
    ::int32_t total_assists_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_telemetry_2fv1_2ftelemetry_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull PlayerAssist_class_data_;
// -------------------------------------------------------------------

class MatchEnded final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:telemetry.v1.MatchEnded) */ {
 public:
  inline MatchEnded() : MatchEnded(nullptr) {}
  ~MatchEnded() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(MatchEnded* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(MatchEnded));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR MatchEnded(::google::protobuf::internal::ConstantInitialized);

  inline MatchEnded(const MatchEnded& from) : MatchEnded(nullptr, from) {}
  inline MatchEnded(MatchEnded&& from) noexcept
      : MatchEnded(nullptr, ::std::move(from)) {}
  inline MatchEnded& operator=(const MatchEnded& from) {
    CopyFrom(from);
    return *this;
  }
  inline MatchEnded& operator=(MatchEnded&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MatchEnded& default_instance() {
    return *reinterpret_cast<const MatchEnded*>(
        &_MatchEnded_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 9;
  friend void swap(MatchEnded& a, MatchEnded& b) { a.Swap(&b); }
  inline void Swap(MatchEnded* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MatchEnded* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MatchEnded* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<MatchEnded>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const MatchEnded& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const MatchEnded& from) { MatchEnded::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(MatchEnded* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "telemetry.v1.MatchEnded"; }

  explicit MatchEnded(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  MatchEnded(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const MatchEnded& from);
  MatchEnded(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, MatchEnded&& from) noexcept
      : MatchEnded(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kWinningTeamFieldNumber = 1,
  };
  // .telemetry.v1.Role winning_team = 1 [json_name = "winningTeam"];
  void clear_winning_team() ;
  ::telemetry::v1::Role winning_team() const;
  void set_winning_team(::telemetry::v1::Role value);

  private:
  ::telemetry::v1::Role _internal_winning_team() const;
  void _internal_set_winning_team(::telemetry::v1::Role value);

  public:
  // @@protoc_insertion_point(class_scope:telemetry.v1.MatchEnded)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const MatchEnded& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    int winning_team_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_telemetry_2fv1_2ftelemetry_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull MatchEnded_class_data_;
// -------------------------------------------------------------------

class EmotePlayed final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:telemetry.v1.EmotePlayed) */ {
 public:
  inline EmotePlayed() : EmotePlayed(nullptr) {}
  ~EmotePlayed() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(EmotePlayed* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(EmotePlayed));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR EmotePlayed(::google::protobuf::internal::ConstantInitialized);

  inline EmotePlayed(const EmotePlayed& from) : EmotePlayed(nullptr, from) {}
  inline EmotePlayed(EmotePlayed&& from) noexcept
      : EmotePlayed(nullptr, ::std::move(from)) {}
  inline EmotePlayed& operator=(const EmotePlayed& from) {
    CopyFrom(from);
    return *this;
  }
  inline EmotePlayed& operator=(EmotePlayed&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EmotePlayed& default_instance() {
    return *reinterpret_cast<const EmotePlayed*>(
        &_EmotePlayed_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 14;
  friend void swap(EmotePlayed& a, EmotePlayed& b) { a.Swap(&b); }
  inline void Swap(EmotePlayed* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EmotePlayed* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EmotePlayed* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<EmotePlayed>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const EmotePlayed& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const EmotePlayed& from) { EmotePlayed::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(EmotePlayed* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "telemetry.v1.EmotePlayed"; }

  explicit EmotePlayed(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  EmotePlayed(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const EmotePlayed& from);
  EmotePlayed(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, EmotePlayed&& from) noexcept
      : EmotePlayed(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using EmoteType = EmotePlayed_EmoteType;
  static constexpr EmoteType EMOTE_TYPE_UNSPECIFIED = EmotePlayed_EmoteType_EMOTE_TYPE_UNSPECIFIED;
  static constexpr EmoteType EMOTE_TYPE_PRIMARY = EmotePlayed_EmoteType_EMOTE_TYPE_PRIMARY;
  static constexpr EmoteType EMOTE_TYPE_SECONDARY = EmotePlayed_EmoteType_EMOTE_TYPE_SECONDARY;
  static inline bool EmoteType_IsValid(int value) {
    return EmotePlayed_EmoteType_IsValid(value);
  }
  static constexpr EmoteType EmoteType_MIN = EmotePlayed_EmoteType_EmoteType_MIN;
  static constexpr EmoteType EmoteType_MAX = EmotePlayed_EmoteType_EmoteType_MAX;
  static constexpr int EmoteType_ARRAYSIZE = EmotePlayed_EmoteType_EmoteType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL EmoteType_descriptor() {
    return EmotePlayed_EmoteType_descriptor();
  }
  template <typename T>
  static inline const ::std::string& EmoteType_Name(T value) {
    return EmotePlayed_EmoteType_Name(value);
  }
  static inline bool EmoteType_Parse(
      ::absl::string_view name, EmoteType* PROTOBUF_NONNULL value) {
    return EmotePlayed_EmoteType_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  enum : int {
    kPlayerSlotFieldNumber = 1,
    kEmoteFieldNumber = 2,
  };
  // int32 player_slot = 1 [json_name = "playerSlot"];
  void clear_player_slot() ;
  ::int32_t player_slot() const;
  void set_player_slot(::int32_t value);

  private:
  ::int32_t _internal_player_slot() const;
  void _internal_set_player_slot(::int32_t value);

  public:
  // .telemetry.v1.EmotePlayed.EmoteType emote = 2 [json_name = "emote"];
  void clear_emote() ;
  ::telemetry::v1::EmotePlayed_EmoteType emote() const;
  void set_emote(::telemetry::v1::EmotePlayed_EmoteType value);

  private:
  ::telemetry::v1::EmotePlayed_EmoteType _internal_emote() const;
  void _internal_set_emote(::telemetry::v1::EmotePlayed_EmoteType value);

  public:
  // @@protoc_insertion_point(class_scope:telemetry.v1.EmotePlayed)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const EmotePlayed& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::int32_t player_slot_;
    int emote_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_telemetry_2fv1_2ftelemetry_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull EmotePlayed_class_data_;
// -------------------------------------------------------------------

class DiscPossessionChanged final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:telemetry.v1.DiscPossessionChanged) */ {
 public:
  inline DiscPossessionChanged() : DiscPossessionChanged(nullptr) {}
  ~DiscPossessionChanged() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(DiscPossessionChanged* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(DiscPossessionChanged));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR DiscPossessionChanged(::google::protobuf::internal::ConstantInitialized);

  inline DiscPossessionChanged(const DiscPossessionChanged& from) : DiscPossessionChanged(nullptr, from) {}
  inline DiscPossessionChanged(DiscPossessionChanged&& from) noexcept
      : DiscPossessionChanged(nullptr, ::std::move(from)) {}
  inline DiscPossessionChanged& operator=(const DiscPossessionChanged& from) {
    CopyFrom(from);
    return *this;
  }
  inline DiscPossessionChanged& operator=(DiscPossessionChanged&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DiscPossessionChanged& default_instance() {
    return *reinterpret_cast<const DiscPossessionChanged*>(
        &_DiscPossessionChanged_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 15;
  friend void swap(DiscPossessionChanged& a, DiscPossessionChanged& b) { a.Swap(&b); }
  inline void Swap(DiscPossessionChanged* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DiscPossessionChanged* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DiscPossessionChanged* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<DiscPossessionChanged>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DiscPossessionChanged& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const DiscPossessionChanged& from) { DiscPossessionChanged::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(DiscPossessionChanged* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "telemetry.v1.DiscPossessionChanged"; }

  explicit DiscPossessionChanged(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  DiscPossessionChanged(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const DiscPossessionChanged& from);
  DiscPossessionChanged(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, DiscPossessionChanged&& from) noexcept
      : DiscPossessionChanged(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPlayerSlotFieldNumber = 1,
    kPreviousPlayerSlotFieldNumber = 2,
  };
  // int32 player_slot = 1 [json_name = "playerSlot"];
  void clear_player_slot() ;
  ::int32_t player_slot() const;
  void set_player_slot(::int32_t value);

  private:
  ::int32_t _internal_player_slot() const;
  void _internal_set_player_slot(::int32_t value);

  public:
  // int32 previous_player_slot = 2 [json_name = "previousPlayerSlot"];
  void clear_previous_player_slot() ;
  ::int32_t previous_player_slot() const;
  void set_previous_player_slot(::int32_t value);

  private:
  ::int32_t _internal_previous_player_slot() const;
  void _internal_set_previous_player_slot(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:telemetry.v1.DiscPossessionChanged)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const DiscPossessionChanged& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::int32_t player_slot_;
    ::int32_t previous_player_slot_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_telemetry_2fv1_2ftelemetry_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull DiscPossessionChanged_class_data_;
// -------------------------------------------------------------------

class DiscCaught final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:telemetry.v1.DiscCaught) */ {
 public:
  inline DiscCaught() : DiscCaught(nullptr) {}
  ~DiscCaught() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(DiscCaught* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(DiscCaught));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR DiscCaught(::google::protobuf::internal::ConstantInitialized);

  inline DiscCaught(const DiscCaught& from) : DiscCaught(nullptr, from) {}
  inline DiscCaught(DiscCaught&& from) noexcept
      : DiscCaught(nullptr, ::std::move(from)) {}
  inline DiscCaught& operator=(const DiscCaught& from) {
    CopyFrom(from);
    return *this;
  }
  inline DiscCaught& operator=(DiscCaught&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DiscCaught& default_instance() {
    return *reinterpret_cast<const DiscCaught*>(
        &_DiscCaught_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 17;
  friend void swap(DiscCaught& a, DiscCaught& b) { a.Swap(&b); }
  inline void Swap(DiscCaught* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DiscCaught* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DiscCaught* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<DiscCaught>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DiscCaught& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const DiscCaught& from) { DiscCaught::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(DiscCaught* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "telemetry.v1.DiscCaught"; }

  explicit DiscCaught(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  DiscCaught(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const DiscCaught& from);
  DiscCaught(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, DiscCaught&& from) noexcept
      : DiscCaught(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPlayerSlotFieldNumber = 1,
  };
  // int32 player_slot = 1 [json_name = "playerSlot"];
  void clear_player_slot() ;
  ::int32_t player_slot() const;
  void set_player_slot(::int32_t value);

  private:
  ::int32_t _internal_player_slot() const;
  void _internal_set_player_slot(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:telemetry.v1.DiscCaught)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const DiscCaught& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::int32_t player_slot_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_telemetry_2fv1_2ftelemetry_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull DiscCaught_class_data_;
// -------------------------------------------------------------------

class TelemetryHeader final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:telemetry.v1.TelemetryHeader) */ {
 public:
  inline TelemetryHeader() : TelemetryHeader(nullptr) {}
  ~TelemetryHeader() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(TelemetryHeader* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(TelemetryHeader));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR TelemetryHeader(::google::protobuf::internal::ConstantInitialized);

  inline TelemetryHeader(const TelemetryHeader& from) : TelemetryHeader(nullptr, from) {}
  inline TelemetryHeader(TelemetryHeader&& from) noexcept
      : TelemetryHeader(nullptr, ::std::move(from)) {}
  inline TelemetryHeader& operator=(const TelemetryHeader& from) {
    CopyFrom(from);
    return *this;
  }
  inline TelemetryHeader& operator=(TelemetryHeader&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TelemetryHeader& default_instance() {
    return *reinterpret_cast<const TelemetryHeader*>(
        &_TelemetryHeader_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 1;
  friend void swap(TelemetryHeader& a, TelemetryHeader& b) { a.Swap(&b); }
  inline void Swap(TelemetryHeader* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TelemetryHeader* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TelemetryHeader* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<TelemetryHeader>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TelemetryHeader& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const TelemetryHeader& from) { TelemetryHeader::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(TelemetryHeader* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "telemetry.v1.TelemetryHeader"; }

  explicit TelemetryHeader(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  TelemetryHeader(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const TelemetryHeader& from);
  TelemetryHeader(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, TelemetryHeader&& from) noexcept
      : TelemetryHeader(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kCaptureIdFieldNumber = 1,
    kCreatedAtFieldNumber = 2,
    kMetadataFieldNumber = 3,
  };
  // string capture_id = 1 [json_name = "captureId"];
  void clear_capture_id() ;
  const ::std::string& capture_id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_capture_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_capture_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_capture_id();
  void set_allocated_capture_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_capture_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_capture_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_capture_id();

  public:
  // .google.protobuf.Timestamp created_at = 2 [json_name = "createdAt"];
  bool has_created_at() const;
  void clear_created_at() ;
  const ::google::protobuf::Timestamp& created_at() const;
  [[nodiscard]] ::google::protobuf::Timestamp* PROTOBUF_NULLABLE release_created_at();
  ::google::protobuf::Timestamp* PROTOBUF_NONNULL mutable_created_at();
  void set_allocated_created_at(::google::protobuf::Timestamp* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_created_at(::google::protobuf::Timestamp* PROTOBUF_NULLABLE value);
  ::google::protobuf::Timestamp* PROTOBUF_NULLABLE unsafe_arena_release_created_at();

  private:
  const ::google::protobuf::Timestamp& _internal_created_at() const;
  ::google::protobuf::Timestamp* PROTOBUF_NONNULL _internal_mutable_created_at();

  public:
  // map<string, string> metadata = 3 [json_name = "metadata"];
  int metadata_size() const;
  private:
  int _internal_metadata_size() const;

  public:
  void clear_metadata() ;
  const ::google::protobuf::Map<::std::string, ::std::string>& metadata() const;
  ::google::protobuf::Map<::std::string, ::std::string>* PROTOBUF_NONNULL mutable_metadata();

  private:
  const ::google::protobuf::Map<::std::string, ::std::string>& _internal_metadata() const;
  ::google::protobuf::Map<::std::string, ::std::string>* PROTOBUF_NONNULL _internal_mutable_metadata();

  public:
  // @@protoc_insertion_point(class_scope:telemetry.v1.TelemetryHeader)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 3,
                                   2, 55,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const TelemetryHeader& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr capture_id_;
    ::google::protobuf::Timestamp* PROTOBUF_NULLABLE created_at_;
    ::google::protobuf::internal::MapField<TelemetryHeader_MetadataEntry_DoNotUse, ::std::string, ::std::string,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>
        metadata_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_telemetry_2fv1_2ftelemetry_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull TelemetryHeader_class_data_;
// -------------------------------------------------------------------

class RoundUnpaused final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:telemetry.v1.RoundUnpaused) */ {
 public:
  inline RoundUnpaused() : RoundUnpaused(nullptr) {}
  ~RoundUnpaused() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(RoundUnpaused* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(RoundUnpaused));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RoundUnpaused(::google::protobuf::internal::ConstantInitialized);

  inline RoundUnpaused(const RoundUnpaused& from) : RoundUnpaused(nullptr, from) {}
  inline RoundUnpaused(RoundUnpaused&& from) noexcept
      : RoundUnpaused(nullptr, ::std::move(from)) {}
  inline RoundUnpaused& operator=(const RoundUnpaused& from) {
    CopyFrom(from);
    return *this;
  }
  inline RoundUnpaused& operator=(RoundUnpaused&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RoundUnpaused& default_instance() {
    return *reinterpret_cast<const RoundUnpaused*>(
        &_RoundUnpaused_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 7;
  friend void swap(RoundUnpaused& a, RoundUnpaused& b) { a.Swap(&b); }
  inline void Swap(RoundUnpaused* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RoundUnpaused* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RoundUnpaused* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<RoundUnpaused>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RoundUnpaused& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RoundUnpaused& from) { RoundUnpaused::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(RoundUnpaused* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "telemetry.v1.RoundUnpaused"; }

  explicit RoundUnpaused(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  RoundUnpaused(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const RoundUnpaused& from);
  RoundUnpaused(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, RoundUnpaused&& from) noexcept
      : RoundUnpaused(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPauseStateFieldNumber = 1,
  };
  // .enginehttp.PauseState pause_state = 1 [json_name = "pauseState"];
  bool has_pause_state() const;
  void clear_pause_state() ;
  const ::enginehttp::PauseState& pause_state() const;
  [[nodiscard]] ::enginehttp::PauseState* PROTOBUF_NULLABLE release_pause_state();
  ::enginehttp::PauseState* PROTOBUF_NONNULL mutable_pause_state();
  void set_allocated_pause_state(::enginehttp::PauseState* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_pause_state(::enginehttp::PauseState* PROTOBUF_NULLABLE value);
  ::enginehttp::PauseState* PROTOBUF_NULLABLE unsafe_arena_release_pause_state();

  private:
  const ::enginehttp::PauseState& _internal_pause_state() const;
  ::enginehttp::PauseState* PROTOBUF_NONNULL _internal_mutable_pause_state();

  public:
  // @@protoc_insertion_point(class_scope:telemetry.v1.RoundUnpaused)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   1, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const RoundUnpaused& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::enginehttp::PauseState* PROTOBUF_NULLABLE pause_state_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_telemetry_2fv1_2ftelemetry_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull RoundUnpaused_class_data_;
// -------------------------------------------------------------------

class RoundPaused final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:telemetry.v1.RoundPaused) */ {
 public:
  inline RoundPaused() : RoundPaused(nullptr) {}
  ~RoundPaused() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(RoundPaused* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(RoundPaused));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RoundPaused(::google::protobuf::internal::ConstantInitialized);

  inline RoundPaused(const RoundPaused& from) : RoundPaused(nullptr, from) {}
  inline RoundPaused(RoundPaused&& from) noexcept
      : RoundPaused(nullptr, ::std::move(from)) {}
  inline RoundPaused& operator=(const RoundPaused& from) {
    CopyFrom(from);
    return *this;
  }
  inline RoundPaused& operator=(RoundPaused&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RoundPaused& default_instance() {
    return *reinterpret_cast<const RoundPaused*>(
        &_RoundPaused_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 6;
  friend void swap(RoundPaused& a, RoundPaused& b) { a.Swap(&b); }
  inline void Swap(RoundPaused* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RoundPaused* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RoundPaused* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<RoundPaused>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RoundPaused& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RoundPaused& from) { RoundPaused::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(RoundPaused* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "telemetry.v1.RoundPaused"; }

  explicit RoundPaused(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  RoundPaused(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const RoundPaused& from);
  RoundPaused(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, RoundPaused&& from) noexcept
      : RoundPaused(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPauseStateFieldNumber = 1,
  };
  // .enginehttp.PauseState pause_state = 1 [json_name = "pauseState"];
  bool has_pause_state() const;
  void clear_pause_state() ;
  const ::enginehttp::PauseState& pause_state() const;
  [[nodiscard]] ::enginehttp::PauseState* PROTOBUF_NULLABLE release_pause_state();
  ::enginehttp::PauseState* PROTOBUF_NONNULL mutable_pause_state();
  void set_allocated_pause_state(::enginehttp::PauseState* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_pause_state(::enginehttp::PauseState* PROTOBUF_NULLABLE value);
  ::enginehttp::PauseState* PROTOBUF_NULLABLE unsafe_arena_release_pause_state();

  private:
  const ::enginehttp::PauseState& _internal_pause_state() const;
  ::enginehttp::PauseState* PROTOBUF_NONNULL _internal_mutable_pause_state();

  public:
  // @@protoc_insertion_point(class_scope:telemetry.v1.RoundPaused)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   1, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const RoundPaused& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::enginehttp::PauseState* PROTOBUF_NULLABLE pause_state_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_telemetry_2fv1_2ftelemetry_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull RoundPaused_class_data_;
// -------------------------------------------------------------------

class GoalScored final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:telemetry.v1.GoalScored) */ {
 public:
  inline GoalScored() : GoalScored(nullptr) {}
  ~GoalScored() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(GoalScored* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(GoalScored));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GoalScored(::google::protobuf::internal::ConstantInitialized);

  inline GoalScored(const GoalScored& from) : GoalScored(nullptr, from) {}
  inline GoalScored(GoalScored&& from) noexcept
      : GoalScored(nullptr, ::std::move(from)) {}
  inline GoalScored& operator=(const GoalScored& from) {
    CopyFrom(from);
    return *this;
  }
  inline GoalScored& operator=(GoalScored&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GoalScored& default_instance() {
    return *reinterpret_cast<const GoalScored*>(
        &_GoalScored_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 18;
  friend void swap(GoalScored& a, GoalScored& b) { a.Swap(&b); }
  inline void Swap(GoalScored* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GoalScored* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GoalScored* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<GoalScored>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GoalScored& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GoalScored& from) { GoalScored::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(GoalScored* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "telemetry.v1.GoalScored"; }

  explicit GoalScored(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  GoalScored(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const GoalScored& from);
  GoalScored(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, GoalScored&& from) noexcept
      : GoalScored(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kScoreDetailsFieldNumber = 1,
  };
  // .enginehttp.LastScore score_details = 1 [json_name = "scoreDetails"];
  bool has_score_details() const;
  void clear_score_details() ;
  const ::enginehttp::LastScore& score_details() const;
  [[nodiscard]] ::enginehttp::LastScore* PROTOBUF_NULLABLE release_score_details();
  ::enginehttp::LastScore* PROTOBUF_NONNULL mutable_score_details();
  void set_allocated_score_details(::enginehttp::LastScore* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_score_details(::enginehttp::LastScore* PROTOBUF_NULLABLE value);
  ::enginehttp::LastScore* PROTOBUF_NULLABLE unsafe_arena_release_score_details();

  private:
  const ::enginehttp::LastScore& _internal_score_details() const;
  ::enginehttp::LastScore* PROTOBUF_NONNULL _internal_mutable_score_details();

  public:
  // @@protoc_insertion_point(class_scope:telemetry.v1.GoalScored)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   1, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const GoalScored& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::enginehttp::LastScore* PROTOBUF_NULLABLE score_details_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_telemetry_2fv1_2ftelemetry_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull GoalScored_class_data_;
// -------------------------------------------------------------------

class DiscThrown final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:telemetry.v1.DiscThrown) */ {
 public:
  inline DiscThrown() : DiscThrown(nullptr) {}
  ~DiscThrown() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(DiscThrown* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(DiscThrown));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR DiscThrown(::google::protobuf::internal::ConstantInitialized);

  inline DiscThrown(const DiscThrown& from) : DiscThrown(nullptr, from) {}
  inline DiscThrown(DiscThrown&& from) noexcept
      : DiscThrown(nullptr, ::std::move(from)) {}
  inline DiscThrown& operator=(const DiscThrown& from) {
    CopyFrom(from);
    return *this;
  }
  inline DiscThrown& operator=(DiscThrown&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DiscThrown& default_instance() {
    return *reinterpret_cast<const DiscThrown*>(
        &_DiscThrown_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 16;
  friend void swap(DiscThrown& a, DiscThrown& b) { a.Swap(&b); }
  inline void Swap(DiscThrown* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DiscThrown* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DiscThrown* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<DiscThrown>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DiscThrown& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const DiscThrown& from) { DiscThrown::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(DiscThrown* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "telemetry.v1.DiscThrown"; }

  explicit DiscThrown(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  DiscThrown(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const DiscThrown& from);
  DiscThrown(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, DiscThrown&& from) noexcept
      : DiscThrown(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kThrowDetailsFieldNumber = 2,
    kPlayerSlotFieldNumber = 1,
  };
  // .enginehttp.LastThrowInfo throw_details = 2 [json_name = "throwDetails"];
  bool has_throw_details() const;
  void clear_throw_details() ;
  const ::enginehttp::LastThrowInfo& throw_details() const;
  [[nodiscard]] ::enginehttp::LastThrowInfo* PROTOBUF_NULLABLE release_throw_details();
  ::enginehttp::LastThrowInfo* PROTOBUF_NONNULL mutable_throw_details();
  void set_allocated_throw_details(::enginehttp::LastThrowInfo* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_throw_details(::enginehttp::LastThrowInfo* PROTOBUF_NULLABLE value);
  ::enginehttp::LastThrowInfo* PROTOBUF_NULLABLE unsafe_arena_release_throw_details();

  private:
  const ::enginehttp::LastThrowInfo& _internal_throw_details() const;
  ::enginehttp::LastThrowInfo* PROTOBUF_NONNULL _internal_mutable_throw_details();

  public:
  // int32 player_slot = 1 [json_name = "playerSlot"];
  void clear_player_slot() ;
  ::int32_t player_slot() const;
  void set_player_slot(::int32_t value);

  private:
  ::int32_t _internal_player_slot() const;
  void _internal_set_player_slot(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:telemetry.v1.DiscThrown)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   1, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const DiscThrown& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::enginehttp::LastThrowInfo* PROTOBUF_NULLABLE throw_details_;
    ::int32_t player_slot_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_telemetry_2fv1_2ftelemetry_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull DiscThrown_class_data_;
// -------------------------------------------------------------------

class PlayerJoined final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:telemetry.v1.PlayerJoined) */ {
 public:
  inline PlayerJoined() : PlayerJoined(nullptr) {}
  ~PlayerJoined() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(PlayerJoined* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(PlayerJoined));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PlayerJoined(::google::protobuf::internal::ConstantInitialized);

  inline PlayerJoined(const PlayerJoined& from) : PlayerJoined(nullptr, from) {}
  inline PlayerJoined(PlayerJoined&& from) noexcept
      : PlayerJoined(nullptr, ::std::move(from)) {}
  inline PlayerJoined& operator=(const PlayerJoined& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayerJoined& operator=(PlayerJoined&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlayerJoined& default_instance() {
    return *reinterpret_cast<const PlayerJoined*>(
        &_PlayerJoined_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 11;
  friend void swap(PlayerJoined& a, PlayerJoined& b) { a.Swap(&b); }
  inline void Swap(PlayerJoined* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlayerJoined* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PlayerJoined* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<PlayerJoined>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PlayerJoined& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const PlayerJoined& from) { PlayerJoined::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(PlayerJoined* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "telemetry.v1.PlayerJoined"; }

  explicit PlayerJoined(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  PlayerJoined(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const PlayerJoined& from);
  PlayerJoined(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, PlayerJoined&& from) noexcept
      : PlayerJoined(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPlayerFieldNumber = 1,
    kRoleFieldNumber = 2,
  };
  // .enginehttp.TeamMember player = 1 [json_name = "player"];
  bool has_player() const;
  void clear_player() ;
  const ::enginehttp::TeamMember& player() const;
  [[nodiscard]] ::enginehttp::TeamMember* PROTOBUF_NULLABLE release_player();
  ::enginehttp::TeamMember* PROTOBUF_NONNULL mutable_player();
  void set_allocated_player(::enginehttp::TeamMember* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_player(::enginehttp::TeamMember* PROTOBUF_NULLABLE value);
  ::enginehttp::TeamMember* PROTOBUF_NULLABLE unsafe_arena_release_player();

  private:
  const ::enginehttp::TeamMember& _internal_player() const;
  ::enginehttp::TeamMember* PROTOBUF_NONNULL _internal_mutable_player();

  public:
  // .telemetry.v1.Role role = 2 [json_name = "role"];
  void clear_role() ;
  ::telemetry::v1::Role role() const;
  void set_role(::telemetry::v1::Role value);

  private:
  ::telemetry::v1::Role _internal_role() const;
  void _internal_set_role(::telemetry::v1::Role value);

  public:
  // @@protoc_insertion_point(class_scope:telemetry.v1.PlayerJoined)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   1, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const PlayerJoined& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::enginehttp::TeamMember* PROTOBUF_NULLABLE player_;
    int role_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_telemetry_2fv1_2ftelemetry_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull PlayerJoined_class_data_;
// -------------------------------------------------------------------

class LobbySessionEvent final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:telemetry.v1.LobbySessionEvent) */ {
 public:
  inline LobbySessionEvent() : LobbySessionEvent(nullptr) {}
  ~LobbySessionEvent() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(LobbySessionEvent* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(LobbySessionEvent));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR LobbySessionEvent(::google::protobuf::internal::ConstantInitialized);

  inline LobbySessionEvent(const LobbySessionEvent& from) : LobbySessionEvent(nullptr, from) {}
  inline LobbySessionEvent(LobbySessionEvent&& from) noexcept
      : LobbySessionEvent(nullptr, ::std::move(from)) {}
  inline LobbySessionEvent& operator=(const LobbySessionEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline LobbySessionEvent& operator=(LobbySessionEvent&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LobbySessionEvent& default_instance() {
    return *reinterpret_cast<const LobbySessionEvent*>(
        &_LobbySessionEvent_default_instance_);
  }
  enum EventCase {
    kRoundStarted = 10,
    kRoundPaused = 11,
    kRoundUnpaused = 12,
    kRoundEnded = 13,
    kMatchEnded = 14,
    kScoreboardUpdated = 15,
    kPlayerJoined = 20,
    kPlayerLeft = 21,
    kPlayerSwitchedTeam = 22,
    kEmotePlayed = 23,
    kDiscPossessionChanged = 30,
    kDiscThrown = 31,
    kDiscCaught = 32,
    kGoalScored = 40,
    kPlayerGoal = 41,
    kPlayerSave = 50,
    kPlayerStun = 51,
    kPlayerPass = 52,
    kPlayerSteal = 53,
    kPlayerBlock = 54,
    kPlayerInterception = 55,
    kPlayerAssist = 56,
    kPlayerShotTaken = 57,
    EVENT_NOT_SET = 0,
  };
  static constexpr int kIndexInFileMessages = 4;
  friend void swap(LobbySessionEvent& a, LobbySessionEvent& b) { a.Swap(&b); }
  inline void Swap(LobbySessionEvent* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LobbySessionEvent* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LobbySessionEvent* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<LobbySessionEvent>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const LobbySessionEvent& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const LobbySessionEvent& from) { LobbySessionEvent::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(LobbySessionEvent* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "telemetry.v1.LobbySessionEvent"; }

  explicit LobbySessionEvent(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  LobbySessionEvent(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const LobbySessionEvent& from);
  LobbySessionEvent(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, LobbySessionEvent&& from) noexcept
      : LobbySessionEvent(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kRoundStartedFieldNumber = 10,
    kRoundPausedFieldNumber = 11,
    kRoundUnpausedFieldNumber = 12,
    kRoundEndedFieldNumber = 13,
    kMatchEndedFieldNumber = 14,
    kScoreboardUpdatedFieldNumber = 15,
    kPlayerJoinedFieldNumber = 20,
    kPlayerLeftFieldNumber = 21,
    kPlayerSwitchedTeamFieldNumber = 22,
    kEmotePlayedFieldNumber = 23,
    kDiscPossessionChangedFieldNumber = 30,
    kDiscThrownFieldNumber = 31,
    kDiscCaughtFieldNumber = 32,
    kGoalScoredFieldNumber = 40,
    kPlayerGoalFieldNumber = 41,
    kPlayerSaveFieldNumber = 50,
    kPlayerStunFieldNumber = 51,
    kPlayerPassFieldNumber = 52,
    kPlayerStealFieldNumber = 53,
    kPlayerBlockFieldNumber = 54,
    kPlayerInterceptionFieldNumber = 55,
    kPlayerAssistFieldNumber = 56,
    kPlayerShotTakenFieldNumber = 57,
  };
  // .telemetry.v1.RoundStarted round_started = 10 [json_name = "roundStarted"];
  bool has_round_started() const;
  private:
  bool _internal_has_round_started() const;

  public:
  void clear_round_started() ;
  const ::telemetry::v1::RoundStarted& round_started() const;
  [[nodiscard]] ::telemetry::v1::RoundStarted* PROTOBUF_NULLABLE release_round_started();
  ::telemetry::v1::RoundStarted* PROTOBUF_NONNULL mutable_round_started();
  void set_allocated_round_started(::telemetry::v1::RoundStarted* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_round_started(::telemetry::v1::RoundStarted* PROTOBUF_NULLABLE value);
  ::telemetry::v1::RoundStarted* PROTOBUF_NULLABLE unsafe_arena_release_round_started();

  private:
  const ::telemetry::v1::RoundStarted& _internal_round_started() const;
  ::telemetry::v1::RoundStarted* PROTOBUF_NONNULL _internal_mutable_round_started();

  public:
  // .telemetry.v1.RoundPaused round_paused = 11 [json_name = "roundPaused"];
  bool has_round_paused() const;
  private:
  bool _internal_has_round_paused() const;

  public:
  void clear_round_paused() ;
  const ::telemetry::v1::RoundPaused& round_paused() const;
  [[nodiscard]] ::telemetry::v1::RoundPaused* PROTOBUF_NULLABLE release_round_paused();
  ::telemetry::v1::RoundPaused* PROTOBUF_NONNULL mutable_round_paused();
  void set_allocated_round_paused(::telemetry::v1::RoundPaused* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_round_paused(::telemetry::v1::RoundPaused* PROTOBUF_NULLABLE value);
  ::telemetry::v1::RoundPaused* PROTOBUF_NULLABLE unsafe_arena_release_round_paused();

  private:
  const ::telemetry::v1::RoundPaused& _internal_round_paused() const;
  ::telemetry::v1::RoundPaused* PROTOBUF_NONNULL _internal_mutable_round_paused();

  public:
  // .telemetry.v1.RoundUnpaused round_unpaused = 12 [json_name = "roundUnpaused"];
  bool has_round_unpaused() const;
  private:
  bool _internal_has_round_unpaused() const;

  public:
  void clear_round_unpaused() ;
  const ::telemetry::v1::RoundUnpaused& round_unpaused() const;
  [[nodiscard]] ::telemetry::v1::RoundUnpaused* PROTOBUF_NULLABLE release_round_unpaused();
  ::telemetry::v1::RoundUnpaused* PROTOBUF_NONNULL mutable_round_unpaused();
  void set_allocated_round_unpaused(::telemetry::v1::RoundUnpaused* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_round_unpaused(::telemetry::v1::RoundUnpaused* PROTOBUF_NULLABLE value);
  ::telemetry::v1::RoundUnpaused* PROTOBUF_NULLABLE unsafe_arena_release_round_unpaused();

  private:
  const ::telemetry::v1::RoundUnpaused& _internal_round_unpaused() const;
  ::telemetry::v1::RoundUnpaused* PROTOBUF_NONNULL _internal_mutable_round_unpaused();

  public:
  // .telemetry.v1.RoundEnded round_ended = 13 [json_name = "roundEnded"];
  bool has_round_ended() const;
  private:
  bool _internal_has_round_ended() const;

  public:
  void clear_round_ended() ;
  const ::telemetry::v1::RoundEnded& round_ended() const;
  [[nodiscard]] ::telemetry::v1::RoundEnded* PROTOBUF_NULLABLE release_round_ended();
  ::telemetry::v1::RoundEnded* PROTOBUF_NONNULL mutable_round_ended();
  void set_allocated_round_ended(::telemetry::v1::RoundEnded* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_round_ended(::telemetry::v1::RoundEnded* PROTOBUF_NULLABLE value);
  ::telemetry::v1::RoundEnded* PROTOBUF_NULLABLE unsafe_arena_release_round_ended();

  private:
  const ::telemetry::v1::RoundEnded& _internal_round_ended() const;
  ::telemetry::v1::RoundEnded* PROTOBUF_NONNULL _internal_mutable_round_ended();

  public:
  // .telemetry.v1.MatchEnded match_ended = 14 [json_name = "matchEnded"];
  bool has_match_ended() const;
  private:
  bool _internal_has_match_ended() const;

  public:
  void clear_match_ended() ;
  const ::telemetry::v1::MatchEnded& match_ended() const;
  [[nodiscard]] ::telemetry::v1::MatchEnded* PROTOBUF_NULLABLE release_match_ended();
  ::telemetry::v1::MatchEnded* PROTOBUF_NONNULL mutable_match_ended();
  void set_allocated_match_ended(::telemetry::v1::MatchEnded* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_match_ended(::telemetry::v1::MatchEnded* PROTOBUF_NULLABLE value);
  ::telemetry::v1::MatchEnded* PROTOBUF_NULLABLE unsafe_arena_release_match_ended();

  private:
  const ::telemetry::v1::MatchEnded& _internal_match_ended() const;
  ::telemetry::v1::MatchEnded* PROTOBUF_NONNULL _internal_mutable_match_ended();

  public:
  // .telemetry.v1.ScoreboardUpdated scoreboard_updated = 15 [json_name = "scoreboardUpdated"];
  bool has_scoreboard_updated() const;
  private:
  bool _internal_has_scoreboard_updated() const;

  public:
  void clear_scoreboard_updated() ;
  const ::telemetry::v1::ScoreboardUpdated& scoreboard_updated() const;
  [[nodiscard]] ::telemetry::v1::ScoreboardUpdated* PROTOBUF_NULLABLE release_scoreboard_updated();
  ::telemetry::v1::ScoreboardUpdated* PROTOBUF_NONNULL mutable_scoreboard_updated();
  void set_allocated_scoreboard_updated(::telemetry::v1::ScoreboardUpdated* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_scoreboard_updated(::telemetry::v1::ScoreboardUpdated* PROTOBUF_NULLABLE value);
  ::telemetry::v1::ScoreboardUpdated* PROTOBUF_NULLABLE unsafe_arena_release_scoreboard_updated();

  private:
  const ::telemetry::v1::ScoreboardUpdated& _internal_scoreboard_updated() const;
  ::telemetry::v1::ScoreboardUpdated* PROTOBUF_NONNULL _internal_mutable_scoreboard_updated();

  public:
  // .telemetry.v1.PlayerJoined player_joined = 20 [json_name = "playerJoined"];
  bool has_player_joined() const;
  private:
  bool _internal_has_player_joined() const;

  public:
  void clear_player_joined() ;
  const ::telemetry::v1::PlayerJoined& player_joined() const;
  [[nodiscard]] ::telemetry::v1::PlayerJoined* PROTOBUF_NULLABLE release_player_joined();
  ::telemetry::v1::PlayerJoined* PROTOBUF_NONNULL mutable_player_joined();
  void set_allocated_player_joined(::telemetry::v1::PlayerJoined* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_player_joined(::telemetry::v1::PlayerJoined* PROTOBUF_NULLABLE value);
  ::telemetry::v1::PlayerJoined* PROTOBUF_NULLABLE unsafe_arena_release_player_joined();

  private:
  const ::telemetry::v1::PlayerJoined& _internal_player_joined() const;
  ::telemetry::v1::PlayerJoined* PROTOBUF_NONNULL _internal_mutable_player_joined();

  public:
  // .telemetry.v1.PlayerLeft player_left = 21 [json_name = "playerLeft"];
  bool has_player_left() const;
  private:
  bool _internal_has_player_left() const;

  public:
  void clear_player_left() ;
  const ::telemetry::v1::PlayerLeft& player_left() const;
  [[nodiscard]] ::telemetry::v1::PlayerLeft* PROTOBUF_NULLABLE release_player_left();
  ::telemetry::v1::PlayerLeft* PROTOBUF_NONNULL mutable_player_left();
  void set_allocated_player_left(::telemetry::v1::PlayerLeft* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_player_left(::telemetry::v1::PlayerLeft* PROTOBUF_NULLABLE value);
  ::telemetry::v1::PlayerLeft* PROTOBUF_NULLABLE unsafe_arena_release_player_left();

  private:
  const ::telemetry::v1::PlayerLeft& _internal_player_left() const;
  ::telemetry::v1::PlayerLeft* PROTOBUF_NONNULL _internal_mutable_player_left();

  public:
  // .telemetry.v1.PlayerSwitchedTeam player_switched_team = 22 [json_name = "playerSwitchedTeam"];
  bool has_player_switched_team() const;
  private:
  bool _internal_has_player_switched_team() const;

  public:
  void clear_player_switched_team() ;
  const ::telemetry::v1::PlayerSwitchedTeam& player_switched_team() const;
  [[nodiscard]] ::telemetry::v1::PlayerSwitchedTeam* PROTOBUF_NULLABLE release_player_switched_team();
  ::telemetry::v1::PlayerSwitchedTeam* PROTOBUF_NONNULL mutable_player_switched_team();
  void set_allocated_player_switched_team(::telemetry::v1::PlayerSwitchedTeam* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_player_switched_team(::telemetry::v1::PlayerSwitchedTeam* PROTOBUF_NULLABLE value);
  ::telemetry::v1::PlayerSwitchedTeam* PROTOBUF_NULLABLE unsafe_arena_release_player_switched_team();

  private:
  const ::telemetry::v1::PlayerSwitchedTeam& _internal_player_switched_team() const;
  ::telemetry::v1::PlayerSwitchedTeam* PROTOBUF_NONNULL _internal_mutable_player_switched_team();

  public:
  // .telemetry.v1.EmotePlayed emote_played = 23 [json_name = "emotePlayed"];
  bool has_emote_played() const;
  private:
  bool _internal_has_emote_played() const;

  public:
  void clear_emote_played() ;
  const ::telemetry::v1::EmotePlayed& emote_played() const;
  [[nodiscard]] ::telemetry::v1::EmotePlayed* PROTOBUF_NULLABLE release_emote_played();
  ::telemetry::v1::EmotePlayed* PROTOBUF_NONNULL mutable_emote_played();
  void set_allocated_emote_played(::telemetry::v1::EmotePlayed* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_emote_played(::telemetry::v1::EmotePlayed* PROTOBUF_NULLABLE value);
  ::telemetry::v1::EmotePlayed* PROTOBUF_NULLABLE unsafe_arena_release_emote_played();

  private:
  const ::telemetry::v1::EmotePlayed& _internal_emote_played() const;
  ::telemetry::v1::EmotePlayed* PROTOBUF_NONNULL _internal_mutable_emote_played();

  public:
  // .telemetry.v1.DiscPossessionChanged disc_possession_changed = 30 [json_name = "discPossessionChanged"];
  bool has_disc_possession_changed() const;
  private:
  bool _internal_has_disc_possession_changed() const;

  public:
  void clear_disc_possession_changed() ;
  const ::telemetry::v1::DiscPossessionChanged& disc_possession_changed() const;
  [[nodiscard]] ::telemetry::v1::DiscPossessionChanged* PROTOBUF_NULLABLE release_disc_possession_changed();
  ::telemetry::v1::DiscPossessionChanged* PROTOBUF_NONNULL mutable_disc_possession_changed();
  void set_allocated_disc_possession_changed(::telemetry::v1::DiscPossessionChanged* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_disc_possession_changed(::telemetry::v1::DiscPossessionChanged* PROTOBUF_NULLABLE value);
  ::telemetry::v1::DiscPossessionChanged* PROTOBUF_NULLABLE unsafe_arena_release_disc_possession_changed();

  private:
  const ::telemetry::v1::DiscPossessionChanged& _internal_disc_possession_changed() const;
  ::telemetry::v1::DiscPossessionChanged* PROTOBUF_NONNULL _internal_mutable_disc_possession_changed();

  public:
  // .telemetry.v1.DiscThrown disc_thrown = 31 [json_name = "discThrown"];
  bool has_disc_thrown() const;
  private:
  bool _internal_has_disc_thrown() const;

  public:
  void clear_disc_thrown() ;
  const ::telemetry::v1::DiscThrown& disc_thrown() const;
  [[nodiscard]] ::telemetry::v1::DiscThrown* PROTOBUF_NULLABLE release_disc_thrown();
  ::telemetry::v1::DiscThrown* PROTOBUF_NONNULL mutable_disc_thrown();
  void set_allocated_disc_thrown(::telemetry::v1::DiscThrown* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_disc_thrown(::telemetry::v1::DiscThrown* PROTOBUF_NULLABLE value);
  ::telemetry::v1::DiscThrown* PROTOBUF_NULLABLE unsafe_arena_release_disc_thrown();

  private:
  const ::telemetry::v1::DiscThrown& _internal_disc_thrown() const;
  ::telemetry::v1::DiscThrown* PROTOBUF_NONNULL _internal_mutable_disc_thrown();

  public:
  // .telemetry.v1.DiscCaught disc_caught = 32 [json_name = "discCaught"];
  bool has_disc_caught() const;
  private:
  bool _internal_has_disc_caught() const;

  public:
  void clear_disc_caught() ;
  const ::telemetry::v1::DiscCaught& disc_caught() const;
  [[nodiscard]] ::telemetry::v1::DiscCaught* PROTOBUF_NULLABLE release_disc_caught();
  ::telemetry::v1::DiscCaught* PROTOBUF_NONNULL mutable_disc_caught();
  void set_allocated_disc_caught(::telemetry::v1::DiscCaught* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_disc_caught(::telemetry::v1::DiscCaught* PROTOBUF_NULLABLE value);
  ::telemetry::v1::DiscCaught* PROTOBUF_NULLABLE unsafe_arena_release_disc_caught();

  private:
  const ::telemetry::v1::DiscCaught& _internal_disc_caught() const;
  ::telemetry::v1::DiscCaught* PROTOBUF_NONNULL _internal_mutable_disc_caught();

  public:
  // .telemetry.v1.GoalScored goal_scored = 40 [json_name = "goalScored"];
  bool has_goal_scored() const;
  private:
  bool _internal_has_goal_scored() const;

  public:
  void clear_goal_scored() ;
  const ::telemetry::v1::GoalScored& goal_scored() const;
  [[nodiscard]] ::telemetry::v1::GoalScored* PROTOBUF_NULLABLE release_goal_scored();
  ::telemetry::v1::GoalScored* PROTOBUF_NONNULL mutable_goal_scored();
  void set_allocated_goal_scored(::telemetry::v1::GoalScored* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_goal_scored(::telemetry::v1::GoalScored* PROTOBUF_NULLABLE value);
  ::telemetry::v1::GoalScored* PROTOBUF_NULLABLE unsafe_arena_release_goal_scored();

  private:
  const ::telemetry::v1::GoalScored& _internal_goal_scored() const;
  ::telemetry::v1::GoalScored* PROTOBUF_NONNULL _internal_mutable_goal_scored();

  public:
  // .telemetry.v1.PlayerGoal player_goal = 41 [json_name = "playerGoal"];
  bool has_player_goal() const;
  private:
  bool _internal_has_player_goal() const;

  public:
  void clear_player_goal() ;
  const ::telemetry::v1::PlayerGoal& player_goal() const;
  [[nodiscard]] ::telemetry::v1::PlayerGoal* PROTOBUF_NULLABLE release_player_goal();
  ::telemetry::v1::PlayerGoal* PROTOBUF_NONNULL mutable_player_goal();
  void set_allocated_player_goal(::telemetry::v1::PlayerGoal* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_player_goal(::telemetry::v1::PlayerGoal* PROTOBUF_NULLABLE value);
  ::telemetry::v1::PlayerGoal* PROTOBUF_NULLABLE unsafe_arena_release_player_goal();

  private:
  const ::telemetry::v1::PlayerGoal& _internal_player_goal() const;
  ::telemetry::v1::PlayerGoal* PROTOBUF_NONNULL _internal_mutable_player_goal();

  public:
  // .telemetry.v1.PlayerSave player_save = 50 [json_name = "playerSave"];
  bool has_player_save() const;
  private:
  bool _internal_has_player_save() const;

  public:
  void clear_player_save() ;
  const ::telemetry::v1::PlayerSave& player_save() const;
  [[nodiscard]] ::telemetry::v1::PlayerSave* PROTOBUF_NULLABLE release_player_save();
  ::telemetry::v1::PlayerSave* PROTOBUF_NONNULL mutable_player_save();
  void set_allocated_player_save(::telemetry::v1::PlayerSave* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_player_save(::telemetry::v1::PlayerSave* PROTOBUF_NULLABLE value);
  ::telemetry::v1::PlayerSave* PROTOBUF_NULLABLE unsafe_arena_release_player_save();

  private:
  const ::telemetry::v1::PlayerSave& _internal_player_save() const;
  ::telemetry::v1::PlayerSave* PROTOBUF_NONNULL _internal_mutable_player_save();

  public:
  // .telemetry.v1.PlayerStun player_stun = 51 [json_name = "playerStun"];
  bool has_player_stun() const;
  private:
  bool _internal_has_player_stun() const;

  public:
  void clear_player_stun() ;
  const ::telemetry::v1::PlayerStun& player_stun() const;
  [[nodiscard]] ::telemetry::v1::PlayerStun* PROTOBUF_NULLABLE release_player_stun();
  ::telemetry::v1::PlayerStun* PROTOBUF_NONNULL mutable_player_stun();
  void set_allocated_player_stun(::telemetry::v1::PlayerStun* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_player_stun(::telemetry::v1::PlayerStun* PROTOBUF_NULLABLE value);
  ::telemetry::v1::PlayerStun* PROTOBUF_NULLABLE unsafe_arena_release_player_stun();

  private:
  const ::telemetry::v1::PlayerStun& _internal_player_stun() const;
  ::telemetry::v1::PlayerStun* PROTOBUF_NONNULL _internal_mutable_player_stun();

  public:
  // .telemetry.v1.PlayerPass player_pass = 52 [json_name = "playerPass"];
  bool has_player_pass() const;
  private:
  bool _internal_has_player_pass() const;

  public:
  void clear_player_pass() ;
  const ::telemetry::v1::PlayerPass& player_pass() const;
  [[nodiscard]] ::telemetry::v1::PlayerPass* PROTOBUF_NULLABLE release_player_pass();
  ::telemetry::v1::PlayerPass* PROTOBUF_NONNULL mutable_player_pass();
  void set_allocated_player_pass(::telemetry::v1::PlayerPass* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_player_pass(::telemetry::v1::PlayerPass* PROTOBUF_NULLABLE value);
  ::telemetry::v1::PlayerPass* PROTOBUF_NULLABLE unsafe_arena_release_player_pass();

  private:
  const ::telemetry::v1::PlayerPass& _internal_player_pass() const;
  ::telemetry::v1::PlayerPass* PROTOBUF_NONNULL _internal_mutable_player_pass();

  public:
  // .telemetry.v1.PlayerSteal player_steal = 53 [json_name = "playerSteal"];
  bool has_player_steal() const;
  private:
  bool _internal_has_player_steal() const;

  public:
  void clear_player_steal() ;
  const ::telemetry::v1::PlayerSteal& player_steal() const;
  [[nodiscard]] ::telemetry::v1::PlayerSteal* PROTOBUF_NULLABLE release_player_steal();
  ::telemetry::v1::PlayerSteal* PROTOBUF_NONNULL mutable_player_steal();
  void set_allocated_player_steal(::telemetry::v1::PlayerSteal* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_player_steal(::telemetry::v1::PlayerSteal* PROTOBUF_NULLABLE value);
  ::telemetry::v1::PlayerSteal* PROTOBUF_NULLABLE unsafe_arena_release_player_steal();

  private:
  const ::telemetry::v1::PlayerSteal& _internal_player_steal() const;
  ::telemetry::v1::PlayerSteal* PROTOBUF_NONNULL _internal_mutable_player_steal();

  public:
  // .telemetry.v1.PlayerBlock player_block = 54 [json_name = "playerBlock"];
  bool has_player_block() const;
  private:
  bool _internal_has_player_block() const;

  public:
  void clear_player_block() ;
  const ::telemetry::v1::PlayerBlock& player_block() const;
  [[nodiscard]] ::telemetry::v1::PlayerBlock* PROTOBUF_NULLABLE release_player_block();
  ::telemetry::v1::PlayerBlock* PROTOBUF_NONNULL mutable_player_block();
  void set_allocated_player_block(::telemetry::v1::PlayerBlock* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_player_block(::telemetry::v1::PlayerBlock* PROTOBUF_NULLABLE value);
  ::telemetry::v1::PlayerBlock* PROTOBUF_NULLABLE unsafe_arena_release_player_block();

  private:
  const ::telemetry::v1::PlayerBlock& _internal_player_block() const;
  ::telemetry::v1::PlayerBlock* PROTOBUF_NONNULL _internal_mutable_player_block();

  public:
  // .telemetry.v1.PlayerInterception player_interception = 55 [json_name = "playerInterception"];
  bool has_player_interception() const;
  private:
  bool _internal_has_player_interception() const;

  public:
  void clear_player_interception() ;
  const ::telemetry::v1::PlayerInterception& player_interception() const;
  [[nodiscard]] ::telemetry::v1::PlayerInterception* PROTOBUF_NULLABLE release_player_interception();
  ::telemetry::v1::PlayerInterception* PROTOBUF_NONNULL mutable_player_interception();
  void set_allocated_player_interception(::telemetry::v1::PlayerInterception* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_player_interception(::telemetry::v1::PlayerInterception* PROTOBUF_NULLABLE value);
  ::telemetry::v1::PlayerInterception* PROTOBUF_NULLABLE unsafe_arena_release_player_interception();

  private:
  const ::telemetry::v1::PlayerInterception& _internal_player_interception() const;
  ::telemetry::v1::PlayerInterception* PROTOBUF_NONNULL _internal_mutable_player_interception();

  public:
  // .telemetry.v1.PlayerAssist player_assist = 56 [json_name = "playerAssist"];
  bool has_player_assist() const;
  private:
  bool _internal_has_player_assist() const;

  public:
  void clear_player_assist() ;
  const ::telemetry::v1::PlayerAssist& player_assist() const;
  [[nodiscard]] ::telemetry::v1::PlayerAssist* PROTOBUF_NULLABLE release_player_assist();
  ::telemetry::v1::PlayerAssist* PROTOBUF_NONNULL mutable_player_assist();
  void set_allocated_player_assist(::telemetry::v1::PlayerAssist* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_player_assist(::telemetry::v1::PlayerAssist* PROTOBUF_NULLABLE value);
  ::telemetry::v1::PlayerAssist* PROTOBUF_NULLABLE unsafe_arena_release_player_assist();

  private:
  const ::telemetry::v1::PlayerAssist& _internal_player_assist() const;
  ::telemetry::v1::PlayerAssist* PROTOBUF_NONNULL _internal_mutable_player_assist();

  public:
  // .telemetry.v1.PlayerShotTaken player_shot_taken = 57 [json_name = "playerShotTaken"];
  bool has_player_shot_taken() const;
  private:
  bool _internal_has_player_shot_taken() const;

  public:
  void clear_player_shot_taken() ;
  const ::telemetry::v1::PlayerShotTaken& player_shot_taken() const;
  [[nodiscard]] ::telemetry::v1::PlayerShotTaken* PROTOBUF_NULLABLE release_player_shot_taken();
  ::telemetry::v1::PlayerShotTaken* PROTOBUF_NONNULL mutable_player_shot_taken();
  void set_allocated_player_shot_taken(::telemetry::v1::PlayerShotTaken* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_player_shot_taken(::telemetry::v1::PlayerShotTaken* PROTOBUF_NULLABLE value);
  ::telemetry::v1::PlayerShotTaken* PROTOBUF_NULLABLE unsafe_arena_release_player_shot_taken();

  private:
  const ::telemetry::v1::PlayerShotTaken& _internal_player_shot_taken() const;
  ::telemetry::v1::PlayerShotTaken* PROTOBUF_NONNULL _internal_mutable_player_shot_taken();

  public:
  void clear_event();
  EventCase event_case() const;
  // @@protoc_insertion_point(class_scope:telemetry.v1.LobbySessionEvent)
 private:
  class _Internal;
  void set_has_round_started();
  void set_has_round_paused();
  void set_has_round_unpaused();
  void set_has_round_ended();
  void set_has_match_ended();
  void set_has_scoreboard_updated();
  void set_has_player_joined();
  void set_has_player_left();
  void set_has_player_switched_team();
  void set_has_emote_played();
  void set_has_disc_possession_changed();
  void set_has_disc_thrown();
  void set_has_disc_caught();
  void set_has_goal_scored();
  void set_has_player_goal();
  void set_has_player_save();
  void set_has_player_stun();
  void set_has_player_pass();
  void set_has_player_steal();
  void set_has_player_block();
  void set_has_player_interception();
  void set_has_player_assist();
  void set_has_player_shot_taken();
  inline bool has_event() const;
  inline void clear_has_event();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 23,
                                   23, 0,
                                   9>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const LobbySessionEvent& from_msg);
    union EventUnion {
      constexpr EventUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE round_started_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE round_paused_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE round_unpaused_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE round_ended_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE match_ended_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE scoreboard_updated_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE player_joined_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE player_left_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE player_switched_team_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE emote_played_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE disc_possession_changed_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE disc_thrown_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE disc_caught_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE goal_scored_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE player_goal_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE player_save_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE player_stun_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE player_pass_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE player_steal_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE player_block_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE player_interception_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE player_assist_;
      ::google::protobuf::Message* PROTOBUF_NULLABLE player_shot_taken_;
    } event_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_telemetry_2fv1_2ftelemetry_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull LobbySessionEvent_class_data_;
// -------------------------------------------------------------------

class LobbySessionStateFrame final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:telemetry.v1.LobbySessionStateFrame) */ {
 public:
  inline LobbySessionStateFrame() : LobbySessionStateFrame(nullptr) {}
  ~LobbySessionStateFrame() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(LobbySessionStateFrame* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(LobbySessionStateFrame));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR LobbySessionStateFrame(::google::protobuf::internal::ConstantInitialized);

  inline LobbySessionStateFrame(const LobbySessionStateFrame& from) : LobbySessionStateFrame(nullptr, from) {}
  inline LobbySessionStateFrame(LobbySessionStateFrame&& from) noexcept
      : LobbySessionStateFrame(nullptr, ::std::move(from)) {}
  inline LobbySessionStateFrame& operator=(const LobbySessionStateFrame& from) {
    CopyFrom(from);
    return *this;
  }
  inline LobbySessionStateFrame& operator=(LobbySessionStateFrame&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LobbySessionStateFrame& default_instance() {
    return *reinterpret_cast<const LobbySessionStateFrame*>(
        &_LobbySessionStateFrame_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 3;
  friend void swap(LobbySessionStateFrame& a, LobbySessionStateFrame& b) { a.Swap(&b); }
  inline void Swap(LobbySessionStateFrame* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LobbySessionStateFrame* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LobbySessionStateFrame* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<LobbySessionStateFrame>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const LobbySessionStateFrame& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const LobbySessionStateFrame& from) { LobbySessionStateFrame::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(LobbySessionStateFrame* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "telemetry.v1.LobbySessionStateFrame"; }

  explicit LobbySessionStateFrame(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  LobbySessionStateFrame(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const LobbySessionStateFrame& from);
  LobbySessionStateFrame(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, LobbySessionStateFrame&& from) noexcept
      : LobbySessionStateFrame(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kEventsFieldNumber = 3,
    kTimestampFieldNumber = 2,
    kSessionFieldNumber = 4,
    kPlayerBonesFieldNumber = 5,
    kFrameIndexFieldNumber = 1,
  };
  // repeated .telemetry.v1.LobbySessionEvent events = 3 [json_name = "events"];
  int events_size() const;
  private:
  int _internal_events_size() const;

  public:
  void clear_events() ;
  ::telemetry::v1::LobbySessionEvent* PROTOBUF_NONNULL mutable_events(int index);
  ::google::protobuf::RepeatedPtrField<::telemetry::v1::LobbySessionEvent>* PROTOBUF_NONNULL mutable_events();

  private:
  const ::google::protobuf::RepeatedPtrField<::telemetry::v1::LobbySessionEvent>& _internal_events() const;
  ::google::protobuf::RepeatedPtrField<::telemetry::v1::LobbySessionEvent>* PROTOBUF_NONNULL _internal_mutable_events();
  public:
  const ::telemetry::v1::LobbySessionEvent& events(int index) const;
  ::telemetry::v1::LobbySessionEvent* PROTOBUF_NONNULL add_events();
  const ::google::protobuf::RepeatedPtrField<::telemetry::v1::LobbySessionEvent>& events() const;
  // .google.protobuf.Timestamp timestamp = 2 [json_name = "timestamp"];
  bool has_timestamp() const;
  void clear_timestamp() ;
  const ::google::protobuf::Timestamp& timestamp() const;
  [[nodiscard]] ::google::protobuf::Timestamp* PROTOBUF_NULLABLE release_timestamp();
  ::google::protobuf::Timestamp* PROTOBUF_NONNULL mutable_timestamp();
  void set_allocated_timestamp(::google::protobuf::Timestamp* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_timestamp(::google::protobuf::Timestamp* PROTOBUF_NULLABLE value);
  ::google::protobuf::Timestamp* PROTOBUF_NULLABLE unsafe_arena_release_timestamp();

  private:
  const ::google::protobuf::Timestamp& _internal_timestamp() const;
  ::google::protobuf::Timestamp* PROTOBUF_NONNULL _internal_mutable_timestamp();

  public:
  // .enginehttp.SessionResponse session = 4 [json_name = "session"];
  bool has_session() const;
  void clear_session() ;
  const ::enginehttp::SessionResponse& session() const;
  [[nodiscard]] ::enginehttp::SessionResponse* PROTOBUF_NULLABLE release_session();
  ::enginehttp::SessionResponse* PROTOBUF_NONNULL mutable_session();
  void set_allocated_session(::enginehttp::SessionResponse* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_session(::enginehttp::SessionResponse* PROTOBUF_NULLABLE value);
  ::enginehttp::SessionResponse* PROTOBUF_NULLABLE unsafe_arena_release_session();

  private:
  const ::enginehttp::SessionResponse& _internal_session() const;
  ::enginehttp::SessionResponse* PROTOBUF_NONNULL _internal_mutable_session();

  public:
  // .enginehttp.PlayerBonesResponse player_bones = 5 [json_name = "playerBones"];
  bool has_player_bones() const;
  void clear_player_bones() ;
  const ::enginehttp::PlayerBonesResponse& player_bones() const;
  [[nodiscard]] ::enginehttp::PlayerBonesResponse* PROTOBUF_NULLABLE release_player_bones();
  ::enginehttp::PlayerBonesResponse* PROTOBUF_NONNULL mutable_player_bones();
  void set_allocated_player_bones(::enginehttp::PlayerBonesResponse* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_player_bones(::enginehttp::PlayerBonesResponse* PROTOBUF_NULLABLE value);
  ::enginehttp::PlayerBonesResponse* PROTOBUF_NULLABLE unsafe_arena_release_player_bones();

  private:
  const ::enginehttp::PlayerBonesResponse& _internal_player_bones() const;
  ::enginehttp::PlayerBonesResponse* PROTOBUF_NONNULL _internal_mutable_player_bones();

  public:
  // uint32 frame_index = 1 [json_name = "frameIndex"];
  void clear_frame_index() ;
  ::uint32_t frame_index() const;
  void set_frame_index(::uint32_t value);

  private:
  ::uint32_t _internal_frame_index() const;
  void _internal_set_frame_index(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:telemetry.v1.LobbySessionStateFrame)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 5,
                                   4, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const LobbySessionStateFrame& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::telemetry::v1::LobbySessionEvent > events_;
    ::google::protobuf::Timestamp* PROTOBUF_NULLABLE timestamp_;
    ::enginehttp::SessionResponse* PROTOBUF_NULLABLE session_;
    ::enginehttp::PlayerBonesResponse* PROTOBUF_NULLABLE player_bones_;
    ::uint32_t frame_index_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_telemetry_2fv1_2ftelemetry_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull LobbySessionStateFrame_class_data_;
// -------------------------------------------------------------------

class Envelope final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:telemetry.v1.Envelope) */ {
 public:
  inline Envelope() : Envelope(nullptr) {}
  ~Envelope() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Envelope* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Envelope));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Envelope(::google::protobuf::internal::ConstantInitialized);

  inline Envelope(const Envelope& from) : Envelope(nullptr, from) {}
  inline Envelope(Envelope&& from) noexcept
      : Envelope(nullptr, ::std::move(from)) {}
  inline Envelope& operator=(const Envelope& from) {
    CopyFrom(from);
    return *this;
  }
  inline Envelope& operator=(Envelope&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Envelope& default_instance() {
    return *reinterpret_cast<const Envelope*>(
        &_Envelope_default_instance_);
  }
  enum MessageCase {
    kHeader = 1,
    kFrame = 2,
    MESSAGE_NOT_SET = 0,
  };
  static constexpr int kIndexInFileMessages = 2;
  friend void swap(Envelope& a, Envelope& b) { a.Swap(&b); }
  inline void Swap(Envelope* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Envelope* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Envelope* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Envelope>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Envelope& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Envelope& from) { Envelope::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Envelope* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "telemetry.v1.Envelope"; }

  explicit Envelope(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  Envelope(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Envelope& from);
  Envelope(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, Envelope&& from) noexcept
      : Envelope(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kHeaderFieldNumber = 1,
    kFrameFieldNumber = 2,
  };
  // .telemetry.v1.TelemetryHeader header = 1 [json_name = "header"];
  bool has_header() const;
  private:
  bool _internal_has_header() const;

  public:
  void clear_header() ;
  const ::telemetry::v1::TelemetryHeader& header() const;
  [[nodiscard]] ::telemetry::v1::TelemetryHeader* PROTOBUF_NULLABLE release_header();
  ::telemetry::v1::TelemetryHeader* PROTOBUF_NONNULL mutable_header();
  void set_allocated_header(::telemetry::v1::TelemetryHeader* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_header(::telemetry::v1::TelemetryHeader* PROTOBUF_NULLABLE value);
  ::telemetry::v1::TelemetryHeader* PROTOBUF_NULLABLE unsafe_arena_release_header();

  private:
  const ::telemetry::v1::TelemetryHeader& _internal_header() const;
  ::telemetry::v1::TelemetryHeader* PROTOBUF_NONNULL _internal_mutable_header();

  public:
  // .telemetry.v1.LobbySessionStateFrame frame = 2 [json_name = "frame"];
  bool has_frame() const;
  private:
  bool _internal_has_frame() const;

  public:
  void clear_frame() ;
  const ::telemetry::v1::LobbySessionStateFrame& frame() const;
  [[nodiscard]] ::telemetry::v1::LobbySessionStateFrame* PROTOBUF_NULLABLE release_frame();
  ::telemetry::v1::LobbySessionStateFrame* PROTOBUF_NONNULL mutable_frame();
  void set_allocated_frame(::telemetry::v1::LobbySessionStateFrame* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_frame(::telemetry::v1::LobbySessionStateFrame* PROTOBUF_NULLABLE value);
  ::telemetry::v1::LobbySessionStateFrame* PROTOBUF_NULLABLE unsafe_arena_release_frame();

  private:
  const ::telemetry::v1::LobbySessionStateFrame& _internal_frame() const;
  ::telemetry::v1::LobbySessionStateFrame* PROTOBUF_NONNULL _internal_mutable_frame();

  public:
  void clear_message();
  MessageCase message_case() const;
  // @@protoc_insertion_point(class_scope:telemetry.v1.Envelope)
 private:
  class _Internal;
  void set_has_header();
  void set_has_frame();
  inline bool has_message() const;
  inline void clear_has_message();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 2,
                                   2, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const Envelope& from_msg);
    union MessageUnion {
      constexpr MessageUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::telemetry::v1::TelemetryHeader* PROTOBUF_NULLABLE header_;
      ::telemetry::v1::LobbySessionStateFrame* PROTOBUF_NULLABLE frame_;
    } message_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_telemetry_2fv1_2ftelemetry_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull Envelope_class_data_;

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// TelemetryHeader

// string capture_id = 1 [json_name = "captureId"];
inline void TelemetryHeader::clear_capture_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.capture_id_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::std::string& TelemetryHeader::capture_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:telemetry.v1.TelemetryHeader.capture_id)
  return _internal_capture_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void TelemetryHeader::set_capture_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  _impl_.capture_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:telemetry.v1.TelemetryHeader.capture_id)
}
inline ::std::string* PROTOBUF_NONNULL TelemetryHeader::mutable_capture_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::std::string* _s = _internal_mutable_capture_id();
  // @@protoc_insertion_point(field_mutable:telemetry.v1.TelemetryHeader.capture_id)
  return _s;
}
inline const ::std::string& TelemetryHeader::_internal_capture_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.capture_id_.Get();
}
inline void TelemetryHeader::_internal_set_capture_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.capture_id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL TelemetryHeader::_internal_mutable_capture_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.capture_id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE TelemetryHeader::release_capture_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:telemetry.v1.TelemetryHeader.capture_id)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000001U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  auto* released = _impl_.capture_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.capture_id_.Set("", GetArena());
  }
  return released;
}
inline void TelemetryHeader::set_allocated_capture_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  _impl_.capture_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.capture_id_.IsDefault()) {
    _impl_.capture_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:telemetry.v1.TelemetryHeader.capture_id)
}

// .google.protobuf.Timestamp created_at = 2 [json_name = "createdAt"];
inline bool TelemetryHeader::has_created_at() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000002U);
  PROTOBUF_ASSUME(!value || _impl_.created_at_ != nullptr);
  return value;
}
inline const ::google::protobuf::Timestamp& TelemetryHeader::_internal_created_at() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::google::protobuf::Timestamp* p = _impl_.created_at_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Timestamp&>(::google::protobuf::_Timestamp_default_instance_);
}
inline const ::google::protobuf::Timestamp& TelemetryHeader::created_at() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:telemetry.v1.TelemetryHeader.created_at)
  return _internal_created_at();
}
inline void TelemetryHeader::unsafe_arena_set_allocated_created_at(
    ::google::protobuf::Timestamp* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.created_at_);
  }
  _impl_.created_at_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:telemetry.v1.TelemetryHeader.created_at)
}
inline ::google::protobuf::Timestamp* PROTOBUF_NULLABLE TelemetryHeader::release_created_at() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::google::protobuf::Timestamp* released = _impl_.created_at_;
  _impl_.created_at_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::google::protobuf::Timestamp* PROTOBUF_NULLABLE TelemetryHeader::unsafe_arena_release_created_at() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:telemetry.v1.TelemetryHeader.created_at)

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::google::protobuf::Timestamp* temp = _impl_.created_at_;
  _impl_.created_at_ = nullptr;
  return temp;
}
inline ::google::protobuf::Timestamp* PROTOBUF_NONNULL TelemetryHeader::_internal_mutable_created_at() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.created_at_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::Timestamp>(GetArena());
    _impl_.created_at_ = reinterpret_cast<::google::protobuf::Timestamp*>(p);
  }
  return _impl_.created_at_;
}
inline ::google::protobuf::Timestamp* PROTOBUF_NONNULL TelemetryHeader::mutable_created_at()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::google::protobuf::Timestamp* _msg = _internal_mutable_created_at();
  // @@protoc_insertion_point(field_mutable:telemetry.v1.TelemetryHeader.created_at)
  return _msg;
}
inline void TelemetryHeader::set_allocated_created_at(::google::protobuf::Timestamp* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.created_at_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }

  _impl_.created_at_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  // @@protoc_insertion_point(field_set_allocated:telemetry.v1.TelemetryHeader.created_at)
}

// map<string, string> metadata = 3 [json_name = "metadata"];
inline int TelemetryHeader::_internal_metadata_size() const {
  return _internal_metadata().size();
}
inline int TelemetryHeader::metadata_size() const {
  return _internal_metadata_size();
}
inline void TelemetryHeader::clear_metadata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.metadata_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000004U);
}
inline const ::google::protobuf::Map<::std::string, ::std::string>& TelemetryHeader::_internal_metadata() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.metadata_.GetMap();
}
inline const ::google::protobuf::Map<::std::string, ::std::string>& TelemetryHeader::metadata() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:telemetry.v1.TelemetryHeader.metadata)
  return _internal_metadata();
}
inline ::google::protobuf::Map<::std::string, ::std::string>* PROTOBUF_NONNULL TelemetryHeader::_internal_mutable_metadata() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.metadata_.MutableMap();
}
inline ::google::protobuf::Map<::std::string, ::std::string>* PROTOBUF_NONNULL TelemetryHeader::mutable_metadata()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000004U);
  // @@protoc_insertion_point(field_mutable_map:telemetry.v1.TelemetryHeader.metadata)
  return _internal_mutable_metadata();
}

// -------------------------------------------------------------------

// Envelope

// .telemetry.v1.TelemetryHeader header = 1 [json_name = "header"];
inline bool Envelope::has_header() const {
  return message_case() == kHeader;
}
inline bool Envelope::_internal_has_header() const {
  return message_case() == kHeader;
}
inline void Envelope::set_has_header() {
  _impl_._oneof_case_[0] = kHeader;
}
inline void Envelope::clear_header() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_case() == kHeader) {
    if (GetArena() == nullptr) {
      delete _impl_.message_.header_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.message_.header_);
    }
    clear_has_message();
  }
}
inline ::telemetry::v1::TelemetryHeader* PROTOBUF_NULLABLE Envelope::release_header() {
  // @@protoc_insertion_point(field_release:telemetry.v1.Envelope.header)
  if (message_case() == kHeader) {
    clear_has_message();
    auto* temp = _impl_.message_.header_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.header_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::telemetry::v1::TelemetryHeader& Envelope::_internal_header() const {
  return message_case() == kHeader ? static_cast<const ::telemetry::v1::TelemetryHeader&>(*_impl_.message_.header_)
                     : reinterpret_cast<const ::telemetry::v1::TelemetryHeader&>(::telemetry::v1::_TelemetryHeader_default_instance_);
}
inline const ::telemetry::v1::TelemetryHeader& Envelope::header() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:telemetry.v1.Envelope.header)
  return _internal_header();
}
inline ::telemetry::v1::TelemetryHeader* PROTOBUF_NULLABLE Envelope::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_unsafe_arena_release:telemetry.v1.Envelope.header)
  if (message_case() == kHeader) {
    clear_has_message();
    auto* temp = _impl_.message_.header_;
    _impl_.message_.header_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Envelope::unsafe_arena_set_allocated_header(
    ::telemetry::v1::TelemetryHeader* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_message();
  if (value) {
    set_has_header();
    _impl_.message_.header_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:telemetry.v1.Envelope.header)
}
inline ::telemetry::v1::TelemetryHeader* PROTOBUF_NONNULL Envelope::_internal_mutable_header() {
  if (message_case() != kHeader) {
    clear_message();
    set_has_header();
    _impl_.message_.header_ = 
        ::google::protobuf::Message::DefaultConstruct<::telemetry::v1::TelemetryHeader>(GetArena());
  }
  return _impl_.message_.header_;
}
inline ::telemetry::v1::TelemetryHeader* PROTOBUF_NONNULL Envelope::mutable_header()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::telemetry::v1::TelemetryHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:telemetry.v1.Envelope.header)
  return _msg;
}

// .telemetry.v1.LobbySessionStateFrame frame = 2 [json_name = "frame"];
inline bool Envelope::has_frame() const {
  return message_case() == kFrame;
}
inline bool Envelope::_internal_has_frame() const {
  return message_case() == kFrame;
}
inline void Envelope::set_has_frame() {
  _impl_._oneof_case_[0] = kFrame;
}
inline void Envelope::clear_frame() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_case() == kFrame) {
    if (GetArena() == nullptr) {
      delete _impl_.message_.frame_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.message_.frame_);
    }
    clear_has_message();
  }
}
inline ::telemetry::v1::LobbySessionStateFrame* PROTOBUF_NULLABLE Envelope::release_frame() {
  // @@protoc_insertion_point(field_release:telemetry.v1.Envelope.frame)
  if (message_case() == kFrame) {
    clear_has_message();
    auto* temp = _impl_.message_.frame_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.frame_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::telemetry::v1::LobbySessionStateFrame& Envelope::_internal_frame() const {
  return message_case() == kFrame ? static_cast<const ::telemetry::v1::LobbySessionStateFrame&>(*_impl_.message_.frame_)
                     : reinterpret_cast<const ::telemetry::v1::LobbySessionStateFrame&>(::telemetry::v1::_LobbySessionStateFrame_default_instance_);
}
inline const ::telemetry::v1::LobbySessionStateFrame& Envelope::frame() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:telemetry.v1.Envelope.frame)
  return _internal_frame();
}
inline ::telemetry::v1::LobbySessionStateFrame* PROTOBUF_NULLABLE Envelope::unsafe_arena_release_frame() {
  // @@protoc_insertion_point(field_unsafe_arena_release:telemetry.v1.Envelope.frame)
  if (message_case() == kFrame) {
    clear_has_message();
    auto* temp = _impl_.message_.frame_;
    _impl_.message_.frame_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Envelope::unsafe_arena_set_allocated_frame(
    ::telemetry::v1::LobbySessionStateFrame* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_message();
  if (value) {
    set_has_frame();
    _impl_.message_.frame_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:telemetry.v1.Envelope.frame)
}
inline ::telemetry::v1::LobbySessionStateFrame* PROTOBUF_NONNULL Envelope::_internal_mutable_frame() {
  if (message_case() != kFrame) {
    clear_message();
    set_has_frame();
    _impl_.message_.frame_ = 
        ::google::protobuf::Message::DefaultConstruct<::telemetry::v1::LobbySessionStateFrame>(GetArena());
  }
  return _impl_.message_.frame_;
}
inline ::telemetry::v1::LobbySessionStateFrame* PROTOBUF_NONNULL Envelope::mutable_frame()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::telemetry::v1::LobbySessionStateFrame* _msg = _internal_mutable_frame();
  // @@protoc_insertion_point(field_mutable:telemetry.v1.Envelope.frame)
  return _msg;
}

inline bool Envelope::has_message() const {
  return message_case() != MESSAGE_NOT_SET;
}
inline void Envelope::clear_has_message() {
  _impl_._oneof_case_[0] = MESSAGE_NOT_SET;
}
inline Envelope::MessageCase Envelope::message_case() const {
  return Envelope::MessageCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// LobbySessionStateFrame

// uint32 frame_index = 1 [json_name = "frameIndex"];
inline void LobbySessionStateFrame::clear_frame_index() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.frame_index_ = 0u;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000010U);
}
inline ::uint32_t LobbySessionStateFrame::frame_index() const {
  // @@protoc_insertion_point(field_get:telemetry.v1.LobbySessionStateFrame.frame_index)
  return _internal_frame_index();
}
inline void LobbySessionStateFrame::set_frame_index(::uint32_t value) {
  _internal_set_frame_index(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000010U);
  // @@protoc_insertion_point(field_set:telemetry.v1.LobbySessionStateFrame.frame_index)
}
inline ::uint32_t LobbySessionStateFrame::_internal_frame_index() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.frame_index_;
}
inline void LobbySessionStateFrame::_internal_set_frame_index(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.frame_index_ = value;
}

// .google.protobuf.Timestamp timestamp = 2 [json_name = "timestamp"];
inline bool LobbySessionStateFrame::has_timestamp() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000002U);
  PROTOBUF_ASSUME(!value || _impl_.timestamp_ != nullptr);
  return value;
}
inline const ::google::protobuf::Timestamp& LobbySessionStateFrame::_internal_timestamp() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::google::protobuf::Timestamp* p = _impl_.timestamp_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Timestamp&>(::google::protobuf::_Timestamp_default_instance_);
}
inline const ::google::protobuf::Timestamp& LobbySessionStateFrame::timestamp() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:telemetry.v1.LobbySessionStateFrame.timestamp)
  return _internal_timestamp();
}
inline void LobbySessionStateFrame::unsafe_arena_set_allocated_timestamp(
    ::google::protobuf::Timestamp* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.timestamp_);
  }
  _impl_.timestamp_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:telemetry.v1.LobbySessionStateFrame.timestamp)
}
inline ::google::protobuf::Timestamp* PROTOBUF_NULLABLE LobbySessionStateFrame::release_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::google::protobuf::Timestamp* released = _impl_.timestamp_;
  _impl_.timestamp_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::google::protobuf::Timestamp* PROTOBUF_NULLABLE LobbySessionStateFrame::unsafe_arena_release_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:telemetry.v1.LobbySessionStateFrame.timestamp)

  ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::google::protobuf::Timestamp* temp = _impl_.timestamp_;
  _impl_.timestamp_ = nullptr;
  return temp;
}
inline ::google::protobuf::Timestamp* PROTOBUF_NONNULL LobbySessionStateFrame::_internal_mutable_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.timestamp_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::Timestamp>(GetArena());
    _impl_.timestamp_ = reinterpret_cast<::google::protobuf::Timestamp*>(p);
  }
  return _impl_.timestamp_;
}
inline ::google::protobuf::Timestamp* PROTOBUF_NONNULL LobbySessionStateFrame::mutable_timestamp()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  ::google::protobuf::Timestamp* _msg = _internal_mutable_timestamp();
  // @@protoc_insertion_point(field_mutable:telemetry.v1.LobbySessionStateFrame.timestamp)
  return _msg;
}
inline void LobbySessionStateFrame::set_allocated_timestamp(::google::protobuf::Timestamp* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.timestamp_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000002U);
  }

  _impl_.timestamp_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  // @@protoc_insertion_point(field_set_allocated:telemetry.v1.LobbySessionStateFrame.timestamp)
}

// repeated .telemetry.v1.LobbySessionEvent events = 3 [json_name = "events"];
inline int LobbySessionStateFrame::_internal_events_size() const {
  return _internal_events().size();
}
inline int LobbySessionStateFrame::events_size() const {
  return _internal_events_size();
}
inline void LobbySessionStateFrame::clear_events() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.events_.Clear();
  ClearHasBitForRepeated(_impl_._has_bits_[0],
                  0x00000001U);
}
inline ::telemetry::v1::LobbySessionEvent* PROTOBUF_NONNULL LobbySessionStateFrame::mutable_events(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:telemetry.v1.LobbySessionStateFrame.events)
  return _internal_mutable_events()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::telemetry::v1::LobbySessionEvent>* PROTOBUF_NONNULL LobbySessionStateFrame::mutable_events()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_mutable_list:telemetry.v1.LobbySessionStateFrame.events)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_events();
}
inline const ::telemetry::v1::LobbySessionEvent& LobbySessionStateFrame::events(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:telemetry.v1.LobbySessionStateFrame.events)
  return _internal_events().Get(index);
}
inline ::telemetry::v1::LobbySessionEvent* PROTOBUF_NONNULL LobbySessionStateFrame::add_events()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::telemetry::v1::LobbySessionEvent* _add =
      _internal_mutable_events()->InternalAddWithArena(
          ::google::protobuf::MessageLite::internal_visibility(), GetArena());
  SetHasBitForRepeated(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_add:telemetry.v1.LobbySessionStateFrame.events)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::telemetry::v1::LobbySessionEvent>& LobbySessionStateFrame::events() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:telemetry.v1.LobbySessionStateFrame.events)
  return _internal_events();
}
inline const ::google::protobuf::RepeatedPtrField<::telemetry::v1::LobbySessionEvent>&
LobbySessionStateFrame::_internal_events() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.events_;
}
inline ::google::protobuf::RepeatedPtrField<::telemetry::v1::LobbySessionEvent>* PROTOBUF_NONNULL
LobbySessionStateFrame::_internal_mutable_events() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.events_;
}

// .enginehttp.SessionResponse session = 4 [json_name = "session"];
inline bool LobbySessionStateFrame::has_session() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000004U);
  PROTOBUF_ASSUME(!value || _impl_.session_ != nullptr);
  return value;
}
inline const ::enginehttp::SessionResponse& LobbySessionStateFrame::_internal_session() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::enginehttp::SessionResponse* p = _impl_.session_;
  return p != nullptr ? *p : reinterpret_cast<const ::enginehttp::SessionResponse&>(::enginehttp::_SessionResponse_default_instance_);
}
inline const ::enginehttp::SessionResponse& LobbySessionStateFrame::session() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:telemetry.v1.LobbySessionStateFrame.session)
  return _internal_session();
}
inline void LobbySessionStateFrame::unsafe_arena_set_allocated_session(
    ::enginehttp::SessionResponse* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.session_);
  }
  _impl_.session_ = reinterpret_cast<::enginehttp::SessionResponse*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:telemetry.v1.LobbySessionStateFrame.session)
}
inline ::enginehttp::SessionResponse* PROTOBUF_NULLABLE LobbySessionStateFrame::release_session() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::enginehttp::SessionResponse* released = _impl_.session_;
  _impl_.session_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::enginehttp::SessionResponse* PROTOBUF_NULLABLE LobbySessionStateFrame::unsafe_arena_release_session() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:telemetry.v1.LobbySessionStateFrame.session)

  ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::enginehttp::SessionResponse* temp = _impl_.session_;
  _impl_.session_ = nullptr;
  return temp;
}
inline ::enginehttp::SessionResponse* PROTOBUF_NONNULL LobbySessionStateFrame::_internal_mutable_session() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.session_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::enginehttp::SessionResponse>(GetArena());
    _impl_.session_ = reinterpret_cast<::enginehttp::SessionResponse*>(p);
  }
  return _impl_.session_;
}
inline ::enginehttp::SessionResponse* PROTOBUF_NONNULL LobbySessionStateFrame::mutable_session()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  ::enginehttp::SessionResponse* _msg = _internal_mutable_session();
  // @@protoc_insertion_point(field_mutable:telemetry.v1.LobbySessionStateFrame.session)
  return _msg;
}
inline void LobbySessionStateFrame::set_allocated_session(::enginehttp::SessionResponse* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.session_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000004U);
  }

  _impl_.session_ = reinterpret_cast<::enginehttp::SessionResponse*>(value);
  // @@protoc_insertion_point(field_set_allocated:telemetry.v1.LobbySessionStateFrame.session)
}

// .enginehttp.PlayerBonesResponse player_bones = 5 [json_name = "playerBones"];
inline bool LobbySessionStateFrame::has_player_bones() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000008U);
  PROTOBUF_ASSUME(!value || _impl_.player_bones_ != nullptr);
  return value;
}
inline const ::enginehttp::PlayerBonesResponse& LobbySessionStateFrame::_internal_player_bones() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::enginehttp::PlayerBonesResponse* p = _impl_.player_bones_;
  return p != nullptr ? *p : reinterpret_cast<const ::enginehttp::PlayerBonesResponse&>(::enginehttp::_PlayerBonesResponse_default_instance_);
}
inline const ::enginehttp::PlayerBonesResponse& LobbySessionStateFrame::player_bones() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:telemetry.v1.LobbySessionStateFrame.player_bones)
  return _internal_player_bones();
}
inline void LobbySessionStateFrame::unsafe_arena_set_allocated_player_bones(
    ::enginehttp::PlayerBonesResponse* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.player_bones_);
  }
  _impl_.player_bones_ = reinterpret_cast<::enginehttp::PlayerBonesResponse*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000008U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:telemetry.v1.LobbySessionStateFrame.player_bones)
}
inline ::enginehttp::PlayerBonesResponse* PROTOBUF_NULLABLE LobbySessionStateFrame::release_player_bones() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000008U);
  ::enginehttp::PlayerBonesResponse* released = _impl_.player_bones_;
  _impl_.player_bones_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::enginehttp::PlayerBonesResponse* PROTOBUF_NULLABLE LobbySessionStateFrame::unsafe_arena_release_player_bones() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:telemetry.v1.LobbySessionStateFrame.player_bones)

  ClearHasBit(_impl_._has_bits_[0], 0x00000008U);
  ::enginehttp::PlayerBonesResponse* temp = _impl_.player_bones_;
  _impl_.player_bones_ = nullptr;
  return temp;
}
inline ::enginehttp::PlayerBonesResponse* PROTOBUF_NONNULL LobbySessionStateFrame::_internal_mutable_player_bones() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.player_bones_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::enginehttp::PlayerBonesResponse>(GetArena());
    _impl_.player_bones_ = reinterpret_cast<::enginehttp::PlayerBonesResponse*>(p);
  }
  return _impl_.player_bones_;
}
inline ::enginehttp::PlayerBonesResponse* PROTOBUF_NONNULL LobbySessionStateFrame::mutable_player_bones()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  ::enginehttp::PlayerBonesResponse* _msg = _internal_mutable_player_bones();
  // @@protoc_insertion_point(field_mutable:telemetry.v1.LobbySessionStateFrame.player_bones)
  return _msg;
}
inline void LobbySessionStateFrame::set_allocated_player_bones(::enginehttp::PlayerBonesResponse* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.player_bones_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000008U);
  }

  _impl_.player_bones_ = reinterpret_cast<::enginehttp::PlayerBonesResponse*>(value);
  // @@protoc_insertion_point(field_set_allocated:telemetry.v1.LobbySessionStateFrame.player_bones)
}

// -------------------------------------------------------------------

// LobbySessionEvent

// .telemetry.v1.RoundStarted round_started = 10 [json_name = "roundStarted"];
inline bool LobbySessionEvent::has_round_started() const {
  return event_case() == kRoundStarted;
}
inline bool LobbySessionEvent::_internal_has_round_started() const {
  return event_case() == kRoundStarted;
}
inline void LobbySessionEvent::set_has_round_started() {
  _impl_._oneof_case_[0] = kRoundStarted;
}
inline void LobbySessionEvent::clear_round_started() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (event_case() == kRoundStarted) {
    if (GetArena() == nullptr) {
      delete _impl_.event_.round_started_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.event_.round_started_);
    }
    clear_has_event();
  }
}
inline ::telemetry::v1::RoundStarted* PROTOBUF_NULLABLE LobbySessionEvent::release_round_started() {
  // @@protoc_insertion_point(field_release:telemetry.v1.LobbySessionEvent.round_started)
  if (event_case() == kRoundStarted) {
    clear_has_event();
    auto* temp = reinterpret_cast<::telemetry::v1::RoundStarted*>(_impl_.event_.round_started_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.event_.round_started_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::telemetry::v1::RoundStarted& LobbySessionEvent::_internal_round_started() const {
  return event_case() == kRoundStarted ? static_cast<const ::telemetry::v1::RoundStarted&>(*reinterpret_cast<::telemetry::v1::RoundStarted*>(_impl_.event_.round_started_))
                     : reinterpret_cast<const ::telemetry::v1::RoundStarted&>(::telemetry::v1::_RoundStarted_default_instance_);
}
inline const ::telemetry::v1::RoundStarted& LobbySessionEvent::round_started() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:telemetry.v1.LobbySessionEvent.round_started)
  return _internal_round_started();
}
inline ::telemetry::v1::RoundStarted* PROTOBUF_NULLABLE LobbySessionEvent::unsafe_arena_release_round_started() {
  // @@protoc_insertion_point(field_unsafe_arena_release:telemetry.v1.LobbySessionEvent.round_started)
  if (event_case() == kRoundStarted) {
    clear_has_event();
    auto* temp = reinterpret_cast<::telemetry::v1::RoundStarted*>(_impl_.event_.round_started_);
    _impl_.event_.round_started_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void LobbySessionEvent::unsafe_arena_set_allocated_round_started(
    ::telemetry::v1::RoundStarted* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_event();
  if (value) {
    set_has_round_started();
    _impl_.event_.round_started_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:telemetry.v1.LobbySessionEvent.round_started)
}
inline ::telemetry::v1::RoundStarted* PROTOBUF_NONNULL LobbySessionEvent::_internal_mutable_round_started() {
  if (event_case() != kRoundStarted) {
    clear_event();
    set_has_round_started();
    _impl_.event_.round_started_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::telemetry::v1::RoundStarted>(GetArena()));
  }
  return reinterpret_cast<::telemetry::v1::RoundStarted*>(_impl_.event_.round_started_);
}
inline ::telemetry::v1::RoundStarted* PROTOBUF_NONNULL LobbySessionEvent::mutable_round_started()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::telemetry::v1::RoundStarted* _msg = _internal_mutable_round_started();
  // @@protoc_insertion_point(field_mutable:telemetry.v1.LobbySessionEvent.round_started)
  return _msg;
}

// .telemetry.v1.RoundPaused round_paused = 11 [json_name = "roundPaused"];
inline bool LobbySessionEvent::has_round_paused() const {
  return event_case() == kRoundPaused;
}
inline bool LobbySessionEvent::_internal_has_round_paused() const {
  return event_case() == kRoundPaused;
}
inline void LobbySessionEvent::set_has_round_paused() {
  _impl_._oneof_case_[0] = kRoundPaused;
}
inline void LobbySessionEvent::clear_round_paused() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (event_case() == kRoundPaused) {
    if (GetArena() == nullptr) {
      delete _impl_.event_.round_paused_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.event_.round_paused_);
    }
    clear_has_event();
  }
}
inline ::telemetry::v1::RoundPaused* PROTOBUF_NULLABLE LobbySessionEvent::release_round_paused() {
  // @@protoc_insertion_point(field_release:telemetry.v1.LobbySessionEvent.round_paused)
  if (event_case() == kRoundPaused) {
    clear_has_event();
    auto* temp = reinterpret_cast<::telemetry::v1::RoundPaused*>(_impl_.event_.round_paused_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.event_.round_paused_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::telemetry::v1::RoundPaused& LobbySessionEvent::_internal_round_paused() const {
  return event_case() == kRoundPaused ? static_cast<const ::telemetry::v1::RoundPaused&>(*reinterpret_cast<::telemetry::v1::RoundPaused*>(_impl_.event_.round_paused_))
                     : reinterpret_cast<const ::telemetry::v1::RoundPaused&>(::telemetry::v1::_RoundPaused_default_instance_);
}
inline const ::telemetry::v1::RoundPaused& LobbySessionEvent::round_paused() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:telemetry.v1.LobbySessionEvent.round_paused)
  return _internal_round_paused();
}
inline ::telemetry::v1::RoundPaused* PROTOBUF_NULLABLE LobbySessionEvent::unsafe_arena_release_round_paused() {
  // @@protoc_insertion_point(field_unsafe_arena_release:telemetry.v1.LobbySessionEvent.round_paused)
  if (event_case() == kRoundPaused) {
    clear_has_event();
    auto* temp = reinterpret_cast<::telemetry::v1::RoundPaused*>(_impl_.event_.round_paused_);
    _impl_.event_.round_paused_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void LobbySessionEvent::unsafe_arena_set_allocated_round_paused(
    ::telemetry::v1::RoundPaused* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_event();
  if (value) {
    set_has_round_paused();
    _impl_.event_.round_paused_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:telemetry.v1.LobbySessionEvent.round_paused)
}
inline ::telemetry::v1::RoundPaused* PROTOBUF_NONNULL LobbySessionEvent::_internal_mutable_round_paused() {
  if (event_case() != kRoundPaused) {
    clear_event();
    set_has_round_paused();
    _impl_.event_.round_paused_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::telemetry::v1::RoundPaused>(GetArena()));
  }
  return reinterpret_cast<::telemetry::v1::RoundPaused*>(_impl_.event_.round_paused_);
}
inline ::telemetry::v1::RoundPaused* PROTOBUF_NONNULL LobbySessionEvent::mutable_round_paused()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::telemetry::v1::RoundPaused* _msg = _internal_mutable_round_paused();
  // @@protoc_insertion_point(field_mutable:telemetry.v1.LobbySessionEvent.round_paused)
  return _msg;
}

// .telemetry.v1.RoundUnpaused round_unpaused = 12 [json_name = "roundUnpaused"];
inline bool LobbySessionEvent::has_round_unpaused() const {
  return event_case() == kRoundUnpaused;
}
inline bool LobbySessionEvent::_internal_has_round_unpaused() const {
  return event_case() == kRoundUnpaused;
}
inline void LobbySessionEvent::set_has_round_unpaused() {
  _impl_._oneof_case_[0] = kRoundUnpaused;
}
inline void LobbySessionEvent::clear_round_unpaused() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (event_case() == kRoundUnpaused) {
    if (GetArena() == nullptr) {
      delete _impl_.event_.round_unpaused_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.event_.round_unpaused_);
    }
    clear_has_event();
  }
}
inline ::telemetry::v1::RoundUnpaused* PROTOBUF_NULLABLE LobbySessionEvent::release_round_unpaused() {
  // @@protoc_insertion_point(field_release:telemetry.v1.LobbySessionEvent.round_unpaused)
  if (event_case() == kRoundUnpaused) {
    clear_has_event();
    auto* temp = reinterpret_cast<::telemetry::v1::RoundUnpaused*>(_impl_.event_.round_unpaused_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.event_.round_unpaused_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::telemetry::v1::RoundUnpaused& LobbySessionEvent::_internal_round_unpaused() const {
  return event_case() == kRoundUnpaused ? static_cast<const ::telemetry::v1::RoundUnpaused&>(*reinterpret_cast<::telemetry::v1::RoundUnpaused*>(_impl_.event_.round_unpaused_))
                     : reinterpret_cast<const ::telemetry::v1::RoundUnpaused&>(::telemetry::v1::_RoundUnpaused_default_instance_);
}
inline const ::telemetry::v1::RoundUnpaused& LobbySessionEvent::round_unpaused() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:telemetry.v1.LobbySessionEvent.round_unpaused)
  return _internal_round_unpaused();
}
inline ::telemetry::v1::RoundUnpaused* PROTOBUF_NULLABLE LobbySessionEvent::unsafe_arena_release_round_unpaused() {
  // @@protoc_insertion_point(field_unsafe_arena_release:telemetry.v1.LobbySessionEvent.round_unpaused)
  if (event_case() == kRoundUnpaused) {
    clear_has_event();
    auto* temp = reinterpret_cast<::telemetry::v1::RoundUnpaused*>(_impl_.event_.round_unpaused_);
    _impl_.event_.round_unpaused_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void LobbySessionEvent::unsafe_arena_set_allocated_round_unpaused(
    ::telemetry::v1::RoundUnpaused* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_event();
  if (value) {
    set_has_round_unpaused();
    _impl_.event_.round_unpaused_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:telemetry.v1.LobbySessionEvent.round_unpaused)
}
inline ::telemetry::v1::RoundUnpaused* PROTOBUF_NONNULL LobbySessionEvent::_internal_mutable_round_unpaused() {
  if (event_case() != kRoundUnpaused) {
    clear_event();
    set_has_round_unpaused();
    _impl_.event_.round_unpaused_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::telemetry::v1::RoundUnpaused>(GetArena()));
  }
  return reinterpret_cast<::telemetry::v1::RoundUnpaused*>(_impl_.event_.round_unpaused_);
}
inline ::telemetry::v1::RoundUnpaused* PROTOBUF_NONNULL LobbySessionEvent::mutable_round_unpaused()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::telemetry::v1::RoundUnpaused* _msg = _internal_mutable_round_unpaused();
  // @@protoc_insertion_point(field_mutable:telemetry.v1.LobbySessionEvent.round_unpaused)
  return _msg;
}

// .telemetry.v1.RoundEnded round_ended = 13 [json_name = "roundEnded"];
inline bool LobbySessionEvent::has_round_ended() const {
  return event_case() == kRoundEnded;
}
inline bool LobbySessionEvent::_internal_has_round_ended() const {
  return event_case() == kRoundEnded;
}
inline void LobbySessionEvent::set_has_round_ended() {
  _impl_._oneof_case_[0] = kRoundEnded;
}
inline void LobbySessionEvent::clear_round_ended() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (event_case() == kRoundEnded) {
    if (GetArena() == nullptr) {
      delete _impl_.event_.round_ended_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.event_.round_ended_);
    }
    clear_has_event();
  }
}
inline ::telemetry::v1::RoundEnded* PROTOBUF_NULLABLE LobbySessionEvent::release_round_ended() {
  // @@protoc_insertion_point(field_release:telemetry.v1.LobbySessionEvent.round_ended)
  if (event_case() == kRoundEnded) {
    clear_has_event();
    auto* temp = reinterpret_cast<::telemetry::v1::RoundEnded*>(_impl_.event_.round_ended_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.event_.round_ended_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::telemetry::v1::RoundEnded& LobbySessionEvent::_internal_round_ended() const {
  return event_case() == kRoundEnded ? static_cast<const ::telemetry::v1::RoundEnded&>(*reinterpret_cast<::telemetry::v1::RoundEnded*>(_impl_.event_.round_ended_))
                     : reinterpret_cast<const ::telemetry::v1::RoundEnded&>(::telemetry::v1::_RoundEnded_default_instance_);
}
inline const ::telemetry::v1::RoundEnded& LobbySessionEvent::round_ended() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:telemetry.v1.LobbySessionEvent.round_ended)
  return _internal_round_ended();
}
inline ::telemetry::v1::RoundEnded* PROTOBUF_NULLABLE LobbySessionEvent::unsafe_arena_release_round_ended() {
  // @@protoc_insertion_point(field_unsafe_arena_release:telemetry.v1.LobbySessionEvent.round_ended)
  if (event_case() == kRoundEnded) {
    clear_has_event();
    auto* temp = reinterpret_cast<::telemetry::v1::RoundEnded*>(_impl_.event_.round_ended_);
    _impl_.event_.round_ended_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void LobbySessionEvent::unsafe_arena_set_allocated_round_ended(
    ::telemetry::v1::RoundEnded* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_event();
  if (value) {
    set_has_round_ended();
    _impl_.event_.round_ended_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:telemetry.v1.LobbySessionEvent.round_ended)
}
inline ::telemetry::v1::RoundEnded* PROTOBUF_NONNULL LobbySessionEvent::_internal_mutable_round_ended() {
  if (event_case() != kRoundEnded) {
    clear_event();
    set_has_round_ended();
    _impl_.event_.round_ended_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::telemetry::v1::RoundEnded>(GetArena()));
  }
  return reinterpret_cast<::telemetry::v1::RoundEnded*>(_impl_.event_.round_ended_);
}
inline ::telemetry::v1::RoundEnded* PROTOBUF_NONNULL LobbySessionEvent::mutable_round_ended()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::telemetry::v1::RoundEnded* _msg = _internal_mutable_round_ended();
  // @@protoc_insertion_point(field_mutable:telemetry.v1.LobbySessionEvent.round_ended)
  return _msg;
}

// .telemetry.v1.MatchEnded match_ended = 14 [json_name = "matchEnded"];
inline bool LobbySessionEvent::has_match_ended() const {
  return event_case() == kMatchEnded;
}
inline bool LobbySessionEvent::_internal_has_match_ended() const {
  return event_case() == kMatchEnded;
}
inline void LobbySessionEvent::set_has_match_ended() {
  _impl_._oneof_case_[0] = kMatchEnded;
}
inline void LobbySessionEvent::clear_match_ended() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (event_case() == kMatchEnded) {
    if (GetArena() == nullptr) {
      delete _impl_.event_.match_ended_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.event_.match_ended_);
    }
    clear_has_event();
  }
}
inline ::telemetry::v1::MatchEnded* PROTOBUF_NULLABLE LobbySessionEvent::release_match_ended() {
  // @@protoc_insertion_point(field_release:telemetry.v1.LobbySessionEvent.match_ended)
  if (event_case() == kMatchEnded) {
    clear_has_event();
    auto* temp = reinterpret_cast<::telemetry::v1::MatchEnded*>(_impl_.event_.match_ended_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.event_.match_ended_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::telemetry::v1::MatchEnded& LobbySessionEvent::_internal_match_ended() const {
  return event_case() == kMatchEnded ? static_cast<const ::telemetry::v1::MatchEnded&>(*reinterpret_cast<::telemetry::v1::MatchEnded*>(_impl_.event_.match_ended_))
                     : reinterpret_cast<const ::telemetry::v1::MatchEnded&>(::telemetry::v1::_MatchEnded_default_instance_);
}
inline const ::telemetry::v1::MatchEnded& LobbySessionEvent::match_ended() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:telemetry.v1.LobbySessionEvent.match_ended)
  return _internal_match_ended();
}
inline ::telemetry::v1::MatchEnded* PROTOBUF_NULLABLE LobbySessionEvent::unsafe_arena_release_match_ended() {
  // @@protoc_insertion_point(field_unsafe_arena_release:telemetry.v1.LobbySessionEvent.match_ended)
  if (event_case() == kMatchEnded) {
    clear_has_event();
    auto* temp = reinterpret_cast<::telemetry::v1::MatchEnded*>(_impl_.event_.match_ended_);
    _impl_.event_.match_ended_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void LobbySessionEvent::unsafe_arena_set_allocated_match_ended(
    ::telemetry::v1::MatchEnded* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_event();
  if (value) {
    set_has_match_ended();
    _impl_.event_.match_ended_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:telemetry.v1.LobbySessionEvent.match_ended)
}
inline ::telemetry::v1::MatchEnded* PROTOBUF_NONNULL LobbySessionEvent::_internal_mutable_match_ended() {
  if (event_case() != kMatchEnded) {
    clear_event();
    set_has_match_ended();
    _impl_.event_.match_ended_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::telemetry::v1::MatchEnded>(GetArena()));
  }
  return reinterpret_cast<::telemetry::v1::MatchEnded*>(_impl_.event_.match_ended_);
}
inline ::telemetry::v1::MatchEnded* PROTOBUF_NONNULL LobbySessionEvent::mutable_match_ended()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::telemetry::v1::MatchEnded* _msg = _internal_mutable_match_ended();
  // @@protoc_insertion_point(field_mutable:telemetry.v1.LobbySessionEvent.match_ended)
  return _msg;
}

// .telemetry.v1.ScoreboardUpdated scoreboard_updated = 15 [json_name = "scoreboardUpdated"];
inline bool LobbySessionEvent::has_scoreboard_updated() const {
  return event_case() == kScoreboardUpdated;
}
inline bool LobbySessionEvent::_internal_has_scoreboard_updated() const {
  return event_case() == kScoreboardUpdated;
}
inline void LobbySessionEvent::set_has_scoreboard_updated() {
  _impl_._oneof_case_[0] = kScoreboardUpdated;
}
inline void LobbySessionEvent::clear_scoreboard_updated() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (event_case() == kScoreboardUpdated) {
    if (GetArena() == nullptr) {
      delete _impl_.event_.scoreboard_updated_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.event_.scoreboard_updated_);
    }
    clear_has_event();
  }
}
inline ::telemetry::v1::ScoreboardUpdated* PROTOBUF_NULLABLE LobbySessionEvent::release_scoreboard_updated() {
  // @@protoc_insertion_point(field_release:telemetry.v1.LobbySessionEvent.scoreboard_updated)
  if (event_case() == kScoreboardUpdated) {
    clear_has_event();
    auto* temp = reinterpret_cast<::telemetry::v1::ScoreboardUpdated*>(_impl_.event_.scoreboard_updated_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.event_.scoreboard_updated_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::telemetry::v1::ScoreboardUpdated& LobbySessionEvent::_internal_scoreboard_updated() const {
  return event_case() == kScoreboardUpdated ? static_cast<const ::telemetry::v1::ScoreboardUpdated&>(*reinterpret_cast<::telemetry::v1::ScoreboardUpdated*>(_impl_.event_.scoreboard_updated_))
                     : reinterpret_cast<const ::telemetry::v1::ScoreboardUpdated&>(::telemetry::v1::_ScoreboardUpdated_default_instance_);
}
inline const ::telemetry::v1::ScoreboardUpdated& LobbySessionEvent::scoreboard_updated() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:telemetry.v1.LobbySessionEvent.scoreboard_updated)
  return _internal_scoreboard_updated();
}
inline ::telemetry::v1::ScoreboardUpdated* PROTOBUF_NULLABLE LobbySessionEvent::unsafe_arena_release_scoreboard_updated() {
  // @@protoc_insertion_point(field_unsafe_arena_release:telemetry.v1.LobbySessionEvent.scoreboard_updated)
  if (event_case() == kScoreboardUpdated) {
    clear_has_event();
    auto* temp = reinterpret_cast<::telemetry::v1::ScoreboardUpdated*>(_impl_.event_.scoreboard_updated_);
    _impl_.event_.scoreboard_updated_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void LobbySessionEvent::unsafe_arena_set_allocated_scoreboard_updated(
    ::telemetry::v1::ScoreboardUpdated* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_event();
  if (value) {
    set_has_scoreboard_updated();
    _impl_.event_.scoreboard_updated_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:telemetry.v1.LobbySessionEvent.scoreboard_updated)
}
inline ::telemetry::v1::ScoreboardUpdated* PROTOBUF_NONNULL LobbySessionEvent::_internal_mutable_scoreboard_updated() {
  if (event_case() != kScoreboardUpdated) {
    clear_event();
    set_has_scoreboard_updated();
    _impl_.event_.scoreboard_updated_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::telemetry::v1::ScoreboardUpdated>(GetArena()));
  }
  return reinterpret_cast<::telemetry::v1::ScoreboardUpdated*>(_impl_.event_.scoreboard_updated_);
}
inline ::telemetry::v1::ScoreboardUpdated* PROTOBUF_NONNULL LobbySessionEvent::mutable_scoreboard_updated()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::telemetry::v1::ScoreboardUpdated* _msg = _internal_mutable_scoreboard_updated();
  // @@protoc_insertion_point(field_mutable:telemetry.v1.LobbySessionEvent.scoreboard_updated)
  return _msg;
}

// .telemetry.v1.PlayerJoined player_joined = 20 [json_name = "playerJoined"];
inline bool LobbySessionEvent::has_player_joined() const {
  return event_case() == kPlayerJoined;
}
inline bool LobbySessionEvent::_internal_has_player_joined() const {
  return event_case() == kPlayerJoined;
}
inline void LobbySessionEvent::set_has_player_joined() {
  _impl_._oneof_case_[0] = kPlayerJoined;
}
inline void LobbySessionEvent::clear_player_joined() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (event_case() == kPlayerJoined) {
    if (GetArena() == nullptr) {
      delete _impl_.event_.player_joined_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.event_.player_joined_);
    }
    clear_has_event();
  }
}
inline ::telemetry::v1::PlayerJoined* PROTOBUF_NULLABLE LobbySessionEvent::release_player_joined() {
  // @@protoc_insertion_point(field_release:telemetry.v1.LobbySessionEvent.player_joined)
  if (event_case() == kPlayerJoined) {
    clear_has_event();
    auto* temp = reinterpret_cast<::telemetry::v1::PlayerJoined*>(_impl_.event_.player_joined_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.event_.player_joined_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::telemetry::v1::PlayerJoined& LobbySessionEvent::_internal_player_joined() const {
  return event_case() == kPlayerJoined ? static_cast<const ::telemetry::v1::PlayerJoined&>(*reinterpret_cast<::telemetry::v1::PlayerJoined*>(_impl_.event_.player_joined_))
                     : reinterpret_cast<const ::telemetry::v1::PlayerJoined&>(::telemetry::v1::_PlayerJoined_default_instance_);
}
inline const ::telemetry::v1::PlayerJoined& LobbySessionEvent::player_joined() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:telemetry.v1.LobbySessionEvent.player_joined)
  return _internal_player_joined();
}
inline ::telemetry::v1::PlayerJoined* PROTOBUF_NULLABLE LobbySessionEvent::unsafe_arena_release_player_joined() {
  // @@protoc_insertion_point(field_unsafe_arena_release:telemetry.v1.LobbySessionEvent.player_joined)
  if (event_case() == kPlayerJoined) {
    clear_has_event();
    auto* temp = reinterpret_cast<::telemetry::v1::PlayerJoined*>(_impl_.event_.player_joined_);
    _impl_.event_.player_joined_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void LobbySessionEvent::unsafe_arena_set_allocated_player_joined(
    ::telemetry::v1::PlayerJoined* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_event();
  if (value) {
    set_has_player_joined();
    _impl_.event_.player_joined_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:telemetry.v1.LobbySessionEvent.player_joined)
}
inline ::telemetry::v1::PlayerJoined* PROTOBUF_NONNULL LobbySessionEvent::_internal_mutable_player_joined() {
  if (event_case() != kPlayerJoined) {
    clear_event();
    set_has_player_joined();
    _impl_.event_.player_joined_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::telemetry::v1::PlayerJoined>(GetArena()));
  }
  return reinterpret_cast<::telemetry::v1::PlayerJoined*>(_impl_.event_.player_joined_);
}
inline ::telemetry::v1::PlayerJoined* PROTOBUF_NONNULL LobbySessionEvent::mutable_player_joined()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::telemetry::v1::PlayerJoined* _msg = _internal_mutable_player_joined();
  // @@protoc_insertion_point(field_mutable:telemetry.v1.LobbySessionEvent.player_joined)
  return _msg;
}

// .telemetry.v1.PlayerLeft player_left = 21 [json_name = "playerLeft"];
inline bool LobbySessionEvent::has_player_left() const {
  return event_case() == kPlayerLeft;
}
inline bool LobbySessionEvent::_internal_has_player_left() const {
  return event_case() == kPlayerLeft;
}
inline void LobbySessionEvent::set_has_player_left() {
  _impl_._oneof_case_[0] = kPlayerLeft;
}
inline void LobbySessionEvent::clear_player_left() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (event_case() == kPlayerLeft) {
    if (GetArena() == nullptr) {
      delete _impl_.event_.player_left_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.event_.player_left_);
    }
    clear_has_event();
  }
}
inline ::telemetry::v1::PlayerLeft* PROTOBUF_NULLABLE LobbySessionEvent::release_player_left() {
  // @@protoc_insertion_point(field_release:telemetry.v1.LobbySessionEvent.player_left)
  if (event_case() == kPlayerLeft) {
    clear_has_event();
    auto* temp = reinterpret_cast<::telemetry::v1::PlayerLeft*>(_impl_.event_.player_left_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.event_.player_left_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::telemetry::v1::PlayerLeft& LobbySessionEvent::_internal_player_left() const {
  return event_case() == kPlayerLeft ? static_cast<const ::telemetry::v1::PlayerLeft&>(*reinterpret_cast<::telemetry::v1::PlayerLeft*>(_impl_.event_.player_left_))
                     : reinterpret_cast<const ::telemetry::v1::PlayerLeft&>(::telemetry::v1::_PlayerLeft_default_instance_);
}
inline const ::telemetry::v1::PlayerLeft& LobbySessionEvent::player_left() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:telemetry.v1.LobbySessionEvent.player_left)
  return _internal_player_left();
}
inline ::telemetry::v1::PlayerLeft* PROTOBUF_NULLABLE LobbySessionEvent::unsafe_arena_release_player_left() {
  // @@protoc_insertion_point(field_unsafe_arena_release:telemetry.v1.LobbySessionEvent.player_left)
  if (event_case() == kPlayerLeft) {
    clear_has_event();
    auto* temp = reinterpret_cast<::telemetry::v1::PlayerLeft*>(_impl_.event_.player_left_);
    _impl_.event_.player_left_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void LobbySessionEvent::unsafe_arena_set_allocated_player_left(
    ::telemetry::v1::PlayerLeft* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_event();
  if (value) {
    set_has_player_left();
    _impl_.event_.player_left_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:telemetry.v1.LobbySessionEvent.player_left)
}
inline ::telemetry::v1::PlayerLeft* PROTOBUF_NONNULL LobbySessionEvent::_internal_mutable_player_left() {
  if (event_case() != kPlayerLeft) {
    clear_event();
    set_has_player_left();
    _impl_.event_.player_left_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::telemetry::v1::PlayerLeft>(GetArena()));
  }
  return reinterpret_cast<::telemetry::v1::PlayerLeft*>(_impl_.event_.player_left_);
}
inline ::telemetry::v1::PlayerLeft* PROTOBUF_NONNULL LobbySessionEvent::mutable_player_left()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::telemetry::v1::PlayerLeft* _msg = _internal_mutable_player_left();
  // @@protoc_insertion_point(field_mutable:telemetry.v1.LobbySessionEvent.player_left)
  return _msg;
}

// .telemetry.v1.PlayerSwitchedTeam player_switched_team = 22 [json_name = "playerSwitchedTeam"];
inline bool LobbySessionEvent::has_player_switched_team() const {
  return event_case() == kPlayerSwitchedTeam;
}
inline bool LobbySessionEvent::_internal_has_player_switched_team() const {
  return event_case() == kPlayerSwitchedTeam;
}
inline void LobbySessionEvent::set_has_player_switched_team() {
  _impl_._oneof_case_[0] = kPlayerSwitchedTeam;
}
inline void LobbySessionEvent::clear_player_switched_team() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (event_case() == kPlayerSwitchedTeam) {
    if (GetArena() == nullptr) {
      delete _impl_.event_.player_switched_team_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.event_.player_switched_team_);
    }
    clear_has_event();
  }
}
inline ::telemetry::v1::PlayerSwitchedTeam* PROTOBUF_NULLABLE LobbySessionEvent::release_player_switched_team() {
  // @@protoc_insertion_point(field_release:telemetry.v1.LobbySessionEvent.player_switched_team)
  if (event_case() == kPlayerSwitchedTeam) {
    clear_has_event();
    auto* temp = reinterpret_cast<::telemetry::v1::PlayerSwitchedTeam*>(_impl_.event_.player_switched_team_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.event_.player_switched_team_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::telemetry::v1::PlayerSwitchedTeam& LobbySessionEvent::_internal_player_switched_team() const {
  return event_case() == kPlayerSwitchedTeam ? static_cast<const ::telemetry::v1::PlayerSwitchedTeam&>(*reinterpret_cast<::telemetry::v1::PlayerSwitchedTeam*>(_impl_.event_.player_switched_team_))
                     : reinterpret_cast<const ::telemetry::v1::PlayerSwitchedTeam&>(::telemetry::v1::_PlayerSwitchedTeam_default_instance_);
}
inline const ::telemetry::v1::PlayerSwitchedTeam& LobbySessionEvent::player_switched_team() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:telemetry.v1.LobbySessionEvent.player_switched_team)
  return _internal_player_switched_team();
}
inline ::telemetry::v1::PlayerSwitchedTeam* PROTOBUF_NULLABLE LobbySessionEvent::unsafe_arena_release_player_switched_team() {
  // @@protoc_insertion_point(field_unsafe_arena_release:telemetry.v1.LobbySessionEvent.player_switched_team)
  if (event_case() == kPlayerSwitchedTeam) {
    clear_has_event();
    auto* temp = reinterpret_cast<::telemetry::v1::PlayerSwitchedTeam*>(_impl_.event_.player_switched_team_);
    _impl_.event_.player_switched_team_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void LobbySessionEvent::unsafe_arena_set_allocated_player_switched_team(
    ::telemetry::v1::PlayerSwitchedTeam* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_event();
  if (value) {
    set_has_player_switched_team();
    _impl_.event_.player_switched_team_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:telemetry.v1.LobbySessionEvent.player_switched_team)
}
inline ::telemetry::v1::PlayerSwitchedTeam* PROTOBUF_NONNULL LobbySessionEvent::_internal_mutable_player_switched_team() {
  if (event_case() != kPlayerSwitchedTeam) {
    clear_event();
    set_has_player_switched_team();
    _impl_.event_.player_switched_team_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::telemetry::v1::PlayerSwitchedTeam>(GetArena()));
  }
  return reinterpret_cast<::telemetry::v1::PlayerSwitchedTeam*>(_impl_.event_.player_switched_team_);
}
inline ::telemetry::v1::PlayerSwitchedTeam* PROTOBUF_NONNULL LobbySessionEvent::mutable_player_switched_team()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::telemetry::v1::PlayerSwitchedTeam* _msg = _internal_mutable_player_switched_team();
  // @@protoc_insertion_point(field_mutable:telemetry.v1.LobbySessionEvent.player_switched_team)
  return _msg;
}

// .telemetry.v1.EmotePlayed emote_played = 23 [json_name = "emotePlayed"];
inline bool LobbySessionEvent::has_emote_played() const {
  return event_case() == kEmotePlayed;
}
inline bool LobbySessionEvent::_internal_has_emote_played() const {
  return event_case() == kEmotePlayed;
}
inline void LobbySessionEvent::set_has_emote_played() {
  _impl_._oneof_case_[0] = kEmotePlayed;
}
inline void LobbySessionEvent::clear_emote_played() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (event_case() == kEmotePlayed) {
    if (GetArena() == nullptr) {
      delete _impl_.event_.emote_played_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.event_.emote_played_);
    }
    clear_has_event();
  }
}
inline ::telemetry::v1::EmotePlayed* PROTOBUF_NULLABLE LobbySessionEvent::release_emote_played() {
  // @@protoc_insertion_point(field_release:telemetry.v1.LobbySessionEvent.emote_played)
  if (event_case() == kEmotePlayed) {
    clear_has_event();
    auto* temp = reinterpret_cast<::telemetry::v1::EmotePlayed*>(_impl_.event_.emote_played_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.event_.emote_played_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::telemetry::v1::EmotePlayed& LobbySessionEvent::_internal_emote_played() const {
  return event_case() == kEmotePlayed ? static_cast<const ::telemetry::v1::EmotePlayed&>(*reinterpret_cast<::telemetry::v1::EmotePlayed*>(_impl_.event_.emote_played_))
                     : reinterpret_cast<const ::telemetry::v1::EmotePlayed&>(::telemetry::v1::_EmotePlayed_default_instance_);
}
inline const ::telemetry::v1::EmotePlayed& LobbySessionEvent::emote_played() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:telemetry.v1.LobbySessionEvent.emote_played)
  return _internal_emote_played();
}
inline ::telemetry::v1::EmotePlayed* PROTOBUF_NULLABLE LobbySessionEvent::unsafe_arena_release_emote_played() {
  // @@protoc_insertion_point(field_unsafe_arena_release:telemetry.v1.LobbySessionEvent.emote_played)
  if (event_case() == kEmotePlayed) {
    clear_has_event();
    auto* temp = reinterpret_cast<::telemetry::v1::EmotePlayed*>(_impl_.event_.emote_played_);
    _impl_.event_.emote_played_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void LobbySessionEvent::unsafe_arena_set_allocated_emote_played(
    ::telemetry::v1::EmotePlayed* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_event();
  if (value) {
    set_has_emote_played();
    _impl_.event_.emote_played_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:telemetry.v1.LobbySessionEvent.emote_played)
}
inline ::telemetry::v1::EmotePlayed* PROTOBUF_NONNULL LobbySessionEvent::_internal_mutable_emote_played() {
  if (event_case() != kEmotePlayed) {
    clear_event();
    set_has_emote_played();
    _impl_.event_.emote_played_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::telemetry::v1::EmotePlayed>(GetArena()));
  }
  return reinterpret_cast<::telemetry::v1::EmotePlayed*>(_impl_.event_.emote_played_);
}
inline ::telemetry::v1::EmotePlayed* PROTOBUF_NONNULL LobbySessionEvent::mutable_emote_played()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::telemetry::v1::EmotePlayed* _msg = _internal_mutable_emote_played();
  // @@protoc_insertion_point(field_mutable:telemetry.v1.LobbySessionEvent.emote_played)
  return _msg;
}

// .telemetry.v1.DiscPossessionChanged disc_possession_changed = 30 [json_name = "discPossessionChanged"];
inline bool LobbySessionEvent::has_disc_possession_changed() const {
  return event_case() == kDiscPossessionChanged;
}
inline bool LobbySessionEvent::_internal_has_disc_possession_changed() const {
  return event_case() == kDiscPossessionChanged;
}
inline void LobbySessionEvent::set_has_disc_possession_changed() {
  _impl_._oneof_case_[0] = kDiscPossessionChanged;
}
inline void LobbySessionEvent::clear_disc_possession_changed() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (event_case() == kDiscPossessionChanged) {
    if (GetArena() == nullptr) {
      delete _impl_.event_.disc_possession_changed_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.event_.disc_possession_changed_);
    }
    clear_has_event();
  }
}
inline ::telemetry::v1::DiscPossessionChanged* PROTOBUF_NULLABLE LobbySessionEvent::release_disc_possession_changed() {
  // @@protoc_insertion_point(field_release:telemetry.v1.LobbySessionEvent.disc_possession_changed)
  if (event_case() == kDiscPossessionChanged) {
    clear_has_event();
    auto* temp = reinterpret_cast<::telemetry::v1::DiscPossessionChanged*>(_impl_.event_.disc_possession_changed_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.event_.disc_possession_changed_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::telemetry::v1::DiscPossessionChanged& LobbySessionEvent::_internal_disc_possession_changed() const {
  return event_case() == kDiscPossessionChanged ? static_cast<const ::telemetry::v1::DiscPossessionChanged&>(*reinterpret_cast<::telemetry::v1::DiscPossessionChanged*>(_impl_.event_.disc_possession_changed_))
                     : reinterpret_cast<const ::telemetry::v1::DiscPossessionChanged&>(::telemetry::v1::_DiscPossessionChanged_default_instance_);
}
inline const ::telemetry::v1::DiscPossessionChanged& LobbySessionEvent::disc_possession_changed() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:telemetry.v1.LobbySessionEvent.disc_possession_changed)
  return _internal_disc_possession_changed();
}
inline ::telemetry::v1::DiscPossessionChanged* PROTOBUF_NULLABLE LobbySessionEvent::unsafe_arena_release_disc_possession_changed() {
  // @@protoc_insertion_point(field_unsafe_arena_release:telemetry.v1.LobbySessionEvent.disc_possession_changed)
  if (event_case() == kDiscPossessionChanged) {
    clear_has_event();
    auto* temp = reinterpret_cast<::telemetry::v1::DiscPossessionChanged*>(_impl_.event_.disc_possession_changed_);
    _impl_.event_.disc_possession_changed_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void LobbySessionEvent::unsafe_arena_set_allocated_disc_possession_changed(
    ::telemetry::v1::DiscPossessionChanged* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_event();
  if (value) {
    set_has_disc_possession_changed();
    _impl_.event_.disc_possession_changed_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:telemetry.v1.LobbySessionEvent.disc_possession_changed)
}
inline ::telemetry::v1::DiscPossessionChanged* PROTOBUF_NONNULL LobbySessionEvent::_internal_mutable_disc_possession_changed() {
  if (event_case() != kDiscPossessionChanged) {
    clear_event();
    set_has_disc_possession_changed();
    _impl_.event_.disc_possession_changed_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::telemetry::v1::DiscPossessionChanged>(GetArena()));
  }
  return reinterpret_cast<::telemetry::v1::DiscPossessionChanged*>(_impl_.event_.disc_possession_changed_);
}
inline ::telemetry::v1::DiscPossessionChanged* PROTOBUF_NONNULL LobbySessionEvent::mutable_disc_possession_changed()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::telemetry::v1::DiscPossessionChanged* _msg = _internal_mutable_disc_possession_changed();
  // @@protoc_insertion_point(field_mutable:telemetry.v1.LobbySessionEvent.disc_possession_changed)
  return _msg;
}

// .telemetry.v1.DiscThrown disc_thrown = 31 [json_name = "discThrown"];
inline bool LobbySessionEvent::has_disc_thrown() const {
  return event_case() == kDiscThrown;
}
inline bool LobbySessionEvent::_internal_has_disc_thrown() const {
  return event_case() == kDiscThrown;
}
inline void LobbySessionEvent::set_has_disc_thrown() {
  _impl_._oneof_case_[0] = kDiscThrown;
}
inline void LobbySessionEvent::clear_disc_thrown() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (event_case() == kDiscThrown) {
    if (GetArena() == nullptr) {
      delete _impl_.event_.disc_thrown_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.event_.disc_thrown_);
    }
    clear_has_event();
  }
}
inline ::telemetry::v1::DiscThrown* PROTOBUF_NULLABLE LobbySessionEvent::release_disc_thrown() {
  // @@protoc_insertion_point(field_release:telemetry.v1.LobbySessionEvent.disc_thrown)
  if (event_case() == kDiscThrown) {
    clear_has_event();
    auto* temp = reinterpret_cast<::telemetry::v1::DiscThrown*>(_impl_.event_.disc_thrown_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.event_.disc_thrown_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::telemetry::v1::DiscThrown& LobbySessionEvent::_internal_disc_thrown() const {
  return event_case() == kDiscThrown ? static_cast<const ::telemetry::v1::DiscThrown&>(*reinterpret_cast<::telemetry::v1::DiscThrown*>(_impl_.event_.disc_thrown_))
                     : reinterpret_cast<const ::telemetry::v1::DiscThrown&>(::telemetry::v1::_DiscThrown_default_instance_);
}
inline const ::telemetry::v1::DiscThrown& LobbySessionEvent::disc_thrown() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:telemetry.v1.LobbySessionEvent.disc_thrown)
  return _internal_disc_thrown();
}
inline ::telemetry::v1::DiscThrown* PROTOBUF_NULLABLE LobbySessionEvent::unsafe_arena_release_disc_thrown() {
  // @@protoc_insertion_point(field_unsafe_arena_release:telemetry.v1.LobbySessionEvent.disc_thrown)
  if (event_case() == kDiscThrown) {
    clear_has_event();
    auto* temp = reinterpret_cast<::telemetry::v1::DiscThrown*>(_impl_.event_.disc_thrown_);
    _impl_.event_.disc_thrown_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void LobbySessionEvent::unsafe_arena_set_allocated_disc_thrown(
    ::telemetry::v1::DiscThrown* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_event();
  if (value) {
    set_has_disc_thrown();
    _impl_.event_.disc_thrown_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:telemetry.v1.LobbySessionEvent.disc_thrown)
}
inline ::telemetry::v1::DiscThrown* PROTOBUF_NONNULL LobbySessionEvent::_internal_mutable_disc_thrown() {
  if (event_case() != kDiscThrown) {
    clear_event();
    set_has_disc_thrown();
    _impl_.event_.disc_thrown_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::telemetry::v1::DiscThrown>(GetArena()));
  }
  return reinterpret_cast<::telemetry::v1::DiscThrown*>(_impl_.event_.disc_thrown_);
}
inline ::telemetry::v1::DiscThrown* PROTOBUF_NONNULL LobbySessionEvent::mutable_disc_thrown()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::telemetry::v1::DiscThrown* _msg = _internal_mutable_disc_thrown();
  // @@protoc_insertion_point(field_mutable:telemetry.v1.LobbySessionEvent.disc_thrown)
  return _msg;
}

// .telemetry.v1.DiscCaught disc_caught = 32 [json_name = "discCaught"];
inline bool LobbySessionEvent::has_disc_caught() const {
  return event_case() == kDiscCaught;
}
inline bool LobbySessionEvent::_internal_has_disc_caught() const {
  return event_case() == kDiscCaught;
}
inline void LobbySessionEvent::set_has_disc_caught() {
  _impl_._oneof_case_[0] = kDiscCaught;
}
inline void LobbySessionEvent::clear_disc_caught() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (event_case() == kDiscCaught) {
    if (GetArena() == nullptr) {
      delete _impl_.event_.disc_caught_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.event_.disc_caught_);
    }
    clear_has_event();
  }
}
inline ::telemetry::v1::DiscCaught* PROTOBUF_NULLABLE LobbySessionEvent::release_disc_caught() {
  // @@protoc_insertion_point(field_release:telemetry.v1.LobbySessionEvent.disc_caught)
  if (event_case() == kDiscCaught) {
    clear_has_event();
    auto* temp = reinterpret_cast<::telemetry::v1::DiscCaught*>(_impl_.event_.disc_caught_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.event_.disc_caught_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::telemetry::v1::DiscCaught& LobbySessionEvent::_internal_disc_caught() const {
  return event_case() == kDiscCaught ? static_cast<const ::telemetry::v1::DiscCaught&>(*reinterpret_cast<::telemetry::v1::DiscCaught*>(_impl_.event_.disc_caught_))
                     : reinterpret_cast<const ::telemetry::v1::DiscCaught&>(::telemetry::v1::_DiscCaught_default_instance_);
}
inline const ::telemetry::v1::DiscCaught& LobbySessionEvent::disc_caught() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:telemetry.v1.LobbySessionEvent.disc_caught)
  return _internal_disc_caught();
}
inline ::telemetry::v1::DiscCaught* PROTOBUF_NULLABLE LobbySessionEvent::unsafe_arena_release_disc_caught() {
  // @@protoc_insertion_point(field_unsafe_arena_release:telemetry.v1.LobbySessionEvent.disc_caught)
  if (event_case() == kDiscCaught) {
    clear_has_event();
    auto* temp = reinterpret_cast<::telemetry::v1::DiscCaught*>(_impl_.event_.disc_caught_);
    _impl_.event_.disc_caught_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void LobbySessionEvent::unsafe_arena_set_allocated_disc_caught(
    ::telemetry::v1::DiscCaught* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_event();
  if (value) {
    set_has_disc_caught();
    _impl_.event_.disc_caught_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:telemetry.v1.LobbySessionEvent.disc_caught)
}
inline ::telemetry::v1::DiscCaught* PROTOBUF_NONNULL LobbySessionEvent::_internal_mutable_disc_caught() {
  if (event_case() != kDiscCaught) {
    clear_event();
    set_has_disc_caught();
    _impl_.event_.disc_caught_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::telemetry::v1::DiscCaught>(GetArena()));
  }
  return reinterpret_cast<::telemetry::v1::DiscCaught*>(_impl_.event_.disc_caught_);
}
inline ::telemetry::v1::DiscCaught* PROTOBUF_NONNULL LobbySessionEvent::mutable_disc_caught()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::telemetry::v1::DiscCaught* _msg = _internal_mutable_disc_caught();
  // @@protoc_insertion_point(field_mutable:telemetry.v1.LobbySessionEvent.disc_caught)
  return _msg;
}

// .telemetry.v1.GoalScored goal_scored = 40 [json_name = "goalScored"];
inline bool LobbySessionEvent::has_goal_scored() const {
  return event_case() == kGoalScored;
}
inline bool LobbySessionEvent::_internal_has_goal_scored() const {
  return event_case() == kGoalScored;
}
inline void LobbySessionEvent::set_has_goal_scored() {
  _impl_._oneof_case_[0] = kGoalScored;
}
inline void LobbySessionEvent::clear_goal_scored() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (event_case() == kGoalScored) {
    if (GetArena() == nullptr) {
      delete _impl_.event_.goal_scored_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.event_.goal_scored_);
    }
    clear_has_event();
  }
}
inline ::telemetry::v1::GoalScored* PROTOBUF_NULLABLE LobbySessionEvent::release_goal_scored() {
  // @@protoc_insertion_point(field_release:telemetry.v1.LobbySessionEvent.goal_scored)
  if (event_case() == kGoalScored) {
    clear_has_event();
    auto* temp = reinterpret_cast<::telemetry::v1::GoalScored*>(_impl_.event_.goal_scored_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.event_.goal_scored_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::telemetry::v1::GoalScored& LobbySessionEvent::_internal_goal_scored() const {
  return event_case() == kGoalScored ? static_cast<const ::telemetry::v1::GoalScored&>(*reinterpret_cast<::telemetry::v1::GoalScored*>(_impl_.event_.goal_scored_))
                     : reinterpret_cast<const ::telemetry::v1::GoalScored&>(::telemetry::v1::_GoalScored_default_instance_);
}
inline const ::telemetry::v1::GoalScored& LobbySessionEvent::goal_scored() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:telemetry.v1.LobbySessionEvent.goal_scored)
  return _internal_goal_scored();
}
inline ::telemetry::v1::GoalScored* PROTOBUF_NULLABLE LobbySessionEvent::unsafe_arena_release_goal_scored() {
  // @@protoc_insertion_point(field_unsafe_arena_release:telemetry.v1.LobbySessionEvent.goal_scored)
  if (event_case() == kGoalScored) {
    clear_has_event();
    auto* temp = reinterpret_cast<::telemetry::v1::GoalScored*>(_impl_.event_.goal_scored_);
    _impl_.event_.goal_scored_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void LobbySessionEvent::unsafe_arena_set_allocated_goal_scored(
    ::telemetry::v1::GoalScored* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_event();
  if (value) {
    set_has_goal_scored();
    _impl_.event_.goal_scored_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:telemetry.v1.LobbySessionEvent.goal_scored)
}
inline ::telemetry::v1::GoalScored* PROTOBUF_NONNULL LobbySessionEvent::_internal_mutable_goal_scored() {
  if (event_case() != kGoalScored) {
    clear_event();
    set_has_goal_scored();
    _impl_.event_.goal_scored_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::telemetry::v1::GoalScored>(GetArena()));
  }
  return reinterpret_cast<::telemetry::v1::GoalScored*>(_impl_.event_.goal_scored_);
}
inline ::telemetry::v1::GoalScored* PROTOBUF_NONNULL LobbySessionEvent::mutable_goal_scored()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::telemetry::v1::GoalScored* _msg = _internal_mutable_goal_scored();
  // @@protoc_insertion_point(field_mutable:telemetry.v1.LobbySessionEvent.goal_scored)
  return _msg;
}

// .telemetry.v1.PlayerGoal player_goal = 41 [json_name = "playerGoal"];
inline bool LobbySessionEvent::has_player_goal() const {
  return event_case() == kPlayerGoal;
}
inline bool LobbySessionEvent::_internal_has_player_goal() const {
  return event_case() == kPlayerGoal;
}
inline void LobbySessionEvent::set_has_player_goal() {
  _impl_._oneof_case_[0] = kPlayerGoal;
}
inline void LobbySessionEvent::clear_player_goal() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (event_case() == kPlayerGoal) {
    if (GetArena() == nullptr) {
      delete _impl_.event_.player_goal_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.event_.player_goal_);
    }
    clear_has_event();
  }
}
inline ::telemetry::v1::PlayerGoal* PROTOBUF_NULLABLE LobbySessionEvent::release_player_goal() {
  // @@protoc_insertion_point(field_release:telemetry.v1.LobbySessionEvent.player_goal)
  if (event_case() == kPlayerGoal) {
    clear_has_event();
    auto* temp = reinterpret_cast<::telemetry::v1::PlayerGoal*>(_impl_.event_.player_goal_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.event_.player_goal_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::telemetry::v1::PlayerGoal& LobbySessionEvent::_internal_player_goal() const {
  return event_case() == kPlayerGoal ? static_cast<const ::telemetry::v1::PlayerGoal&>(*reinterpret_cast<::telemetry::v1::PlayerGoal*>(_impl_.event_.player_goal_))
                     : reinterpret_cast<const ::telemetry::v1::PlayerGoal&>(::telemetry::v1::_PlayerGoal_default_instance_);
}
inline const ::telemetry::v1::PlayerGoal& LobbySessionEvent::player_goal() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:telemetry.v1.LobbySessionEvent.player_goal)
  return _internal_player_goal();
}
inline ::telemetry::v1::PlayerGoal* PROTOBUF_NULLABLE LobbySessionEvent::unsafe_arena_release_player_goal() {
  // @@protoc_insertion_point(field_unsafe_arena_release:telemetry.v1.LobbySessionEvent.player_goal)
  if (event_case() == kPlayerGoal) {
    clear_has_event();
    auto* temp = reinterpret_cast<::telemetry::v1::PlayerGoal*>(_impl_.event_.player_goal_);
    _impl_.event_.player_goal_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void LobbySessionEvent::unsafe_arena_set_allocated_player_goal(
    ::telemetry::v1::PlayerGoal* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_event();
  if (value) {
    set_has_player_goal();
    _impl_.event_.player_goal_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:telemetry.v1.LobbySessionEvent.player_goal)
}
inline ::telemetry::v1::PlayerGoal* PROTOBUF_NONNULL LobbySessionEvent::_internal_mutable_player_goal() {
  if (event_case() != kPlayerGoal) {
    clear_event();
    set_has_player_goal();
    _impl_.event_.player_goal_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::telemetry::v1::PlayerGoal>(GetArena()));
  }
  return reinterpret_cast<::telemetry::v1::PlayerGoal*>(_impl_.event_.player_goal_);
}
inline ::telemetry::v1::PlayerGoal* PROTOBUF_NONNULL LobbySessionEvent::mutable_player_goal()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::telemetry::v1::PlayerGoal* _msg = _internal_mutable_player_goal();
  // @@protoc_insertion_point(field_mutable:telemetry.v1.LobbySessionEvent.player_goal)
  return _msg;
}

// .telemetry.v1.PlayerSave player_save = 50 [json_name = "playerSave"];
inline bool LobbySessionEvent::has_player_save() const {
  return event_case() == kPlayerSave;
}
inline bool LobbySessionEvent::_internal_has_player_save() const {
  return event_case() == kPlayerSave;
}
inline void LobbySessionEvent::set_has_player_save() {
  _impl_._oneof_case_[0] = kPlayerSave;
}
inline void LobbySessionEvent::clear_player_save() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (event_case() == kPlayerSave) {
    if (GetArena() == nullptr) {
      delete _impl_.event_.player_save_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.event_.player_save_);
    }
    clear_has_event();
  }
}
inline ::telemetry::v1::PlayerSave* PROTOBUF_NULLABLE LobbySessionEvent::release_player_save() {
  // @@protoc_insertion_point(field_release:telemetry.v1.LobbySessionEvent.player_save)
  if (event_case() == kPlayerSave) {
    clear_has_event();
    auto* temp = reinterpret_cast<::telemetry::v1::PlayerSave*>(_impl_.event_.player_save_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.event_.player_save_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::telemetry::v1::PlayerSave& LobbySessionEvent::_internal_player_save() const {
  return event_case() == kPlayerSave ? static_cast<const ::telemetry::v1::PlayerSave&>(*reinterpret_cast<::telemetry::v1::PlayerSave*>(_impl_.event_.player_save_))
                     : reinterpret_cast<const ::telemetry::v1::PlayerSave&>(::telemetry::v1::_PlayerSave_default_instance_);
}
inline const ::telemetry::v1::PlayerSave& LobbySessionEvent::player_save() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:telemetry.v1.LobbySessionEvent.player_save)
  return _internal_player_save();
}
inline ::telemetry::v1::PlayerSave* PROTOBUF_NULLABLE LobbySessionEvent::unsafe_arena_release_player_save() {
  // @@protoc_insertion_point(field_unsafe_arena_release:telemetry.v1.LobbySessionEvent.player_save)
  if (event_case() == kPlayerSave) {
    clear_has_event();
    auto* temp = reinterpret_cast<::telemetry::v1::PlayerSave*>(_impl_.event_.player_save_);
    _impl_.event_.player_save_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void LobbySessionEvent::unsafe_arena_set_allocated_player_save(
    ::telemetry::v1::PlayerSave* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_event();
  if (value) {
    set_has_player_save();
    _impl_.event_.player_save_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:telemetry.v1.LobbySessionEvent.player_save)
}
inline ::telemetry::v1::PlayerSave* PROTOBUF_NONNULL LobbySessionEvent::_internal_mutable_player_save() {
  if (event_case() != kPlayerSave) {
    clear_event();
    set_has_player_save();
    _impl_.event_.player_save_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::telemetry::v1::PlayerSave>(GetArena()));
  }
  return reinterpret_cast<::telemetry::v1::PlayerSave*>(_impl_.event_.player_save_);
}
inline ::telemetry::v1::PlayerSave* PROTOBUF_NONNULL LobbySessionEvent::mutable_player_save()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::telemetry::v1::PlayerSave* _msg = _internal_mutable_player_save();
  // @@protoc_insertion_point(field_mutable:telemetry.v1.LobbySessionEvent.player_save)
  return _msg;
}

// .telemetry.v1.PlayerStun player_stun = 51 [json_name = "playerStun"];
inline bool LobbySessionEvent::has_player_stun() const {
  return event_case() == kPlayerStun;
}
inline bool LobbySessionEvent::_internal_has_player_stun() const {
  return event_case() == kPlayerStun;
}
inline void LobbySessionEvent::set_has_player_stun() {
  _impl_._oneof_case_[0] = kPlayerStun;
}
inline void LobbySessionEvent::clear_player_stun() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (event_case() == kPlayerStun) {
    if (GetArena() == nullptr) {
      delete _impl_.event_.player_stun_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.event_.player_stun_);
    }
    clear_has_event();
  }
}
inline ::telemetry::v1::PlayerStun* PROTOBUF_NULLABLE LobbySessionEvent::release_player_stun() {
  // @@protoc_insertion_point(field_release:telemetry.v1.LobbySessionEvent.player_stun)
  if (event_case() == kPlayerStun) {
    clear_has_event();
    auto* temp = reinterpret_cast<::telemetry::v1::PlayerStun*>(_impl_.event_.player_stun_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.event_.player_stun_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::telemetry::v1::PlayerStun& LobbySessionEvent::_internal_player_stun() const {
  return event_case() == kPlayerStun ? static_cast<const ::telemetry::v1::PlayerStun&>(*reinterpret_cast<::telemetry::v1::PlayerStun*>(_impl_.event_.player_stun_))
                     : reinterpret_cast<const ::telemetry::v1::PlayerStun&>(::telemetry::v1::_PlayerStun_default_instance_);
}
inline const ::telemetry::v1::PlayerStun& LobbySessionEvent::player_stun() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:telemetry.v1.LobbySessionEvent.player_stun)
  return _internal_player_stun();
}
inline ::telemetry::v1::PlayerStun* PROTOBUF_NULLABLE LobbySessionEvent::unsafe_arena_release_player_stun() {
  // @@protoc_insertion_point(field_unsafe_arena_release:telemetry.v1.LobbySessionEvent.player_stun)
  if (event_case() == kPlayerStun) {
    clear_has_event();
    auto* temp = reinterpret_cast<::telemetry::v1::PlayerStun*>(_impl_.event_.player_stun_);
    _impl_.event_.player_stun_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void LobbySessionEvent::unsafe_arena_set_allocated_player_stun(
    ::telemetry::v1::PlayerStun* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_event();
  if (value) {
    set_has_player_stun();
    _impl_.event_.player_stun_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:telemetry.v1.LobbySessionEvent.player_stun)
}
inline ::telemetry::v1::PlayerStun* PROTOBUF_NONNULL LobbySessionEvent::_internal_mutable_player_stun() {
  if (event_case() != kPlayerStun) {
    clear_event();
    set_has_player_stun();
    _impl_.event_.player_stun_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::telemetry::v1::PlayerStun>(GetArena()));
  }
  return reinterpret_cast<::telemetry::v1::PlayerStun*>(_impl_.event_.player_stun_);
}
inline ::telemetry::v1::PlayerStun* PROTOBUF_NONNULL LobbySessionEvent::mutable_player_stun()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::telemetry::v1::PlayerStun* _msg = _internal_mutable_player_stun();
  // @@protoc_insertion_point(field_mutable:telemetry.v1.LobbySessionEvent.player_stun)
  return _msg;
}

// .telemetry.v1.PlayerPass player_pass = 52 [json_name = "playerPass"];
inline bool LobbySessionEvent::has_player_pass() const {
  return event_case() == kPlayerPass;
}
inline bool LobbySessionEvent::_internal_has_player_pass() const {
  return event_case() == kPlayerPass;
}
inline void LobbySessionEvent::set_has_player_pass() {
  _impl_._oneof_case_[0] = kPlayerPass;
}
inline void LobbySessionEvent::clear_player_pass() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (event_case() == kPlayerPass) {
    if (GetArena() == nullptr) {
      delete _impl_.event_.player_pass_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.event_.player_pass_);
    }
    clear_has_event();
  }
}
inline ::telemetry::v1::PlayerPass* PROTOBUF_NULLABLE LobbySessionEvent::release_player_pass() {
  // @@protoc_insertion_point(field_release:telemetry.v1.LobbySessionEvent.player_pass)
  if (event_case() == kPlayerPass) {
    clear_has_event();
    auto* temp = reinterpret_cast<::telemetry::v1::PlayerPass*>(_impl_.event_.player_pass_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.event_.player_pass_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::telemetry::v1::PlayerPass& LobbySessionEvent::_internal_player_pass() const {
  return event_case() == kPlayerPass ? static_cast<const ::telemetry::v1::PlayerPass&>(*reinterpret_cast<::telemetry::v1::PlayerPass*>(_impl_.event_.player_pass_))
                     : reinterpret_cast<const ::telemetry::v1::PlayerPass&>(::telemetry::v1::_PlayerPass_default_instance_);
}
inline const ::telemetry::v1::PlayerPass& LobbySessionEvent::player_pass() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:telemetry.v1.LobbySessionEvent.player_pass)
  return _internal_player_pass();
}
inline ::telemetry::v1::PlayerPass* PROTOBUF_NULLABLE LobbySessionEvent::unsafe_arena_release_player_pass() {
  // @@protoc_insertion_point(field_unsafe_arena_release:telemetry.v1.LobbySessionEvent.player_pass)
  if (event_case() == kPlayerPass) {
    clear_has_event();
    auto* temp = reinterpret_cast<::telemetry::v1::PlayerPass*>(_impl_.event_.player_pass_);
    _impl_.event_.player_pass_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void LobbySessionEvent::unsafe_arena_set_allocated_player_pass(
    ::telemetry::v1::PlayerPass* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_event();
  if (value) {
    set_has_player_pass();
    _impl_.event_.player_pass_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:telemetry.v1.LobbySessionEvent.player_pass)
}
inline ::telemetry::v1::PlayerPass* PROTOBUF_NONNULL LobbySessionEvent::_internal_mutable_player_pass() {
  if (event_case() != kPlayerPass) {
    clear_event();
    set_has_player_pass();
    _impl_.event_.player_pass_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::telemetry::v1::PlayerPass>(GetArena()));
  }
  return reinterpret_cast<::telemetry::v1::PlayerPass*>(_impl_.event_.player_pass_);
}
inline ::telemetry::v1::PlayerPass* PROTOBUF_NONNULL LobbySessionEvent::mutable_player_pass()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::telemetry::v1::PlayerPass* _msg = _internal_mutable_player_pass();
  // @@protoc_insertion_point(field_mutable:telemetry.v1.LobbySessionEvent.player_pass)
  return _msg;
}

// .telemetry.v1.PlayerSteal player_steal = 53 [json_name = "playerSteal"];
inline bool LobbySessionEvent::has_player_steal() const {
  return event_case() == kPlayerSteal;
}
inline bool LobbySessionEvent::_internal_has_player_steal() const {
  return event_case() == kPlayerSteal;
}
inline void LobbySessionEvent::set_has_player_steal() {
  _impl_._oneof_case_[0] = kPlayerSteal;
}
inline void LobbySessionEvent::clear_player_steal() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (event_case() == kPlayerSteal) {
    if (GetArena() == nullptr) {
      delete _impl_.event_.player_steal_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.event_.player_steal_);
    }
    clear_has_event();
  }
}
inline ::telemetry::v1::PlayerSteal* PROTOBUF_NULLABLE LobbySessionEvent::release_player_steal() {
  // @@protoc_insertion_point(field_release:telemetry.v1.LobbySessionEvent.player_steal)
  if (event_case() == kPlayerSteal) {
    clear_has_event();
    auto* temp = reinterpret_cast<::telemetry::v1::PlayerSteal*>(_impl_.event_.player_steal_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.event_.player_steal_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::telemetry::v1::PlayerSteal& LobbySessionEvent::_internal_player_steal() const {
  return event_case() == kPlayerSteal ? static_cast<const ::telemetry::v1::PlayerSteal&>(*reinterpret_cast<::telemetry::v1::PlayerSteal*>(_impl_.event_.player_steal_))
                     : reinterpret_cast<const ::telemetry::v1::PlayerSteal&>(::telemetry::v1::_PlayerSteal_default_instance_);
}
inline const ::telemetry::v1::PlayerSteal& LobbySessionEvent::player_steal() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:telemetry.v1.LobbySessionEvent.player_steal)
  return _internal_player_steal();
}
inline ::telemetry::v1::PlayerSteal* PROTOBUF_NULLABLE LobbySessionEvent::unsafe_arena_release_player_steal() {
  // @@protoc_insertion_point(field_unsafe_arena_release:telemetry.v1.LobbySessionEvent.player_steal)
  if (event_case() == kPlayerSteal) {
    clear_has_event();
    auto* temp = reinterpret_cast<::telemetry::v1::PlayerSteal*>(_impl_.event_.player_steal_);
    _impl_.event_.player_steal_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void LobbySessionEvent::unsafe_arena_set_allocated_player_steal(
    ::telemetry::v1::PlayerSteal* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_event();
  if (value) {
    set_has_player_steal();
    _impl_.event_.player_steal_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:telemetry.v1.LobbySessionEvent.player_steal)
}
inline ::telemetry::v1::PlayerSteal* PROTOBUF_NONNULL LobbySessionEvent::_internal_mutable_player_steal() {
  if (event_case() != kPlayerSteal) {
    clear_event();
    set_has_player_steal();
    _impl_.event_.player_steal_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::telemetry::v1::PlayerSteal>(GetArena()));
  }
  return reinterpret_cast<::telemetry::v1::PlayerSteal*>(_impl_.event_.player_steal_);
}
inline ::telemetry::v1::PlayerSteal* PROTOBUF_NONNULL LobbySessionEvent::mutable_player_steal()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::telemetry::v1::PlayerSteal* _msg = _internal_mutable_player_steal();
  // @@protoc_insertion_point(field_mutable:telemetry.v1.LobbySessionEvent.player_steal)
  return _msg;
}

// .telemetry.v1.PlayerBlock player_block = 54 [json_name = "playerBlock"];
inline bool LobbySessionEvent::has_player_block() const {
  return event_case() == kPlayerBlock;
}
inline bool LobbySessionEvent::_internal_has_player_block() const {
  return event_case() == kPlayerBlock;
}
inline void LobbySessionEvent::set_has_player_block() {
  _impl_._oneof_case_[0] = kPlayerBlock;
}
inline void LobbySessionEvent::clear_player_block() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (event_case() == kPlayerBlock) {
    if (GetArena() == nullptr) {
      delete _impl_.event_.player_block_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.event_.player_block_);
    }
    clear_has_event();
  }
}
inline ::telemetry::v1::PlayerBlock* PROTOBUF_NULLABLE LobbySessionEvent::release_player_block() {
  // @@protoc_insertion_point(field_release:telemetry.v1.LobbySessionEvent.player_block)
  if (event_case() == kPlayerBlock) {
    clear_has_event();
    auto* temp = reinterpret_cast<::telemetry::v1::PlayerBlock*>(_impl_.event_.player_block_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.event_.player_block_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::telemetry::v1::PlayerBlock& LobbySessionEvent::_internal_player_block() const {
  return event_case() == kPlayerBlock ? static_cast<const ::telemetry::v1::PlayerBlock&>(*reinterpret_cast<::telemetry::v1::PlayerBlock*>(_impl_.event_.player_block_))
                     : reinterpret_cast<const ::telemetry::v1::PlayerBlock&>(::telemetry::v1::_PlayerBlock_default_instance_);
}
inline const ::telemetry::v1::PlayerBlock& LobbySessionEvent::player_block() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:telemetry.v1.LobbySessionEvent.player_block)
  return _internal_player_block();
}
inline ::telemetry::v1::PlayerBlock* PROTOBUF_NULLABLE LobbySessionEvent::unsafe_arena_release_player_block() {
  // @@protoc_insertion_point(field_unsafe_arena_release:telemetry.v1.LobbySessionEvent.player_block)
  if (event_case() == kPlayerBlock) {
    clear_has_event();
    auto* temp = reinterpret_cast<::telemetry::v1::PlayerBlock*>(_impl_.event_.player_block_);
    _impl_.event_.player_block_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void LobbySessionEvent::unsafe_arena_set_allocated_player_block(
    ::telemetry::v1::PlayerBlock* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_event();
  if (value) {
    set_has_player_block();
    _impl_.event_.player_block_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:telemetry.v1.LobbySessionEvent.player_block)
}
inline ::telemetry::v1::PlayerBlock* PROTOBUF_NONNULL LobbySessionEvent::_internal_mutable_player_block() {
  if (event_case() != kPlayerBlock) {
    clear_event();
    set_has_player_block();
    _impl_.event_.player_block_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::telemetry::v1::PlayerBlock>(GetArena()));
  }
  return reinterpret_cast<::telemetry::v1::PlayerBlock*>(_impl_.event_.player_block_);
}
inline ::telemetry::v1::PlayerBlock* PROTOBUF_NONNULL LobbySessionEvent::mutable_player_block()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::telemetry::v1::PlayerBlock* _msg = _internal_mutable_player_block();
  // @@protoc_insertion_point(field_mutable:telemetry.v1.LobbySessionEvent.player_block)
  return _msg;
}

// .telemetry.v1.PlayerInterception player_interception = 55 [json_name = "playerInterception"];
inline bool LobbySessionEvent::has_player_interception() const {
  return event_case() == kPlayerInterception;
}
inline bool LobbySessionEvent::_internal_has_player_interception() const {
  return event_case() == kPlayerInterception;
}
inline void LobbySessionEvent::set_has_player_interception() {
  _impl_._oneof_case_[0] = kPlayerInterception;
}
inline void LobbySessionEvent::clear_player_interception() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (event_case() == kPlayerInterception) {
    if (GetArena() == nullptr) {
      delete _impl_.event_.player_interception_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.event_.player_interception_);
    }
    clear_has_event();
  }
}
inline ::telemetry::v1::PlayerInterception* PROTOBUF_NULLABLE LobbySessionEvent::release_player_interception() {
  // @@protoc_insertion_point(field_release:telemetry.v1.LobbySessionEvent.player_interception)
  if (event_case() == kPlayerInterception) {
    clear_has_event();
    auto* temp = reinterpret_cast<::telemetry::v1::PlayerInterception*>(_impl_.event_.player_interception_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.event_.player_interception_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::telemetry::v1::PlayerInterception& LobbySessionEvent::_internal_player_interception() const {
  return event_case() == kPlayerInterception ? static_cast<const ::telemetry::v1::PlayerInterception&>(*reinterpret_cast<::telemetry::v1::PlayerInterception*>(_impl_.event_.player_interception_))
                     : reinterpret_cast<const ::telemetry::v1::PlayerInterception&>(::telemetry::v1::_PlayerInterception_default_instance_);
}
inline const ::telemetry::v1::PlayerInterception& LobbySessionEvent::player_interception() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:telemetry.v1.LobbySessionEvent.player_interception)
  return _internal_player_interception();
}
inline ::telemetry::v1::PlayerInterception* PROTOBUF_NULLABLE LobbySessionEvent::unsafe_arena_release_player_interception() {
  // @@protoc_insertion_point(field_unsafe_arena_release:telemetry.v1.LobbySessionEvent.player_interception)
  if (event_case() == kPlayerInterception) {
    clear_has_event();
    auto* temp = reinterpret_cast<::telemetry::v1::PlayerInterception*>(_impl_.event_.player_interception_);
    _impl_.event_.player_interception_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void LobbySessionEvent::unsafe_arena_set_allocated_player_interception(
    ::telemetry::v1::PlayerInterception* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_event();
  if (value) {
    set_has_player_interception();
    _impl_.event_.player_interception_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:telemetry.v1.LobbySessionEvent.player_interception)
}
inline ::telemetry::v1::PlayerInterception* PROTOBUF_NONNULL LobbySessionEvent::_internal_mutable_player_interception() {
  if (event_case() != kPlayerInterception) {
    clear_event();
    set_has_player_interception();
    _impl_.event_.player_interception_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::telemetry::v1::PlayerInterception>(GetArena()));
  }
  return reinterpret_cast<::telemetry::v1::PlayerInterception*>(_impl_.event_.player_interception_);
}
inline ::telemetry::v1::PlayerInterception* PROTOBUF_NONNULL LobbySessionEvent::mutable_player_interception()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::telemetry::v1::PlayerInterception* _msg = _internal_mutable_player_interception();
  // @@protoc_insertion_point(field_mutable:telemetry.v1.LobbySessionEvent.player_interception)
  return _msg;
}

// .telemetry.v1.PlayerAssist player_assist = 56 [json_name = "playerAssist"];
inline bool LobbySessionEvent::has_player_assist() const {
  return event_case() == kPlayerAssist;
}
inline bool LobbySessionEvent::_internal_has_player_assist() const {
  return event_case() == kPlayerAssist;
}
inline void LobbySessionEvent::set_has_player_assist() {
  _impl_._oneof_case_[0] = kPlayerAssist;
}
inline void LobbySessionEvent::clear_player_assist() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (event_case() == kPlayerAssist) {
    if (GetArena() == nullptr) {
      delete _impl_.event_.player_assist_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.event_.player_assist_);
    }
    clear_has_event();
  }
}
inline ::telemetry::v1::PlayerAssist* PROTOBUF_NULLABLE LobbySessionEvent::release_player_assist() {
  // @@protoc_insertion_point(field_release:telemetry.v1.LobbySessionEvent.player_assist)
  if (event_case() == kPlayerAssist) {
    clear_has_event();
    auto* temp = reinterpret_cast<::telemetry::v1::PlayerAssist*>(_impl_.event_.player_assist_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.event_.player_assist_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::telemetry::v1::PlayerAssist& LobbySessionEvent::_internal_player_assist() const {
  return event_case() == kPlayerAssist ? static_cast<const ::telemetry::v1::PlayerAssist&>(*reinterpret_cast<::telemetry::v1::PlayerAssist*>(_impl_.event_.player_assist_))
                     : reinterpret_cast<const ::telemetry::v1::PlayerAssist&>(::telemetry::v1::_PlayerAssist_default_instance_);
}
inline const ::telemetry::v1::PlayerAssist& LobbySessionEvent::player_assist() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:telemetry.v1.LobbySessionEvent.player_assist)
  return _internal_player_assist();
}
inline ::telemetry::v1::PlayerAssist* PROTOBUF_NULLABLE LobbySessionEvent::unsafe_arena_release_player_assist() {
  // @@protoc_insertion_point(field_unsafe_arena_release:telemetry.v1.LobbySessionEvent.player_assist)
  if (event_case() == kPlayerAssist) {
    clear_has_event();
    auto* temp = reinterpret_cast<::telemetry::v1::PlayerAssist*>(_impl_.event_.player_assist_);
    _impl_.event_.player_assist_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void LobbySessionEvent::unsafe_arena_set_allocated_player_assist(
    ::telemetry::v1::PlayerAssist* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_event();
  if (value) {
    set_has_player_assist();
    _impl_.event_.player_assist_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:telemetry.v1.LobbySessionEvent.player_assist)
}
inline ::telemetry::v1::PlayerAssist* PROTOBUF_NONNULL LobbySessionEvent::_internal_mutable_player_assist() {
  if (event_case() != kPlayerAssist) {
    clear_event();
    set_has_player_assist();
    _impl_.event_.player_assist_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::telemetry::v1::PlayerAssist>(GetArena()));
  }
  return reinterpret_cast<::telemetry::v1::PlayerAssist*>(_impl_.event_.player_assist_);
}
inline ::telemetry::v1::PlayerAssist* PROTOBUF_NONNULL LobbySessionEvent::mutable_player_assist()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::telemetry::v1::PlayerAssist* _msg = _internal_mutable_player_assist();
  // @@protoc_insertion_point(field_mutable:telemetry.v1.LobbySessionEvent.player_assist)
  return _msg;
}

// .telemetry.v1.PlayerShotTaken player_shot_taken = 57 [json_name = "playerShotTaken"];
inline bool LobbySessionEvent::has_player_shot_taken() const {
  return event_case() == kPlayerShotTaken;
}
inline bool LobbySessionEvent::_internal_has_player_shot_taken() const {
  return event_case() == kPlayerShotTaken;
}
inline void LobbySessionEvent::set_has_player_shot_taken() {
  _impl_._oneof_case_[0] = kPlayerShotTaken;
}
inline void LobbySessionEvent::clear_player_shot_taken() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (event_case() == kPlayerShotTaken) {
    if (GetArena() == nullptr) {
      delete _impl_.event_.player_shot_taken_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.event_.player_shot_taken_);
    }
    clear_has_event();
  }
}
inline ::telemetry::v1::PlayerShotTaken* PROTOBUF_NULLABLE LobbySessionEvent::release_player_shot_taken() {
  // @@protoc_insertion_point(field_release:telemetry.v1.LobbySessionEvent.player_shot_taken)
  if (event_case() == kPlayerShotTaken) {
    clear_has_event();
    auto* temp = reinterpret_cast<::telemetry::v1::PlayerShotTaken*>(_impl_.event_.player_shot_taken_);
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.event_.player_shot_taken_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::telemetry::v1::PlayerShotTaken& LobbySessionEvent::_internal_player_shot_taken() const {
  return event_case() == kPlayerShotTaken ? static_cast<const ::telemetry::v1::PlayerShotTaken&>(*reinterpret_cast<::telemetry::v1::PlayerShotTaken*>(_impl_.event_.player_shot_taken_))
                     : reinterpret_cast<const ::telemetry::v1::PlayerShotTaken&>(::telemetry::v1::_PlayerShotTaken_default_instance_);
}
inline const ::telemetry::v1::PlayerShotTaken& LobbySessionEvent::player_shot_taken() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:telemetry.v1.LobbySessionEvent.player_shot_taken)
  return _internal_player_shot_taken();
}
inline ::telemetry::v1::PlayerShotTaken* PROTOBUF_NULLABLE LobbySessionEvent::unsafe_arena_release_player_shot_taken() {
  // @@protoc_insertion_point(field_unsafe_arena_release:telemetry.v1.LobbySessionEvent.player_shot_taken)
  if (event_case() == kPlayerShotTaken) {
    clear_has_event();
    auto* temp = reinterpret_cast<::telemetry::v1::PlayerShotTaken*>(_impl_.event_.player_shot_taken_);
    _impl_.event_.player_shot_taken_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void LobbySessionEvent::unsafe_arena_set_allocated_player_shot_taken(
    ::telemetry::v1::PlayerShotTaken* PROTOBUF_NULLABLE value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_event();
  if (value) {
    set_has_player_shot_taken();
    _impl_.event_.player_shot_taken_ = reinterpret_cast<::google::protobuf::Message*>(value);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:telemetry.v1.LobbySessionEvent.player_shot_taken)
}
inline ::telemetry::v1::PlayerShotTaken* PROTOBUF_NONNULL LobbySessionEvent::_internal_mutable_player_shot_taken() {
  if (event_case() != kPlayerShotTaken) {
    clear_event();
    set_has_player_shot_taken();
    _impl_.event_.player_shot_taken_ = reinterpret_cast<::google::protobuf::Message*>(
        ::google::protobuf::Message::DefaultConstruct<::telemetry::v1::PlayerShotTaken>(GetArena()));
  }
  return reinterpret_cast<::telemetry::v1::PlayerShotTaken*>(_impl_.event_.player_shot_taken_);
}
inline ::telemetry::v1::PlayerShotTaken* PROTOBUF_NONNULL LobbySessionEvent::mutable_player_shot_taken()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::telemetry::v1::PlayerShotTaken* _msg = _internal_mutable_player_shot_taken();
  // @@protoc_insertion_point(field_mutable:telemetry.v1.LobbySessionEvent.player_shot_taken)
  return _msg;
}

inline bool LobbySessionEvent::has_event() const {
  return event_case() != EVENT_NOT_SET;
}
inline void LobbySessionEvent::clear_has_event() {
  _impl_._oneof_case_[0] = EVENT_NOT_SET;
}
inline LobbySessionEvent::EventCase LobbySessionEvent::event_case() const {
  return LobbySessionEvent::EventCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// RoundStarted

// int32 round_number = 1 [json_name = "roundNumber"];
inline void RoundStarted::clear_round_number() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.round_number_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline ::int32_t RoundStarted::round_number() const {
  // @@protoc_insertion_point(field_get:telemetry.v1.RoundStarted.round_number)
  return _internal_round_number();
}
inline void RoundStarted::set_round_number(::int32_t value) {
  _internal_set_round_number(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_set:telemetry.v1.RoundStarted.round_number)
}
inline ::int32_t RoundStarted::_internal_round_number() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.round_number_;
}
inline void RoundStarted::_internal_set_round_number(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.round_number_ = value;
}

// -------------------------------------------------------------------

// RoundPaused

// .enginehttp.PauseState pause_state = 1 [json_name = "pauseState"];
inline bool RoundPaused::has_pause_state() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000001U);
  PROTOBUF_ASSUME(!value || _impl_.pause_state_ != nullptr);
  return value;
}
inline const ::enginehttp::PauseState& RoundPaused::_internal_pause_state() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::enginehttp::PauseState* p = _impl_.pause_state_;
  return p != nullptr ? *p : reinterpret_cast<const ::enginehttp::PauseState&>(::enginehttp::_PauseState_default_instance_);
}
inline const ::enginehttp::PauseState& RoundPaused::pause_state() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:telemetry.v1.RoundPaused.pause_state)
  return _internal_pause_state();
}
inline void RoundPaused::unsafe_arena_set_allocated_pause_state(
    ::enginehttp::PauseState* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.pause_state_);
  }
  _impl_.pause_state_ = reinterpret_cast<::enginehttp::PauseState*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:telemetry.v1.RoundPaused.pause_state)
}
inline ::enginehttp::PauseState* PROTOBUF_NULLABLE RoundPaused::release_pause_state() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::enginehttp::PauseState* released = _impl_.pause_state_;
  _impl_.pause_state_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::enginehttp::PauseState* PROTOBUF_NULLABLE RoundPaused::unsafe_arena_release_pause_state() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:telemetry.v1.RoundPaused.pause_state)

  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::enginehttp::PauseState* temp = _impl_.pause_state_;
  _impl_.pause_state_ = nullptr;
  return temp;
}
inline ::enginehttp::PauseState* PROTOBUF_NONNULL RoundPaused::_internal_mutable_pause_state() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.pause_state_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::enginehttp::PauseState>(GetArena());
    _impl_.pause_state_ = reinterpret_cast<::enginehttp::PauseState*>(p);
  }
  return _impl_.pause_state_;
}
inline ::enginehttp::PauseState* PROTOBUF_NONNULL RoundPaused::mutable_pause_state()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::enginehttp::PauseState* _msg = _internal_mutable_pause_state();
  // @@protoc_insertion_point(field_mutable:telemetry.v1.RoundPaused.pause_state)
  return _msg;
}
inline void RoundPaused::set_allocated_pause_state(::enginehttp::PauseState* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.pause_state_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }

  _impl_.pause_state_ = reinterpret_cast<::enginehttp::PauseState*>(value);
  // @@protoc_insertion_point(field_set_allocated:telemetry.v1.RoundPaused.pause_state)
}

// -------------------------------------------------------------------

// RoundUnpaused

// .enginehttp.PauseState pause_state = 1 [json_name = "pauseState"];
inline bool RoundUnpaused::has_pause_state() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000001U);
  PROTOBUF_ASSUME(!value || _impl_.pause_state_ != nullptr);
  return value;
}
inline const ::enginehttp::PauseState& RoundUnpaused::_internal_pause_state() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::enginehttp::PauseState* p = _impl_.pause_state_;
  return p != nullptr ? *p : reinterpret_cast<const ::enginehttp::PauseState&>(::enginehttp::_PauseState_default_instance_);
}
inline const ::enginehttp::PauseState& RoundUnpaused::pause_state() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:telemetry.v1.RoundUnpaused.pause_state)
  return _internal_pause_state();
}
inline void RoundUnpaused::unsafe_arena_set_allocated_pause_state(
    ::enginehttp::PauseState* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.pause_state_);
  }
  _impl_.pause_state_ = reinterpret_cast<::enginehttp::PauseState*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:telemetry.v1.RoundUnpaused.pause_state)
}
inline ::enginehttp::PauseState* PROTOBUF_NULLABLE RoundUnpaused::release_pause_state() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::enginehttp::PauseState* released = _impl_.pause_state_;
  _impl_.pause_state_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::enginehttp::PauseState* PROTOBUF_NULLABLE RoundUnpaused::unsafe_arena_release_pause_state() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:telemetry.v1.RoundUnpaused.pause_state)

  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::enginehttp::PauseState* temp = _impl_.pause_state_;
  _impl_.pause_state_ = nullptr;
  return temp;
}
inline ::enginehttp::PauseState* PROTOBUF_NONNULL RoundUnpaused::_internal_mutable_pause_state() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.pause_state_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::enginehttp::PauseState>(GetArena());
    _impl_.pause_state_ = reinterpret_cast<::enginehttp::PauseState*>(p);
  }
  return _impl_.pause_state_;
}
inline ::enginehttp::PauseState* PROTOBUF_NONNULL RoundUnpaused::mutable_pause_state()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::enginehttp::PauseState* _msg = _internal_mutable_pause_state();
  // @@protoc_insertion_point(field_mutable:telemetry.v1.RoundUnpaused.pause_state)
  return _msg;
}
inline void RoundUnpaused::set_allocated_pause_state(::enginehttp::PauseState* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.pause_state_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }

  _impl_.pause_state_ = reinterpret_cast<::enginehttp::PauseState*>(value);
  // @@protoc_insertion_point(field_set_allocated:telemetry.v1.RoundUnpaused.pause_state)
}

// -------------------------------------------------------------------

// RoundEnded

// int32 round_number = 1 [json_name = "roundNumber"];
inline void RoundEnded::clear_round_number() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.round_number_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline ::int32_t RoundEnded::round_number() const {
  // @@protoc_insertion_point(field_get:telemetry.v1.RoundEnded.round_number)
  return _internal_round_number();
}
inline void RoundEnded::set_round_number(::int32_t value) {
  _internal_set_round_number(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_set:telemetry.v1.RoundEnded.round_number)
}
inline ::int32_t RoundEnded::_internal_round_number() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.round_number_;
}
inline void RoundEnded::_internal_set_round_number(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.round_number_ = value;
}

// .telemetry.v1.Role winning_team = 2 [json_name = "winningTeam"];
inline void RoundEnded::clear_winning_team() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.winning_team_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline ::telemetry::v1::Role RoundEnded::winning_team() const {
  // @@protoc_insertion_point(field_get:telemetry.v1.RoundEnded.winning_team)
  return _internal_winning_team();
}
inline void RoundEnded::set_winning_team(::telemetry::v1::Role value) {
  _internal_set_winning_team(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_set:telemetry.v1.RoundEnded.winning_team)
}
inline ::telemetry::v1::Role RoundEnded::_internal_winning_team() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::telemetry::v1::Role>(_impl_.winning_team_);
}
inline void RoundEnded::_internal_set_winning_team(::telemetry::v1::Role value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.winning_team_ = value;
}

// -------------------------------------------------------------------

// MatchEnded

// .telemetry.v1.Role winning_team = 1 [json_name = "winningTeam"];
inline void MatchEnded::clear_winning_team() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.winning_team_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline ::telemetry::v1::Role MatchEnded::winning_team() const {
  // @@protoc_insertion_point(field_get:telemetry.v1.MatchEnded.winning_team)
  return _internal_winning_team();
}
inline void MatchEnded::set_winning_team(::telemetry::v1::Role value) {
  _internal_set_winning_team(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_set:telemetry.v1.MatchEnded.winning_team)
}
inline ::telemetry::v1::Role MatchEnded::_internal_winning_team() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::telemetry::v1::Role>(_impl_.winning_team_);
}
inline void MatchEnded::_internal_set_winning_team(::telemetry::v1::Role value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.winning_team_ = value;
}

// -------------------------------------------------------------------

// ScoreboardUpdated

// int32 blue_points = 1 [json_name = "bluePoints"];
inline void ScoreboardUpdated::clear_blue_points() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.blue_points_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline ::int32_t ScoreboardUpdated::blue_points() const {
  // @@protoc_insertion_point(field_get:telemetry.v1.ScoreboardUpdated.blue_points)
  return _internal_blue_points();
}
inline void ScoreboardUpdated::set_blue_points(::int32_t value) {
  _internal_set_blue_points(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_set:telemetry.v1.ScoreboardUpdated.blue_points)
}
inline ::int32_t ScoreboardUpdated::_internal_blue_points() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.blue_points_;
}
inline void ScoreboardUpdated::_internal_set_blue_points(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.blue_points_ = value;
}

// int32 orange_points = 2 [json_name = "orangePoints"];
inline void ScoreboardUpdated::clear_orange_points() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.orange_points_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline ::int32_t ScoreboardUpdated::orange_points() const {
  // @@protoc_insertion_point(field_get:telemetry.v1.ScoreboardUpdated.orange_points)
  return _internal_orange_points();
}
inline void ScoreboardUpdated::set_orange_points(::int32_t value) {
  _internal_set_orange_points(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  // @@protoc_insertion_point(field_set:telemetry.v1.ScoreboardUpdated.orange_points)
}
inline ::int32_t ScoreboardUpdated::_internal_orange_points() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.orange_points_;
}
inline void ScoreboardUpdated::_internal_set_orange_points(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.orange_points_ = value;
}

// int32 blue_round_score = 3 [json_name = "blueRoundScore"];
inline void ScoreboardUpdated::clear_blue_round_score() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.blue_round_score_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000008U);
}
inline ::int32_t ScoreboardUpdated::blue_round_score() const {
  // @@protoc_insertion_point(field_get:telemetry.v1.ScoreboardUpdated.blue_round_score)
  return _internal_blue_round_score();
}
inline void ScoreboardUpdated::set_blue_round_score(::int32_t value) {
  _internal_set_blue_round_score(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000008U);
  // @@protoc_insertion_point(field_set:telemetry.v1.ScoreboardUpdated.blue_round_score)
}
inline ::int32_t ScoreboardUpdated::_internal_blue_round_score() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.blue_round_score_;
}
inline void ScoreboardUpdated::_internal_set_blue_round_score(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.blue_round_score_ = value;
}

// int32 orange_round_score = 4 [json_name = "orangeRoundScore"];
inline void ScoreboardUpdated::clear_orange_round_score() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.orange_round_score_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000010U);
}
inline ::int32_t ScoreboardUpdated::orange_round_score() const {
  // @@protoc_insertion_point(field_get:telemetry.v1.ScoreboardUpdated.orange_round_score)
  return _internal_orange_round_score();
}
inline void ScoreboardUpdated::set_orange_round_score(::int32_t value) {
  _internal_set_orange_round_score(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000010U);
  // @@protoc_insertion_point(field_set:telemetry.v1.ScoreboardUpdated.orange_round_score)
}
inline ::int32_t ScoreboardUpdated::_internal_orange_round_score() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.orange_round_score_;
}
inline void ScoreboardUpdated::_internal_set_orange_round_score(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.orange_round_score_ = value;
}

// string game_clock_display = 5 [json_name = "gameClockDisplay"];
inline void ScoreboardUpdated::clear_game_clock_display() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.game_clock_display_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::std::string& ScoreboardUpdated::game_clock_display() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:telemetry.v1.ScoreboardUpdated.game_clock_display)
  return _internal_game_clock_display();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void ScoreboardUpdated::set_game_clock_display(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  _impl_.game_clock_display_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:telemetry.v1.ScoreboardUpdated.game_clock_display)
}
inline ::std::string* PROTOBUF_NONNULL ScoreboardUpdated::mutable_game_clock_display()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::std::string* _s = _internal_mutable_game_clock_display();
  // @@protoc_insertion_point(field_mutable:telemetry.v1.ScoreboardUpdated.game_clock_display)
  return _s;
}
inline const ::std::string& ScoreboardUpdated::_internal_game_clock_display() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.game_clock_display_.Get();
}
inline void ScoreboardUpdated::_internal_set_game_clock_display(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.game_clock_display_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL ScoreboardUpdated::_internal_mutable_game_clock_display() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.game_clock_display_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE ScoreboardUpdated::release_game_clock_display() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:telemetry.v1.ScoreboardUpdated.game_clock_display)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000001U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  auto* released = _impl_.game_clock_display_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.game_clock_display_.Set("", GetArena());
  }
  return released;
}
inline void ScoreboardUpdated::set_allocated_game_clock_display(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  _impl_.game_clock_display_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.game_clock_display_.IsDefault()) {
    _impl_.game_clock_display_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:telemetry.v1.ScoreboardUpdated.game_clock_display)
}

// -------------------------------------------------------------------

// PlayerJoined

// .enginehttp.TeamMember player = 1 [json_name = "player"];
inline bool PlayerJoined::has_player() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000001U);
  PROTOBUF_ASSUME(!value || _impl_.player_ != nullptr);
  return value;
}
inline const ::enginehttp::TeamMember& PlayerJoined::_internal_player() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::enginehttp::TeamMember* p = _impl_.player_;
  return p != nullptr ? *p : reinterpret_cast<const ::enginehttp::TeamMember&>(::enginehttp::_TeamMember_default_instance_);
}
inline const ::enginehttp::TeamMember& PlayerJoined::player() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:telemetry.v1.PlayerJoined.player)
  return _internal_player();
}
inline void PlayerJoined::unsafe_arena_set_allocated_player(
    ::enginehttp::TeamMember* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.player_);
  }
  _impl_.player_ = reinterpret_cast<::enginehttp::TeamMember*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:telemetry.v1.PlayerJoined.player)
}
inline ::enginehttp::TeamMember* PROTOBUF_NULLABLE PlayerJoined::release_player() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::enginehttp::TeamMember* released = _impl_.player_;
  _impl_.player_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::enginehttp::TeamMember* PROTOBUF_NULLABLE PlayerJoined::unsafe_arena_release_player() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:telemetry.v1.PlayerJoined.player)

  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::enginehttp::TeamMember* temp = _impl_.player_;
  _impl_.player_ = nullptr;
  return temp;
}
inline ::enginehttp::TeamMember* PROTOBUF_NONNULL PlayerJoined::_internal_mutable_player() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.player_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::enginehttp::TeamMember>(GetArena());
    _impl_.player_ = reinterpret_cast<::enginehttp::TeamMember*>(p);
  }
  return _impl_.player_;
}
inline ::enginehttp::TeamMember* PROTOBUF_NONNULL PlayerJoined::mutable_player()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::enginehttp::TeamMember* _msg = _internal_mutable_player();
  // @@protoc_insertion_point(field_mutable:telemetry.v1.PlayerJoined.player)
  return _msg;
}
inline void PlayerJoined::set_allocated_player(::enginehttp::TeamMember* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.player_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }

  _impl_.player_ = reinterpret_cast<::enginehttp::TeamMember*>(value);
  // @@protoc_insertion_point(field_set_allocated:telemetry.v1.PlayerJoined.player)
}

// .telemetry.v1.Role role = 2 [json_name = "role"];
inline void PlayerJoined::clear_role() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.role_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline ::telemetry::v1::Role PlayerJoined::role() const {
  // @@protoc_insertion_point(field_get:telemetry.v1.PlayerJoined.role)
  return _internal_role();
}
inline void PlayerJoined::set_role(::telemetry::v1::Role value) {
  _internal_set_role(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_set:telemetry.v1.PlayerJoined.role)
}
inline ::telemetry::v1::Role PlayerJoined::_internal_role() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::telemetry::v1::Role>(_impl_.role_);
}
inline void PlayerJoined::_internal_set_role(::telemetry::v1::Role value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.role_ = value;
}

// -------------------------------------------------------------------

// PlayerLeft

// int32 player_slot = 1 [json_name = "playerSlot"];
inline void PlayerLeft::clear_player_slot() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.player_slot_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline ::int32_t PlayerLeft::player_slot() const {
  // @@protoc_insertion_point(field_get:telemetry.v1.PlayerLeft.player_slot)
  return _internal_player_slot();
}
inline void PlayerLeft::set_player_slot(::int32_t value) {
  _internal_set_player_slot(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_set:telemetry.v1.PlayerLeft.player_slot)
}
inline ::int32_t PlayerLeft::_internal_player_slot() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.player_slot_;
}
inline void PlayerLeft::_internal_set_player_slot(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.player_slot_ = value;
}

// string display_name = 2 [json_name = "displayName"];
inline void PlayerLeft::clear_display_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.display_name_.ClearToEmpty();
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline const ::std::string& PlayerLeft::display_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:telemetry.v1.PlayerLeft.display_name)
  return _internal_display_name();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void PlayerLeft::set_display_name(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  _impl_.display_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:telemetry.v1.PlayerLeft.display_name)
}
inline ::std::string* PROTOBUF_NONNULL PlayerLeft::mutable_display_name()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::std::string* _s = _internal_mutable_display_name();
  // @@protoc_insertion_point(field_mutable:telemetry.v1.PlayerLeft.display_name)
  return _s;
}
inline const ::std::string& PlayerLeft::_internal_display_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.display_name_.Get();
}
inline void PlayerLeft::_internal_set_display_name(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.display_name_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL PlayerLeft::_internal_mutable_display_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.display_name_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE PlayerLeft::release_display_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:telemetry.v1.PlayerLeft.display_name)
  if (!CheckHasBit(_impl_._has_bits_[0], 0x00000001U)) {
    return nullptr;
  }
  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  auto* released = _impl_.display_name_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.display_name_.Set("", GetArena());
  }
  return released;
}
inline void PlayerLeft::set_allocated_display_name(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  _impl_.display_name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.display_name_.IsDefault()) {
    _impl_.display_name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:telemetry.v1.PlayerLeft.display_name)
}

// -------------------------------------------------------------------

// PlayerSwitchedTeam

// int32 player_slot = 1 [json_name = "playerSlot"];
inline void PlayerSwitchedTeam::clear_player_slot() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.player_slot_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline ::int32_t PlayerSwitchedTeam::player_slot() const {
  // @@protoc_insertion_point(field_get:telemetry.v1.PlayerSwitchedTeam.player_slot)
  return _internal_player_slot();
}
inline void PlayerSwitchedTeam::set_player_slot(::int32_t value) {
  _internal_set_player_slot(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_set:telemetry.v1.PlayerSwitchedTeam.player_slot)
}
inline ::int32_t PlayerSwitchedTeam::_internal_player_slot() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.player_slot_;
}
inline void PlayerSwitchedTeam::_internal_set_player_slot(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.player_slot_ = value;
}

// .telemetry.v1.Role new_role = 2 [json_name = "newRole"];
inline void PlayerSwitchedTeam::clear_new_role() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.new_role_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline ::telemetry::v1::Role PlayerSwitchedTeam::new_role() const {
  // @@protoc_insertion_point(field_get:telemetry.v1.PlayerSwitchedTeam.new_role)
  return _internal_new_role();
}
inline void PlayerSwitchedTeam::set_new_role(::telemetry::v1::Role value) {
  _internal_set_new_role(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_set:telemetry.v1.PlayerSwitchedTeam.new_role)
}
inline ::telemetry::v1::Role PlayerSwitchedTeam::_internal_new_role() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::telemetry::v1::Role>(_impl_.new_role_);
}
inline void PlayerSwitchedTeam::_internal_set_new_role(::telemetry::v1::Role value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.new_role_ = value;
}

// .telemetry.v1.Role prev_role = 3 [json_name = "prevRole"];
inline void PlayerSwitchedTeam::clear_prev_role() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.prev_role_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline ::telemetry::v1::Role PlayerSwitchedTeam::prev_role() const {
  // @@protoc_insertion_point(field_get:telemetry.v1.PlayerSwitchedTeam.prev_role)
  return _internal_prev_role();
}
inline void PlayerSwitchedTeam::set_prev_role(::telemetry::v1::Role value) {
  _internal_set_prev_role(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  // @@protoc_insertion_point(field_set:telemetry.v1.PlayerSwitchedTeam.prev_role)
}
inline ::telemetry::v1::Role PlayerSwitchedTeam::_internal_prev_role() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::telemetry::v1::Role>(_impl_.prev_role_);
}
inline void PlayerSwitchedTeam::_internal_set_prev_role(::telemetry::v1::Role value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.prev_role_ = value;
}

// -------------------------------------------------------------------

// EmotePlayed

// int32 player_slot = 1 [json_name = "playerSlot"];
inline void EmotePlayed::clear_player_slot() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.player_slot_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline ::int32_t EmotePlayed::player_slot() const {
  // @@protoc_insertion_point(field_get:telemetry.v1.EmotePlayed.player_slot)
  return _internal_player_slot();
}
inline void EmotePlayed::set_player_slot(::int32_t value) {
  _internal_set_player_slot(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_set:telemetry.v1.EmotePlayed.player_slot)
}
inline ::int32_t EmotePlayed::_internal_player_slot() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.player_slot_;
}
inline void EmotePlayed::_internal_set_player_slot(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.player_slot_ = value;
}

// .telemetry.v1.EmotePlayed.EmoteType emote = 2 [json_name = "emote"];
inline void EmotePlayed::clear_emote() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.emote_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline ::telemetry::v1::EmotePlayed_EmoteType EmotePlayed::emote() const {
  // @@protoc_insertion_point(field_get:telemetry.v1.EmotePlayed.emote)
  return _internal_emote();
}
inline void EmotePlayed::set_emote(::telemetry::v1::EmotePlayed_EmoteType value) {
  _internal_set_emote(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_set:telemetry.v1.EmotePlayed.emote)
}
inline ::telemetry::v1::EmotePlayed_EmoteType EmotePlayed::_internal_emote() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::telemetry::v1::EmotePlayed_EmoteType>(_impl_.emote_);
}
inline void EmotePlayed::_internal_set_emote(::telemetry::v1::EmotePlayed_EmoteType value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.emote_ = value;
}

// -------------------------------------------------------------------

// DiscPossessionChanged

// int32 player_slot = 1 [json_name = "playerSlot"];
inline void DiscPossessionChanged::clear_player_slot() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.player_slot_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline ::int32_t DiscPossessionChanged::player_slot() const {
  // @@protoc_insertion_point(field_get:telemetry.v1.DiscPossessionChanged.player_slot)
  return _internal_player_slot();
}
inline void DiscPossessionChanged::set_player_slot(::int32_t value) {
  _internal_set_player_slot(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_set:telemetry.v1.DiscPossessionChanged.player_slot)
}
inline ::int32_t DiscPossessionChanged::_internal_player_slot() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.player_slot_;
}
inline void DiscPossessionChanged::_internal_set_player_slot(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.player_slot_ = value;
}

// int32 previous_player_slot = 2 [json_name = "previousPlayerSlot"];
inline void DiscPossessionChanged::clear_previous_player_slot() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.previous_player_slot_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline ::int32_t DiscPossessionChanged::previous_player_slot() const {
  // @@protoc_insertion_point(field_get:telemetry.v1.DiscPossessionChanged.previous_player_slot)
  return _internal_previous_player_slot();
}
inline void DiscPossessionChanged::set_previous_player_slot(::int32_t value) {
  _internal_set_previous_player_slot(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_set:telemetry.v1.DiscPossessionChanged.previous_player_slot)
}
inline ::int32_t DiscPossessionChanged::_internal_previous_player_slot() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.previous_player_slot_;
}
inline void DiscPossessionChanged::_internal_set_previous_player_slot(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.previous_player_slot_ = value;
}

// -------------------------------------------------------------------

// DiscThrown

// int32 player_slot = 1 [json_name = "playerSlot"];
inline void DiscThrown::clear_player_slot() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.player_slot_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline ::int32_t DiscThrown::player_slot() const {
  // @@protoc_insertion_point(field_get:telemetry.v1.DiscThrown.player_slot)
  return _internal_player_slot();
}
inline void DiscThrown::set_player_slot(::int32_t value) {
  _internal_set_player_slot(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_set:telemetry.v1.DiscThrown.player_slot)
}
inline ::int32_t DiscThrown::_internal_player_slot() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.player_slot_;
}
inline void DiscThrown::_internal_set_player_slot(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.player_slot_ = value;
}

// .enginehttp.LastThrowInfo throw_details = 2 [json_name = "throwDetails"];
inline bool DiscThrown::has_throw_details() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000001U);
  PROTOBUF_ASSUME(!value || _impl_.throw_details_ != nullptr);
  return value;
}
inline const ::enginehttp::LastThrowInfo& DiscThrown::_internal_throw_details() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::enginehttp::LastThrowInfo* p = _impl_.throw_details_;
  return p != nullptr ? *p : reinterpret_cast<const ::enginehttp::LastThrowInfo&>(::enginehttp::_LastThrowInfo_default_instance_);
}
inline const ::enginehttp::LastThrowInfo& DiscThrown::throw_details() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:telemetry.v1.DiscThrown.throw_details)
  return _internal_throw_details();
}
inline void DiscThrown::unsafe_arena_set_allocated_throw_details(
    ::enginehttp::LastThrowInfo* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.throw_details_);
  }
  _impl_.throw_details_ = reinterpret_cast<::enginehttp::LastThrowInfo*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:telemetry.v1.DiscThrown.throw_details)
}
inline ::enginehttp::LastThrowInfo* PROTOBUF_NULLABLE DiscThrown::release_throw_details() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::enginehttp::LastThrowInfo* released = _impl_.throw_details_;
  _impl_.throw_details_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::enginehttp::LastThrowInfo* PROTOBUF_NULLABLE DiscThrown::unsafe_arena_release_throw_details() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:telemetry.v1.DiscThrown.throw_details)

  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::enginehttp::LastThrowInfo* temp = _impl_.throw_details_;
  _impl_.throw_details_ = nullptr;
  return temp;
}
inline ::enginehttp::LastThrowInfo* PROTOBUF_NONNULL DiscThrown::_internal_mutable_throw_details() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.throw_details_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::enginehttp::LastThrowInfo>(GetArena());
    _impl_.throw_details_ = reinterpret_cast<::enginehttp::LastThrowInfo*>(p);
  }
  return _impl_.throw_details_;
}
inline ::enginehttp::LastThrowInfo* PROTOBUF_NONNULL DiscThrown::mutable_throw_details()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::enginehttp::LastThrowInfo* _msg = _internal_mutable_throw_details();
  // @@protoc_insertion_point(field_mutable:telemetry.v1.DiscThrown.throw_details)
  return _msg;
}
inline void DiscThrown::set_allocated_throw_details(::enginehttp::LastThrowInfo* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.throw_details_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }

  _impl_.throw_details_ = reinterpret_cast<::enginehttp::LastThrowInfo*>(value);
  // @@protoc_insertion_point(field_set_allocated:telemetry.v1.DiscThrown.throw_details)
}

// -------------------------------------------------------------------

// DiscCaught

// int32 player_slot = 1 [json_name = "playerSlot"];
inline void DiscCaught::clear_player_slot() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.player_slot_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline ::int32_t DiscCaught::player_slot() const {
  // @@protoc_insertion_point(field_get:telemetry.v1.DiscCaught.player_slot)
  return _internal_player_slot();
}
inline void DiscCaught::set_player_slot(::int32_t value) {
  _internal_set_player_slot(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_set:telemetry.v1.DiscCaught.player_slot)
}
inline ::int32_t DiscCaught::_internal_player_slot() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.player_slot_;
}
inline void DiscCaught::_internal_set_player_slot(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.player_slot_ = value;
}

// -------------------------------------------------------------------

// GoalScored

// .enginehttp.LastScore score_details = 1 [json_name = "scoreDetails"];
inline bool GoalScored::has_score_details() const {
  bool value = CheckHasBit(_impl_._has_bits_[0], 0x00000001U);
  PROTOBUF_ASSUME(!value || _impl_.score_details_ != nullptr);
  return value;
}
inline const ::enginehttp::LastScore& GoalScored::_internal_score_details() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::enginehttp::LastScore* p = _impl_.score_details_;
  return p != nullptr ? *p : reinterpret_cast<const ::enginehttp::LastScore&>(::enginehttp::_LastScore_default_instance_);
}
inline const ::enginehttp::LastScore& GoalScored::score_details() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:telemetry.v1.GoalScored.score_details)
  return _internal_score_details();
}
inline void GoalScored::unsafe_arena_set_allocated_score_details(
    ::enginehttp::LastScore* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.score_details_);
  }
  _impl_.score_details_ = reinterpret_cast<::enginehttp::LastScore*>(value);
  if (value != nullptr) {
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:telemetry.v1.GoalScored.score_details)
}
inline ::enginehttp::LastScore* PROTOBUF_NULLABLE GoalScored::release_score_details() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::enginehttp::LastScore* released = _impl_.score_details_;
  _impl_.score_details_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::enginehttp::LastScore* PROTOBUF_NULLABLE GoalScored::unsafe_arena_release_score_details() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:telemetry.v1.GoalScored.score_details)

  ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::enginehttp::LastScore* temp = _impl_.score_details_;
  _impl_.score_details_ = nullptr;
  return temp;
}
inline ::enginehttp::LastScore* PROTOBUF_NONNULL GoalScored::_internal_mutable_score_details() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.score_details_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::enginehttp::LastScore>(GetArena());
    _impl_.score_details_ = reinterpret_cast<::enginehttp::LastScore*>(p);
  }
  return _impl_.score_details_;
}
inline ::enginehttp::LastScore* PROTOBUF_NONNULL GoalScored::mutable_score_details()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  ::enginehttp::LastScore* _msg = _internal_mutable_score_details();
  // @@protoc_insertion_point(field_mutable:telemetry.v1.GoalScored.score_details)
  return _msg;
}
inline void GoalScored::set_allocated_score_details(::enginehttp::LastScore* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.score_details_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::Message*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  } else {
    ClearHasBit(_impl_._has_bits_[0], 0x00000001U);
  }

  _impl_.score_details_ = reinterpret_cast<::enginehttp::LastScore*>(value);
  // @@protoc_insertion_point(field_set_allocated:telemetry.v1.GoalScored.score_details)
}

// -------------------------------------------------------------------

// PlayerGoal

// int32 player_slot = 1 [json_name = "playerSlot"];
inline void PlayerGoal::clear_player_slot() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.player_slot_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline ::int32_t PlayerGoal::player_slot() const {
  // @@protoc_insertion_point(field_get:telemetry.v1.PlayerGoal.player_slot)
  return _internal_player_slot();
}
inline void PlayerGoal::set_player_slot(::int32_t value) {
  _internal_set_player_slot(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_set:telemetry.v1.PlayerGoal.player_slot)
}
inline ::int32_t PlayerGoal::_internal_player_slot() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.player_slot_;
}
inline void PlayerGoal::_internal_set_player_slot(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.player_slot_ = value;
}

// int32 total_goals = 2 [json_name = "totalGoals"];
inline void PlayerGoal::clear_total_goals() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.total_goals_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline ::int32_t PlayerGoal::total_goals() const {
  // @@protoc_insertion_point(field_get:telemetry.v1.PlayerGoal.total_goals)
  return _internal_total_goals();
}
inline void PlayerGoal::set_total_goals(::int32_t value) {
  _internal_set_total_goals(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_set:telemetry.v1.PlayerGoal.total_goals)
}
inline ::int32_t PlayerGoal::_internal_total_goals() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.total_goals_;
}
inline void PlayerGoal::_internal_set_total_goals(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.total_goals_ = value;
}

// int32 points = 3 [json_name = "points"];
inline void PlayerGoal::clear_points() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.points_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000004U);
}
inline ::int32_t PlayerGoal::points() const {
  // @@protoc_insertion_point(field_get:telemetry.v1.PlayerGoal.points)
  return _internal_points();
}
inline void PlayerGoal::set_points(::int32_t value) {
  _internal_set_points(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000004U);
  // @@protoc_insertion_point(field_set:telemetry.v1.PlayerGoal.points)
}
inline ::int32_t PlayerGoal::_internal_points() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.points_;
}
inline void PlayerGoal::_internal_set_points(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.points_ = value;
}

// -------------------------------------------------------------------

// PlayerSave

// int32 player_slot = 1 [json_name = "playerSlot"];
inline void PlayerSave::clear_player_slot() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.player_slot_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline ::int32_t PlayerSave::player_slot() const {
  // @@protoc_insertion_point(field_get:telemetry.v1.PlayerSave.player_slot)
  return _internal_player_slot();
}
inline void PlayerSave::set_player_slot(::int32_t value) {
  _internal_set_player_slot(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_set:telemetry.v1.PlayerSave.player_slot)
}
inline ::int32_t PlayerSave::_internal_player_slot() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.player_slot_;
}
inline void PlayerSave::_internal_set_player_slot(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.player_slot_ = value;
}

// int32 total_saves = 2 [json_name = "totalSaves"];
inline void PlayerSave::clear_total_saves() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.total_saves_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline ::int32_t PlayerSave::total_saves() const {
  // @@protoc_insertion_point(field_get:telemetry.v1.PlayerSave.total_saves)
  return _internal_total_saves();
}
inline void PlayerSave::set_total_saves(::int32_t value) {
  _internal_set_total_saves(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_set:telemetry.v1.PlayerSave.total_saves)
}
inline ::int32_t PlayerSave::_internal_total_saves() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.total_saves_;
}
inline void PlayerSave::_internal_set_total_saves(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.total_saves_ = value;
}

// -------------------------------------------------------------------

// PlayerStun

// int32 player_slot = 1 [json_name = "playerSlot"];
inline void PlayerStun::clear_player_slot() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.player_slot_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline ::int32_t PlayerStun::player_slot() const {
  // @@protoc_insertion_point(field_get:telemetry.v1.PlayerStun.player_slot)
  return _internal_player_slot();
}
inline void PlayerStun::set_player_slot(::int32_t value) {
  _internal_set_player_slot(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_set:telemetry.v1.PlayerStun.player_slot)
}
inline ::int32_t PlayerStun::_internal_player_slot() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.player_slot_;
}
inline void PlayerStun::_internal_set_player_slot(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.player_slot_ = value;
}

// int32 total_stuns = 2 [json_name = "totalStuns"];
inline void PlayerStun::clear_total_stuns() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.total_stuns_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline ::int32_t PlayerStun::total_stuns() const {
  // @@protoc_insertion_point(field_get:telemetry.v1.PlayerStun.total_stuns)
  return _internal_total_stuns();
}
inline void PlayerStun::set_total_stuns(::int32_t value) {
  _internal_set_total_stuns(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_set:telemetry.v1.PlayerStun.total_stuns)
}
inline ::int32_t PlayerStun::_internal_total_stuns() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.total_stuns_;
}
inline void PlayerStun::_internal_set_total_stuns(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.total_stuns_ = value;
}

// -------------------------------------------------------------------

// PlayerPass

// int32 player_slot = 1 [json_name = "playerSlot"];
inline void PlayerPass::clear_player_slot() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.player_slot_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline ::int32_t PlayerPass::player_slot() const {
  // @@protoc_insertion_point(field_get:telemetry.v1.PlayerPass.player_slot)
  return _internal_player_slot();
}
inline void PlayerPass::set_player_slot(::int32_t value) {
  _internal_set_player_slot(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_set:telemetry.v1.PlayerPass.player_slot)
}
inline ::int32_t PlayerPass::_internal_player_slot() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.player_slot_;
}
inline void PlayerPass::_internal_set_player_slot(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.player_slot_ = value;
}

// int32 total_passes = 2 [json_name = "totalPasses"];
inline void PlayerPass::clear_total_passes() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.total_passes_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline ::int32_t PlayerPass::total_passes() const {
  // @@protoc_insertion_point(field_get:telemetry.v1.PlayerPass.total_passes)
  return _internal_total_passes();
}
inline void PlayerPass::set_total_passes(::int32_t value) {
  _internal_set_total_passes(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_set:telemetry.v1.PlayerPass.total_passes)
}
inline ::int32_t PlayerPass::_internal_total_passes() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.total_passes_;
}
inline void PlayerPass::_internal_set_total_passes(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.total_passes_ = value;
}

// -------------------------------------------------------------------

// PlayerSteal

// int32 player_slot = 1 [json_name = "playerSlot"];
inline void PlayerSteal::clear_player_slot() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.player_slot_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline ::int32_t PlayerSteal::player_slot() const {
  // @@protoc_insertion_point(field_get:telemetry.v1.PlayerSteal.player_slot)
  return _internal_player_slot();
}
inline void PlayerSteal::set_player_slot(::int32_t value) {
  _internal_set_player_slot(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_set:telemetry.v1.PlayerSteal.player_slot)
}
inline ::int32_t PlayerSteal::_internal_player_slot() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.player_slot_;
}
inline void PlayerSteal::_internal_set_player_slot(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.player_slot_ = value;
}

// int32 total_steals = 2 [json_name = "totalSteals"];
inline void PlayerSteal::clear_total_steals() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.total_steals_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline ::int32_t PlayerSteal::total_steals() const {
  // @@protoc_insertion_point(field_get:telemetry.v1.PlayerSteal.total_steals)
  return _internal_total_steals();
}
inline void PlayerSteal::set_total_steals(::int32_t value) {
  _internal_set_total_steals(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_set:telemetry.v1.PlayerSteal.total_steals)
}
inline ::int32_t PlayerSteal::_internal_total_steals() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.total_steals_;
}
inline void PlayerSteal::_internal_set_total_steals(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.total_steals_ = value;
}

// -------------------------------------------------------------------

// PlayerBlock

// int32 player_slot = 1 [json_name = "playerSlot"];
inline void PlayerBlock::clear_player_slot() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.player_slot_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline ::int32_t PlayerBlock::player_slot() const {
  // @@protoc_insertion_point(field_get:telemetry.v1.PlayerBlock.player_slot)
  return _internal_player_slot();
}
inline void PlayerBlock::set_player_slot(::int32_t value) {
  _internal_set_player_slot(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_set:telemetry.v1.PlayerBlock.player_slot)
}
inline ::int32_t PlayerBlock::_internal_player_slot() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.player_slot_;
}
inline void PlayerBlock::_internal_set_player_slot(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.player_slot_ = value;
}

// int32 total_blocks = 2 [json_name = "totalBlocks"];
inline void PlayerBlock::clear_total_blocks() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.total_blocks_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline ::int32_t PlayerBlock::total_blocks() const {
  // @@protoc_insertion_point(field_get:telemetry.v1.PlayerBlock.total_blocks)
  return _internal_total_blocks();
}
inline void PlayerBlock::set_total_blocks(::int32_t value) {
  _internal_set_total_blocks(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_set:telemetry.v1.PlayerBlock.total_blocks)
}
inline ::int32_t PlayerBlock::_internal_total_blocks() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.total_blocks_;
}
inline void PlayerBlock::_internal_set_total_blocks(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.total_blocks_ = value;
}

// -------------------------------------------------------------------

// PlayerInterception

// int32 player_slot = 1 [json_name = "playerSlot"];
inline void PlayerInterception::clear_player_slot() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.player_slot_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline ::int32_t PlayerInterception::player_slot() const {
  // @@protoc_insertion_point(field_get:telemetry.v1.PlayerInterception.player_slot)
  return _internal_player_slot();
}
inline void PlayerInterception::set_player_slot(::int32_t value) {
  _internal_set_player_slot(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_set:telemetry.v1.PlayerInterception.player_slot)
}
inline ::int32_t PlayerInterception::_internal_player_slot() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.player_slot_;
}
inline void PlayerInterception::_internal_set_player_slot(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.player_slot_ = value;
}

// int32 total_interceptions = 2 [json_name = "totalInterceptions"];
inline void PlayerInterception::clear_total_interceptions() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.total_interceptions_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline ::int32_t PlayerInterception::total_interceptions() const {
  // @@protoc_insertion_point(field_get:telemetry.v1.PlayerInterception.total_interceptions)
  return _internal_total_interceptions();
}
inline void PlayerInterception::set_total_interceptions(::int32_t value) {
  _internal_set_total_interceptions(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_set:telemetry.v1.PlayerInterception.total_interceptions)
}
inline ::int32_t PlayerInterception::_internal_total_interceptions() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.total_interceptions_;
}
inline void PlayerInterception::_internal_set_total_interceptions(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.total_interceptions_ = value;
}

// -------------------------------------------------------------------

// PlayerAssist

// int32 player_slot = 1 [json_name = "playerSlot"];
inline void PlayerAssist::clear_player_slot() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.player_slot_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline ::int32_t PlayerAssist::player_slot() const {
  // @@protoc_insertion_point(field_get:telemetry.v1.PlayerAssist.player_slot)
  return _internal_player_slot();
}
inline void PlayerAssist::set_player_slot(::int32_t value) {
  _internal_set_player_slot(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_set:telemetry.v1.PlayerAssist.player_slot)
}
inline ::int32_t PlayerAssist::_internal_player_slot() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.player_slot_;
}
inline void PlayerAssist::_internal_set_player_slot(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.player_slot_ = value;
}

// int32 total_assists = 2 [json_name = "totalAssists"];
inline void PlayerAssist::clear_total_assists() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.total_assists_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline ::int32_t PlayerAssist::total_assists() const {
  // @@protoc_insertion_point(field_get:telemetry.v1.PlayerAssist.total_assists)
  return _internal_total_assists();
}
inline void PlayerAssist::set_total_assists(::int32_t value) {
  _internal_set_total_assists(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_set:telemetry.v1.PlayerAssist.total_assists)
}
inline ::int32_t PlayerAssist::_internal_total_assists() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.total_assists_;
}
inline void PlayerAssist::_internal_set_total_assists(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.total_assists_ = value;
}

// -------------------------------------------------------------------

// PlayerShotTaken

// int32 player_slot = 1 [json_name = "playerSlot"];
inline void PlayerShotTaken::clear_player_slot() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.player_slot_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000001U);
}
inline ::int32_t PlayerShotTaken::player_slot() const {
  // @@protoc_insertion_point(field_get:telemetry.v1.PlayerShotTaken.player_slot)
  return _internal_player_slot();
}
inline void PlayerShotTaken::set_player_slot(::int32_t value) {
  _internal_set_player_slot(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000001U);
  // @@protoc_insertion_point(field_set:telemetry.v1.PlayerShotTaken.player_slot)
}
inline ::int32_t PlayerShotTaken::_internal_player_slot() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.player_slot_;
}
inline void PlayerShotTaken::_internal_set_player_slot(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.player_slot_ = value;
}

// int32 total_shots = 2 [json_name = "totalShots"];
inline void PlayerShotTaken::clear_total_shots() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.total_shots_ = 0;
  ClearHasBit(_impl_._has_bits_[0],
                  0x00000002U);
}
inline ::int32_t PlayerShotTaken::total_shots() const {
  // @@protoc_insertion_point(field_get:telemetry.v1.PlayerShotTaken.total_shots)
  return _internal_total_shots();
}
inline void PlayerShotTaken::set_total_shots(::int32_t value) {
  _internal_set_total_shots(value);
  SetHasBit(_impl_._has_bits_[0], 0x00000002U);
  // @@protoc_insertion_point(field_set:telemetry.v1.PlayerShotTaken.total_shots)
}
inline ::int32_t PlayerShotTaken::_internal_total_shots() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.total_shots_;
}
inline void PlayerShotTaken::_internal_set_total_shots(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.total_shots_ = value;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace v1
}  // namespace telemetry


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::telemetry::v1::EmotePlayed_EmoteType> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::telemetry::v1::EmotePlayed_EmoteType>() {
  return ::telemetry::v1::EmotePlayed_EmoteType_descriptor();
}
template <>
struct is_proto_enum<::telemetry::v1::Role> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::telemetry::v1::Role>() {
  return ::telemetry::v1::Role_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // telemetry_2fv1_2ftelemetry_2eproto_2epb_2eh
