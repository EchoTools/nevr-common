// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: telemetry/v2/frame.proto

#include "telemetry/v2/frame.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace telemetry {
namespace v2 {
PROTOBUF_CONSTEXPR CaptureHeader_MetadataEntry_DoNotUse::CaptureHeader_MetadataEntry_DoNotUse(
    ::_pbi::ConstantInitialized) {}
struct CaptureHeader_MetadataEntry_DoNotUseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CaptureHeader_MetadataEntry_DoNotUseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CaptureHeader_MetadataEntry_DoNotUseDefaultTypeInternal() {}
  union {
    CaptureHeader_MetadataEntry_DoNotUse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CaptureHeader_MetadataEntry_DoNotUseDefaultTypeInternal _CaptureHeader_MetadataEntry_DoNotUse_default_instance_;
PROTOBUF_CONSTEXPR CaptureHeader::CaptureHeader(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.initial_roster_)*/{}
  , /*decltype(_impl_.metadata_)*/{::_pbi::ConstantInitialized()}
  , /*decltype(_impl_.capture_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.session_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.map_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.client_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.created_at_)*/nullptr
  , /*decltype(_impl_.match_type_)*/0
  , /*decltype(_impl_.private_match_)*/false
  , /*decltype(_impl_.tournament_match_)*/false
  , /*decltype(_impl_.total_round_count_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CaptureHeaderDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CaptureHeaderDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CaptureHeaderDefaultTypeInternal() {}
  union {
    CaptureHeader _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CaptureHeaderDefaultTypeInternal _CaptureHeader_default_instance_;
PROTOBUF_CONSTEXPR PlayerInfo::PlayerInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.display_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.account_number_)*/uint64_t{0u}
  , /*decltype(_impl_.slot_)*/0
  , /*decltype(_impl_.role_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct PlayerInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PlayerInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PlayerInfoDefaultTypeInternal() {}
  union {
    PlayerInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PlayerInfoDefaultTypeInternal _PlayerInfo_default_instance_;
PROTOBUF_CONSTEXPR DiscState::DiscState(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.pose_)*/nullptr
  , /*decltype(_impl_.velocity_)*/nullptr
  , /*decltype(_impl_.bounce_count_)*/0u
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct DiscStateDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DiscStateDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DiscStateDefaultTypeInternal() {}
  union {
    DiscState _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DiscStateDefaultTypeInternal _DiscState_default_instance_;
PROTOBUF_CONSTEXPR PlayerState::PlayerState(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.head_)*/nullptr
  , /*decltype(_impl_.body_)*/nullptr
  , /*decltype(_impl_.left_hand_)*/nullptr
  , /*decltype(_impl_.right_hand_)*/nullptr
  , /*decltype(_impl_.velocity_)*/nullptr
  , /*decltype(_impl_.slot_)*/0
  , /*decltype(_impl_.flags_)*/0u
  , /*decltype(_impl_.ping_)*/0u
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct PlayerStateDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PlayerStateDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PlayerStateDefaultTypeInternal() {}
  union {
    PlayerState _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PlayerStateDefaultTypeInternal _PlayerState_default_instance_;
PROTOBUF_CONSTEXPR PlayerBones::PlayerBones(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.transforms_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.orientations_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.slot_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct PlayerBonesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PlayerBonesDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PlayerBonesDefaultTypeInternal() {}
  union {
    PlayerBones _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PlayerBonesDefaultTypeInternal _PlayerBones_default_instance_;
PROTOBUF_CONSTEXPR Frame::Frame(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.players_)*/{}
  , /*decltype(_impl_.player_bones_)*/{}
  , /*decltype(_impl_.events_)*/{}
  , /*decltype(_impl_.disc_)*/nullptr
  , /*decltype(_impl_.vr_root_)*/nullptr
  , /*decltype(_impl_.frame_index_)*/0u
  , /*decltype(_impl_.timestamp_offset_ms_)*/0u
  , /*decltype(_impl_.game_status_)*/0
  , /*decltype(_impl_.game_clock_)*/0
  , /*decltype(_impl_.disc_holder_slot_)*/0
  , /*decltype(_impl_.blue_points_)*/0
  , /*decltype(_impl_.orange_points_)*/0
  , /*decltype(_impl_.round_number_)*/0
  , /*decltype(_impl_.pause_state_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct FrameDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FrameDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~FrameDefaultTypeInternal() {}
  union {
    Frame _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FrameDefaultTypeInternal _Frame_default_instance_;
PROTOBUF_CONSTEXPR EnvelopeV2::EnvelopeV2(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.message_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct EnvelopeV2DefaultTypeInternal {
  PROTOBUF_CONSTEXPR EnvelopeV2DefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~EnvelopeV2DefaultTypeInternal() {}
  union {
    EnvelopeV2 _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 EnvelopeV2DefaultTypeInternal _EnvelopeV2_default_instance_;
}  // namespace v2
}  // namespace telemetry
static ::_pb::Metadata file_level_metadata_telemetry_2fv2_2fframe_2eproto[8];
static const ::_pb::EnumDescriptor* file_level_enum_descriptors_telemetry_2fv2_2fframe_2eproto[4];
static constexpr ::_pb::ServiceDescriptor const** file_level_service_descriptors_telemetry_2fv2_2fframe_2eproto = nullptr;

const uint32_t TableStruct_telemetry_2fv2_2fframe_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  PROTOBUF_FIELD_OFFSET(::telemetry::v2::CaptureHeader_MetadataEntry_DoNotUse, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::telemetry::v2::CaptureHeader_MetadataEntry_DoNotUse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::telemetry::v2::CaptureHeader_MetadataEntry_DoNotUse, key_),
  PROTOBUF_FIELD_OFFSET(::telemetry::v2::CaptureHeader_MetadataEntry_DoNotUse, value_),
  0,
  1,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::telemetry::v2::CaptureHeader, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::telemetry::v2::CaptureHeader, _impl_.capture_id_),
  PROTOBUF_FIELD_OFFSET(::telemetry::v2::CaptureHeader, _impl_.created_at_),
  PROTOBUF_FIELD_OFFSET(::telemetry::v2::CaptureHeader, _impl_.session_id_),
  PROTOBUF_FIELD_OFFSET(::telemetry::v2::CaptureHeader, _impl_.map_name_),
  PROTOBUF_FIELD_OFFSET(::telemetry::v2::CaptureHeader, _impl_.match_type_),
  PROTOBUF_FIELD_OFFSET(::telemetry::v2::CaptureHeader, _impl_.client_name_),
  PROTOBUF_FIELD_OFFSET(::telemetry::v2::CaptureHeader, _impl_.private_match_),
  PROTOBUF_FIELD_OFFSET(::telemetry::v2::CaptureHeader, _impl_.tournament_match_),
  PROTOBUF_FIELD_OFFSET(::telemetry::v2::CaptureHeader, _impl_.total_round_count_),
  PROTOBUF_FIELD_OFFSET(::telemetry::v2::CaptureHeader, _impl_.initial_roster_),
  PROTOBUF_FIELD_OFFSET(::telemetry::v2::CaptureHeader, _impl_.metadata_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::telemetry::v2::PlayerInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::telemetry::v2::PlayerInfo, _impl_.slot_),
  PROTOBUF_FIELD_OFFSET(::telemetry::v2::PlayerInfo, _impl_.account_number_),
  PROTOBUF_FIELD_OFFSET(::telemetry::v2::PlayerInfo, _impl_.display_name_),
  PROTOBUF_FIELD_OFFSET(::telemetry::v2::PlayerInfo, _impl_.role_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::telemetry::v2::DiscState, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::telemetry::v2::DiscState, _impl_.pose_),
  PROTOBUF_FIELD_OFFSET(::telemetry::v2::DiscState, _impl_.velocity_),
  PROTOBUF_FIELD_OFFSET(::telemetry::v2::DiscState, _impl_.bounce_count_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::telemetry::v2::PlayerState, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::telemetry::v2::PlayerState, _impl_.slot_),
  PROTOBUF_FIELD_OFFSET(::telemetry::v2::PlayerState, _impl_.head_),
  PROTOBUF_FIELD_OFFSET(::telemetry::v2::PlayerState, _impl_.body_),
  PROTOBUF_FIELD_OFFSET(::telemetry::v2::PlayerState, _impl_.left_hand_),
  PROTOBUF_FIELD_OFFSET(::telemetry::v2::PlayerState, _impl_.right_hand_),
  PROTOBUF_FIELD_OFFSET(::telemetry::v2::PlayerState, _impl_.velocity_),
  PROTOBUF_FIELD_OFFSET(::telemetry::v2::PlayerState, _impl_.flags_),
  PROTOBUF_FIELD_OFFSET(::telemetry::v2::PlayerState, _impl_.ping_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::telemetry::v2::PlayerBones, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::telemetry::v2::PlayerBones, _impl_.slot_),
  PROTOBUF_FIELD_OFFSET(::telemetry::v2::PlayerBones, _impl_.transforms_),
  PROTOBUF_FIELD_OFFSET(::telemetry::v2::PlayerBones, _impl_.orientations_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::telemetry::v2::Frame, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::telemetry::v2::Frame, _impl_.frame_index_),
  PROTOBUF_FIELD_OFFSET(::telemetry::v2::Frame, _impl_.timestamp_offset_ms_),
  PROTOBUF_FIELD_OFFSET(::telemetry::v2::Frame, _impl_.game_status_),
  PROTOBUF_FIELD_OFFSET(::telemetry::v2::Frame, _impl_.game_clock_),
  PROTOBUF_FIELD_OFFSET(::telemetry::v2::Frame, _impl_.disc_),
  PROTOBUF_FIELD_OFFSET(::telemetry::v2::Frame, _impl_.players_),
  PROTOBUF_FIELD_OFFSET(::telemetry::v2::Frame, _impl_.player_bones_),
  PROTOBUF_FIELD_OFFSET(::telemetry::v2::Frame, _impl_.events_),
  PROTOBUF_FIELD_OFFSET(::telemetry::v2::Frame, _impl_.disc_holder_slot_),
  PROTOBUF_FIELD_OFFSET(::telemetry::v2::Frame, _impl_.vr_root_),
  PROTOBUF_FIELD_OFFSET(::telemetry::v2::Frame, _impl_.blue_points_),
  PROTOBUF_FIELD_OFFSET(::telemetry::v2::Frame, _impl_.orange_points_),
  PROTOBUF_FIELD_OFFSET(::telemetry::v2::Frame, _impl_.round_number_),
  PROTOBUF_FIELD_OFFSET(::telemetry::v2::Frame, _impl_.pause_state_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::telemetry::v2::EnvelopeV2, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::telemetry::v2::EnvelopeV2, _impl_._oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::telemetry::v2::EnvelopeV2, _impl_.message_),
};
static const ::_pbi::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, 8, -1, sizeof(::telemetry::v2::CaptureHeader_MetadataEntry_DoNotUse)},
  { 10, -1, -1, sizeof(::telemetry::v2::CaptureHeader)},
  { 27, -1, -1, sizeof(::telemetry::v2::PlayerInfo)},
  { 37, -1, -1, sizeof(::telemetry::v2::DiscState)},
  { 46, -1, -1, sizeof(::telemetry::v2::PlayerState)},
  { 60, -1, -1, sizeof(::telemetry::v2::PlayerBones)},
  { 69, -1, -1, sizeof(::telemetry::v2::Frame)},
  { 89, -1, -1, sizeof(::telemetry::v2::EnvelopeV2)},
};

static const ::_pb::Message* const file_default_instances[] = {
  &::telemetry::v2::_CaptureHeader_MetadataEntry_DoNotUse_default_instance_._instance,
  &::telemetry::v2::_CaptureHeader_default_instance_._instance,
  &::telemetry::v2::_PlayerInfo_default_instance_._instance,
  &::telemetry::v2::_DiscState_default_instance_._instance,
  &::telemetry::v2::_PlayerState_default_instance_._instance,
  &::telemetry::v2::_PlayerBones_default_instance_._instance,
  &::telemetry::v2::_Frame_default_instance_._instance,
  &::telemetry::v2::_EnvelopeV2_default_instance_._instance,
};

const char descriptor_table_protodef_telemetry_2fv2_2fframe_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\030telemetry/v2/frame.proto\022\014telemetry.v2"
  "\032\026spatial/v1/types.proto\032\034telemetry/v1/t"
  "elemetry.proto\032\037google/protobuf/timestam"
  "p.proto\"\247\003\n\rCaptureHeader\022\022\n\ncapture_id\030"
  "\001 \001(\t\022.\n\ncreated_at\030\002 \001(\0132\032.google.proto"
  "buf.Timestamp\022\022\n\nsession_id\030\003 \001(\t\022\020\n\010map"
  "_name\030\004 \001(\t\022+\n\nmatch_type\030\005 \001(\0162\027.teleme"
  "try.v2.MatchType\022\023\n\013client_name\030\006 \001(\t\022\025\n"
  "\rprivate_match\030\007 \001(\010\022\030\n\020tournament_match"
  "\030\010 \001(\010\022\031\n\021total_round_count\030\t \001(\005\0220\n\016ini"
  "tial_roster\030\n \003(\0132\030.telemetry.v2.PlayerI"
  "nfo\022;\n\010metadata\030\013 \003(\0132).telemetry.v2.Cap"
  "tureHeader.MetadataEntry\032/\n\rMetadataEntr"
  "y\022\013\n\003key\030\001 \001(\t\022\r\n\005value\030\002 \001(\t:\0028\001\"j\n\nPla"
  "yerInfo\022\014\n\004slot\030\001 \001(\005\022\026\n\016account_number\030"
  "\002 \001(\004\022\024\n\014display_name\030\003 \001(\t\022 \n\004role\030\004 \001("
  "\0162\022.telemetry.v1.Role\"e\n\tDiscState\022\036\n\004po"
  "se\030\001 \001(\0132\020.spatial.v1.Pose\022\"\n\010velocity\030\002"
  " \001(\0132\020.spatial.v1.Vec3\022\024\n\014bounce_count\030\003"
  " \001(\r\"\347\001\n\013PlayerState\022\014\n\004slot\030\001 \001(\005\022\036\n\004he"
  "ad\030\002 \001(\0132\020.spatial.v1.Pose\022\036\n\004body\030\003 \001(\013"
  "2\020.spatial.v1.Pose\022#\n\tleft_hand\030\004 \001(\0132\020."
  "spatial.v1.Pose\022$\n\nright_hand\030\005 \001(\0132\020.sp"
  "atial.v1.Pose\022\"\n\010velocity\030\006 \001(\0132\020.spatia"
  "l.v1.Vec3\022\r\n\005flags\030\007 \001(\r\022\014\n\004ping\030\010 \001(\r\"E"
  "\n\013PlayerBones\022\014\n\004slot\030\001 \001(\005\022\022\n\ntransform"
  "s\030\002 \001(\014\022\024\n\014orientations\030\003 \001(\014\"\337\003\n\005Frame\022"
  "\023\n\013frame_index\030\001 \001(\r\022\033\n\023timestamp_offset"
  "_ms\030\002 \001(\r\022-\n\013game_status\030\003 \001(\0162\030.telemet"
  "ry.v2.GameStatus\022\022\n\ngame_clock\030\004 \001(\002\022%\n\004"
  "disc\030\005 \001(\0132\027.telemetry.v2.DiscState\022*\n\007p"
  "layers\030\006 \003(\0132\031.telemetry.v2.PlayerState\022"
  "/\n\014player_bones\030\007 \003(\0132\031.telemetry.v2.Pla"
  "yerBones\022/\n\006events\030\010 \003(\0132\037.telemetry.v1."
  "LobbySessionEvent\022\030\n\020disc_holder_slot\030\t "
  "\001(\021\022!\n\007vr_root\030\n \001(\0132\020.spatial.v1.Pose\022\023"
  "\n\013blue_points\030\013 \001(\005\022\025\n\rorange_points\030\014 \001"
  "(\005\022\024\n\014round_number\030\r \001(\005\022-\n\013pause_state\030"
  "\016 \001(\0162\030.telemetry.v2.PauseState\"\340\001\n\nEnve"
  "lopeV2\0220\n\theader_v2\030\001 \001(\0132\033.telemetry.v2"
  ".CaptureHeaderH\000\022\'\n\010frame_v2\030\002 \001(\0132\023.tel"
  "emetry.v2.FrameH\000\0222\n\theader_v1\030\n \001(\0132\035.t"
  "elemetry.v1.TelemetryHeaderH\000\0228\n\010frame_v"
  "1\030\013 \001(\0132$.telemetry.v1.LobbySessionState"
  "FrameH\000B\t\n\007message*\254\002\n\nGameStatus\022\033\n\027GAM"
  "E_STATUS_UNSPECIFIED\020\000\022\031\n\025GAME_STATUS_PR"
  "E_MATCH\020\001\022\033\n\027GAME_STATUS_ROUND_START\020\002\022\027"
  "\n\023GAME_STATUS_PLAYING\020\003\022\025\n\021GAME_STATUS_S"
  "CORE\020\004\022\032\n\026GAME_STATUS_ROUND_OVER\020\005\022\032\n\026GA"
  "ME_STATUS_POST_MATCH\020\006\022 \n\034GAME_STATUS_PR"
  "E_SUDDEN_DEATH\020\007\022\034\n\030GAME_STATUS_SUDDEN_D"
  "EATH\020\010\022!\n\035GAME_STATUS_POST_SUDDEN_DEATH\020"
  "\t*\362\001\n\tMatchType\022\032\n\026MATCH_TYPE_UNSPECIFIE"
  "D\020\000\022\034\n\030MATCH_TYPE_SOCIAL_PUBLIC\020\001\022\035\n\031MAT"
  "CH_TYPE_SOCIAL_PRIVATE\020\002\022\024\n\020MATCH_TYPE_A"
  "RENA\020\003\022\025\n\021MATCH_TYPE_COMBAT\020\004\022\030\n\024MATCH_T"
  "YPE_ECHO_PASS\020\005\022\022\n\016MATCH_TYPE_FFA\020\006\022\026\n\022M"
  "ATCH_TYPE_PRIVATE\020\007\022\031\n\025MATCH_TYPE_TOURNA"
  "MENT\020\010*\232\001\n\nPauseState\022\033\n\027PAUSE_STATE_UNS"
  "PECIFIED\020\000\022\032\n\026PAUSE_STATE_NOT_PAUSED\020\001\022\026"
  "\n\022PAUSE_STATE_PAUSED\020\002\022\031\n\025PAUSE_STATE_UN"
  "PAUSING\020\003\022 \n\034PAUSE_STATE_AUTOPAUSE_REPLA"
  "Y\020\004*\224\001\n\010GoalType\022\031\n\025GOAL_TYPE_UNSPECIFIE"
  "D\020\000\022\031\n\025GOAL_TYPE_INSIDE_SHOT\020\001\022\027\n\023GOAL_T"
  "YPE_LONG_SHOT\020\002\022\031\n\025GOAL_TYPE_BOUNCE_SHOT"
  "\020\003\022\036\n\032GOAL_TYPE_LONG_BOUNCE_SHOT\020\004B\216\001\n\037c"
  "om.echotools.nevr.telemetry.v2B\020Telemetr"
  "yV2ProtoP\001ZCgithub.com/echotools/nevr-co"
  "mmon/v4/gen/go/telemetry/v2;telemetryv2\252"
  "\002\021Nevr.Telemetry.V2b\006proto3"
  ;
static const ::_pbi::DescriptorTable* const descriptor_table_telemetry_2fv2_2fframe_2eproto_deps[3] = {
  &::descriptor_table_google_2fprotobuf_2ftimestamp_2eproto,
  &::descriptor_table_spatial_2fv1_2ftypes_2eproto,
  &::descriptor_table_telemetry_2fv1_2ftelemetry_2eproto,
};
static ::_pbi::once_flag descriptor_table_telemetry_2fv2_2fframe_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_telemetry_2fv2_2fframe_2eproto = {
    false, false, 2787, descriptor_table_protodef_telemetry_2fv2_2fframe_2eproto,
    "telemetry/v2/frame.proto",
    &descriptor_table_telemetry_2fv2_2fframe_2eproto_once, descriptor_table_telemetry_2fv2_2fframe_2eproto_deps, 3, 8,
    schemas, file_default_instances, TableStruct_telemetry_2fv2_2fframe_2eproto::offsets,
    file_level_metadata_telemetry_2fv2_2fframe_2eproto, file_level_enum_descriptors_telemetry_2fv2_2fframe_2eproto,
    file_level_service_descriptors_telemetry_2fv2_2fframe_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_telemetry_2fv2_2fframe_2eproto_getter() {
  return &descriptor_table_telemetry_2fv2_2fframe_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_telemetry_2fv2_2fframe_2eproto(&descriptor_table_telemetry_2fv2_2fframe_2eproto);
namespace telemetry {
namespace v2 {
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* GameStatus_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_telemetry_2fv2_2fframe_2eproto);
  return file_level_enum_descriptors_telemetry_2fv2_2fframe_2eproto[0];
}
bool GameStatus_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MatchType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_telemetry_2fv2_2fframe_2eproto);
  return file_level_enum_descriptors_telemetry_2fv2_2fframe_2eproto[1];
}
bool MatchType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PauseState_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_telemetry_2fv2_2fframe_2eproto);
  return file_level_enum_descriptors_telemetry_2fv2_2fframe_2eproto[2];
}
bool PauseState_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* GoalType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_telemetry_2fv2_2fframe_2eproto);
  return file_level_enum_descriptors_telemetry_2fv2_2fframe_2eproto[3];
}
bool GoalType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}


// ===================================================================

CaptureHeader_MetadataEntry_DoNotUse::CaptureHeader_MetadataEntry_DoNotUse() {}
CaptureHeader_MetadataEntry_DoNotUse::CaptureHeader_MetadataEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena) {}
void CaptureHeader_MetadataEntry_DoNotUse::MergeFrom(const CaptureHeader_MetadataEntry_DoNotUse& other) {
  MergeFromInternal(other);
}
::PROTOBUF_NAMESPACE_ID::Metadata CaptureHeader_MetadataEntry_DoNotUse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_telemetry_2fv2_2fframe_2eproto_getter, &descriptor_table_telemetry_2fv2_2fframe_2eproto_once,
      file_level_metadata_telemetry_2fv2_2fframe_2eproto[0]);
}

// ===================================================================

class CaptureHeader::_Internal {
 public:
  static const ::PROTOBUF_NAMESPACE_ID::Timestamp& created_at(const CaptureHeader* msg);
};

const ::PROTOBUF_NAMESPACE_ID::Timestamp&
CaptureHeader::_Internal::created_at(const CaptureHeader* msg) {
  return *msg->_impl_.created_at_;
}
void CaptureHeader::clear_created_at() {
  if (GetArenaForAllocation() == nullptr && _impl_.created_at_ != nullptr) {
    delete _impl_.created_at_;
  }
  _impl_.created_at_ = nullptr;
}
CaptureHeader::CaptureHeader(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  if (arena != nullptr && !is_message_owned) {
    arena->OwnCustomDestructor(this, &CaptureHeader::ArenaDtor);
  }
  // @@protoc_insertion_point(arena_constructor:telemetry.v2.CaptureHeader)
}
CaptureHeader::CaptureHeader(const CaptureHeader& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CaptureHeader* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.initial_roster_){from._impl_.initial_roster_}
    , /*decltype(_impl_.metadata_)*/{}
    , decltype(_impl_.capture_id_){}
    , decltype(_impl_.session_id_){}
    , decltype(_impl_.map_name_){}
    , decltype(_impl_.client_name_){}
    , decltype(_impl_.created_at_){nullptr}
    , decltype(_impl_.match_type_){}
    , decltype(_impl_.private_match_){}
    , decltype(_impl_.tournament_match_){}
    , decltype(_impl_.total_round_count_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.metadata_.MergeFrom(from._impl_.metadata_);
  _impl_.capture_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.capture_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_capture_id().empty()) {
    _this->_impl_.capture_id_.Set(from._internal_capture_id(), 
      _this->GetArenaForAllocation());
  }
  _impl_.session_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.session_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_session_id().empty()) {
    _this->_impl_.session_id_.Set(from._internal_session_id(), 
      _this->GetArenaForAllocation());
  }
  _impl_.map_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.map_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_map_name().empty()) {
    _this->_impl_.map_name_.Set(from._internal_map_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.client_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.client_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_client_name().empty()) {
    _this->_impl_.client_name_.Set(from._internal_client_name(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_created_at()) {
    _this->_impl_.created_at_ = new ::PROTOBUF_NAMESPACE_ID::Timestamp(*from._impl_.created_at_);
  }
  ::memcpy(&_impl_.match_type_, &from._impl_.match_type_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.total_round_count_) -
    reinterpret_cast<char*>(&_impl_.match_type_)) + sizeof(_impl_.total_round_count_));
  // @@protoc_insertion_point(copy_constructor:telemetry.v2.CaptureHeader)
}

inline void CaptureHeader::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.initial_roster_){arena}
    , /*decltype(_impl_.metadata_)*/{::_pbi::ArenaInitialized(), arena}
    , decltype(_impl_.capture_id_){}
    , decltype(_impl_.session_id_){}
    , decltype(_impl_.map_name_){}
    , decltype(_impl_.client_name_){}
    , decltype(_impl_.created_at_){nullptr}
    , decltype(_impl_.match_type_){0}
    , decltype(_impl_.private_match_){false}
    , decltype(_impl_.tournament_match_){false}
    , decltype(_impl_.total_round_count_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.capture_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.capture_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.session_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.session_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.map_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.map_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.client_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.client_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CaptureHeader::~CaptureHeader() {
  // @@protoc_insertion_point(destructor:telemetry.v2.CaptureHeader)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    ArenaDtor(this);
    return;
  }
  SharedDtor();
}

inline void CaptureHeader::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.initial_roster_.~RepeatedPtrField();
  _impl_.metadata_.Destruct();
  _impl_.metadata_.~MapField();
  _impl_.capture_id_.Destroy();
  _impl_.session_id_.Destroy();
  _impl_.map_name_.Destroy();
  _impl_.client_name_.Destroy();
  if (this != internal_default_instance()) delete _impl_.created_at_;
}

void CaptureHeader::ArenaDtor(void* object) {
  CaptureHeader* _this = reinterpret_cast< CaptureHeader* >(object);
  _this->_impl_.metadata_.Destruct();
}
void CaptureHeader::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CaptureHeader::Clear() {
// @@protoc_insertion_point(message_clear_start:telemetry.v2.CaptureHeader)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.initial_roster_.Clear();
  _impl_.metadata_.Clear();
  _impl_.capture_id_.ClearToEmpty();
  _impl_.session_id_.ClearToEmpty();
  _impl_.map_name_.ClearToEmpty();
  _impl_.client_name_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.created_at_ != nullptr) {
    delete _impl_.created_at_;
  }
  _impl_.created_at_ = nullptr;
  ::memset(&_impl_.match_type_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.total_round_count_) -
      reinterpret_cast<char*>(&_impl_.match_type_)) + sizeof(_impl_.total_round_count_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CaptureHeader::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string capture_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_capture_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "telemetry.v2.CaptureHeader.capture_id"));
        } else
          goto handle_unusual;
        continue;
      // .google.protobuf.Timestamp created_at = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_created_at(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string session_id = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_session_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "telemetry.v2.CaptureHeader.session_id"));
        } else
          goto handle_unusual;
        continue;
      // string map_name = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_map_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "telemetry.v2.CaptureHeader.map_name"));
        } else
          goto handle_unusual;
        continue;
      // .telemetry.v2.MatchType match_type = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_match_type(static_cast<::telemetry::v2::MatchType>(val));
        } else
          goto handle_unusual;
        continue;
      // string client_name = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_client_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "telemetry.v2.CaptureHeader.client_name"));
        } else
          goto handle_unusual;
        continue;
      // bool private_match = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _impl_.private_match_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool tournament_match = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _impl_.tournament_match_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 total_round_count = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _impl_.total_round_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .telemetry.v2.PlayerInfo initial_roster = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_initial_roster(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<82>(ptr));
        } else
          goto handle_unusual;
        continue;
      // map<string, string> metadata = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(&_impl_.metadata_, ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<90>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CaptureHeader::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:telemetry.v2.CaptureHeader)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string capture_id = 1;
  if (!this->_internal_capture_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_capture_id().data(), static_cast<int>(this->_internal_capture_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "telemetry.v2.CaptureHeader.capture_id");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_capture_id(), target);
  }

  // .google.protobuf.Timestamp created_at = 2;
  if (this->_internal_has_created_at()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::created_at(this),
        _Internal::created_at(this).GetCachedSize(), target, stream);
  }

  // string session_id = 3;
  if (!this->_internal_session_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_session_id().data(), static_cast<int>(this->_internal_session_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "telemetry.v2.CaptureHeader.session_id");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_session_id(), target);
  }

  // string map_name = 4;
  if (!this->_internal_map_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_map_name().data(), static_cast<int>(this->_internal_map_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "telemetry.v2.CaptureHeader.map_name");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_map_name(), target);
  }

  // .telemetry.v2.MatchType match_type = 5;
  if (this->_internal_match_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      5, this->_internal_match_type(), target);
  }

  // string client_name = 6;
  if (!this->_internal_client_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_client_name().data(), static_cast<int>(this->_internal_client_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "telemetry.v2.CaptureHeader.client_name");
    target = stream->WriteStringMaybeAliased(
        6, this->_internal_client_name(), target);
  }

  // bool private_match = 7;
  if (this->_internal_private_match() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(7, this->_internal_private_match(), target);
  }

  // bool tournament_match = 8;
  if (this->_internal_tournament_match() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(8, this->_internal_tournament_match(), target);
  }

  // int32 total_round_count = 9;
  if (this->_internal_total_round_count() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(9, this->_internal_total_round_count(), target);
  }

  // repeated .telemetry.v2.PlayerInfo initial_roster = 10;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_initial_roster_size()); i < n; i++) {
    const auto& repfield = this->_internal_initial_roster(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(10, repfield, repfield.GetCachedSize(), target, stream);
  }

  // map<string, string> metadata = 11;
  if (!this->_internal_metadata().empty()) {
    using MapType = ::_pb::Map<std::string, std::string>;
    using WireHelper = CaptureHeader_MetadataEntry_DoNotUse::Funcs;
    const auto& map_field = this->_internal_metadata();
    auto check_utf8 = [](const MapType::value_type& entry) {
      (void)entry;
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        entry.first.data(), static_cast<int>(entry.first.length()),
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
        "telemetry.v2.CaptureHeader.MetadataEntry.key");
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        entry.second.data(), static_cast<int>(entry.second.length()),
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
        "telemetry.v2.CaptureHeader.MetadataEntry.value");
    };

    if (stream->IsSerializationDeterministic() && map_field.size() > 1) {
      for (const auto& entry : ::_pbi::MapSorterPtr<MapType>(map_field)) {
        target = WireHelper::InternalSerialize(11, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    } else {
      for (const auto& entry : map_field) {
        target = WireHelper::InternalSerialize(11, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:telemetry.v2.CaptureHeader)
  return target;
}

size_t CaptureHeader::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:telemetry.v2.CaptureHeader)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .telemetry.v2.PlayerInfo initial_roster = 10;
  total_size += 1UL * this->_internal_initial_roster_size();
  for (const auto& msg : this->_impl_.initial_roster_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // map<string, string> metadata = 11;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_metadata_size());
  for (::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >::const_iterator
      it = this->_internal_metadata().begin();
      it != this->_internal_metadata().end(); ++it) {
    total_size += CaptureHeader_MetadataEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
  }

  // string capture_id = 1;
  if (!this->_internal_capture_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_capture_id());
  }

  // string session_id = 3;
  if (!this->_internal_session_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_session_id());
  }

  // string map_name = 4;
  if (!this->_internal_map_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_map_name());
  }

  // string client_name = 6;
  if (!this->_internal_client_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_client_name());
  }

  // .google.protobuf.Timestamp created_at = 2;
  if (this->_internal_has_created_at()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.created_at_);
  }

  // .telemetry.v2.MatchType match_type = 5;
  if (this->_internal_match_type() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_match_type());
  }

  // bool private_match = 7;
  if (this->_internal_private_match() != 0) {
    total_size += 1 + 1;
  }

  // bool tournament_match = 8;
  if (this->_internal_tournament_match() != 0) {
    total_size += 1 + 1;
  }

  // int32 total_round_count = 9;
  if (this->_internal_total_round_count() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_total_round_count());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CaptureHeader::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CaptureHeader::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CaptureHeader::GetClassData() const { return &_class_data_; }


void CaptureHeader::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CaptureHeader*>(&to_msg);
  auto& from = static_cast<const CaptureHeader&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:telemetry.v2.CaptureHeader)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.initial_roster_.MergeFrom(from._impl_.initial_roster_);
  _this->_impl_.metadata_.MergeFrom(from._impl_.metadata_);
  if (!from._internal_capture_id().empty()) {
    _this->_internal_set_capture_id(from._internal_capture_id());
  }
  if (!from._internal_session_id().empty()) {
    _this->_internal_set_session_id(from._internal_session_id());
  }
  if (!from._internal_map_name().empty()) {
    _this->_internal_set_map_name(from._internal_map_name());
  }
  if (!from._internal_client_name().empty()) {
    _this->_internal_set_client_name(from._internal_client_name());
  }
  if (from._internal_has_created_at()) {
    _this->_internal_mutable_created_at()->::PROTOBUF_NAMESPACE_ID::Timestamp::MergeFrom(
        from._internal_created_at());
  }
  if (from._internal_match_type() != 0) {
    _this->_internal_set_match_type(from._internal_match_type());
  }
  if (from._internal_private_match() != 0) {
    _this->_internal_set_private_match(from._internal_private_match());
  }
  if (from._internal_tournament_match() != 0) {
    _this->_internal_set_tournament_match(from._internal_tournament_match());
  }
  if (from._internal_total_round_count() != 0) {
    _this->_internal_set_total_round_count(from._internal_total_round_count());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CaptureHeader::CopyFrom(const CaptureHeader& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:telemetry.v2.CaptureHeader)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CaptureHeader::IsInitialized() const {
  return true;
}

void CaptureHeader::InternalSwap(CaptureHeader* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.initial_roster_.InternalSwap(&other->_impl_.initial_roster_);
  _impl_.metadata_.InternalSwap(&other->_impl_.metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.capture_id_, lhs_arena,
      &other->_impl_.capture_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.session_id_, lhs_arena,
      &other->_impl_.session_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.map_name_, lhs_arena,
      &other->_impl_.map_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.client_name_, lhs_arena,
      &other->_impl_.client_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CaptureHeader, _impl_.total_round_count_)
      + sizeof(CaptureHeader::_impl_.total_round_count_)
      - PROTOBUF_FIELD_OFFSET(CaptureHeader, _impl_.created_at_)>(
          reinterpret_cast<char*>(&_impl_.created_at_),
          reinterpret_cast<char*>(&other->_impl_.created_at_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CaptureHeader::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_telemetry_2fv2_2fframe_2eproto_getter, &descriptor_table_telemetry_2fv2_2fframe_2eproto_once,
      file_level_metadata_telemetry_2fv2_2fframe_2eproto[1]);
}

// ===================================================================

class PlayerInfo::_Internal {
 public:
};

PlayerInfo::PlayerInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:telemetry.v2.PlayerInfo)
}
PlayerInfo::PlayerInfo(const PlayerInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PlayerInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.display_name_){}
    , decltype(_impl_.account_number_){}
    , decltype(_impl_.slot_){}
    , decltype(_impl_.role_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.display_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.display_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_display_name().empty()) {
    _this->_impl_.display_name_.Set(from._internal_display_name(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.account_number_, &from._impl_.account_number_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.role_) -
    reinterpret_cast<char*>(&_impl_.account_number_)) + sizeof(_impl_.role_));
  // @@protoc_insertion_point(copy_constructor:telemetry.v2.PlayerInfo)
}

inline void PlayerInfo::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.display_name_){}
    , decltype(_impl_.account_number_){uint64_t{0u}}
    , decltype(_impl_.slot_){0}
    , decltype(_impl_.role_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.display_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.display_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

PlayerInfo::~PlayerInfo() {
  // @@protoc_insertion_point(destructor:telemetry.v2.PlayerInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PlayerInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.display_name_.Destroy();
}

void PlayerInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PlayerInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:telemetry.v2.PlayerInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.display_name_.ClearToEmpty();
  ::memset(&_impl_.account_number_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.role_) -
      reinterpret_cast<char*>(&_impl_.account_number_)) + sizeof(_impl_.role_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PlayerInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 slot = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.slot_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint64 account_number = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.account_number_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string display_name = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_display_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "telemetry.v2.PlayerInfo.display_name"));
        } else
          goto handle_unusual;
        continue;
      // .telemetry.v1.Role role = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_role(static_cast<::telemetry::v1::Role>(val));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PlayerInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:telemetry.v2.PlayerInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 slot = 1;
  if (this->_internal_slot() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_slot(), target);
  }

  // uint64 account_number = 2;
  if (this->_internal_account_number() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_account_number(), target);
  }

  // string display_name = 3;
  if (!this->_internal_display_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_display_name().data(), static_cast<int>(this->_internal_display_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "telemetry.v2.PlayerInfo.display_name");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_display_name(), target);
  }

  // .telemetry.v1.Role role = 4;
  if (this->_internal_role() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      4, this->_internal_role(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:telemetry.v2.PlayerInfo)
  return target;
}

size_t PlayerInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:telemetry.v2.PlayerInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string display_name = 3;
  if (!this->_internal_display_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_display_name());
  }

  // uint64 account_number = 2;
  if (this->_internal_account_number() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_account_number());
  }

  // int32 slot = 1;
  if (this->_internal_slot() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_slot());
  }

  // .telemetry.v1.Role role = 4;
  if (this->_internal_role() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_role());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PlayerInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PlayerInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PlayerInfo::GetClassData() const { return &_class_data_; }


void PlayerInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PlayerInfo*>(&to_msg);
  auto& from = static_cast<const PlayerInfo&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:telemetry.v2.PlayerInfo)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_display_name().empty()) {
    _this->_internal_set_display_name(from._internal_display_name());
  }
  if (from._internal_account_number() != 0) {
    _this->_internal_set_account_number(from._internal_account_number());
  }
  if (from._internal_slot() != 0) {
    _this->_internal_set_slot(from._internal_slot());
  }
  if (from._internal_role() != 0) {
    _this->_internal_set_role(from._internal_role());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PlayerInfo::CopyFrom(const PlayerInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:telemetry.v2.PlayerInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PlayerInfo::IsInitialized() const {
  return true;
}

void PlayerInfo::InternalSwap(PlayerInfo* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.display_name_, lhs_arena,
      &other->_impl_.display_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PlayerInfo, _impl_.role_)
      + sizeof(PlayerInfo::_impl_.role_)
      - PROTOBUF_FIELD_OFFSET(PlayerInfo, _impl_.account_number_)>(
          reinterpret_cast<char*>(&_impl_.account_number_),
          reinterpret_cast<char*>(&other->_impl_.account_number_));
}

::PROTOBUF_NAMESPACE_ID::Metadata PlayerInfo::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_telemetry_2fv2_2fframe_2eproto_getter, &descriptor_table_telemetry_2fv2_2fframe_2eproto_once,
      file_level_metadata_telemetry_2fv2_2fframe_2eproto[2]);
}

// ===================================================================

class DiscState::_Internal {
 public:
  static const ::spatial::v1::Pose& pose(const DiscState* msg);
  static const ::spatial::v1::Vec3& velocity(const DiscState* msg);
};

const ::spatial::v1::Pose&
DiscState::_Internal::pose(const DiscState* msg) {
  return *msg->_impl_.pose_;
}
const ::spatial::v1::Vec3&
DiscState::_Internal::velocity(const DiscState* msg) {
  return *msg->_impl_.velocity_;
}
void DiscState::clear_pose() {
  if (GetArenaForAllocation() == nullptr && _impl_.pose_ != nullptr) {
    delete _impl_.pose_;
  }
  _impl_.pose_ = nullptr;
}
void DiscState::clear_velocity() {
  if (GetArenaForAllocation() == nullptr && _impl_.velocity_ != nullptr) {
    delete _impl_.velocity_;
  }
  _impl_.velocity_ = nullptr;
}
DiscState::DiscState(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:telemetry.v2.DiscState)
}
DiscState::DiscState(const DiscState& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  DiscState* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.pose_){nullptr}
    , decltype(_impl_.velocity_){nullptr}
    , decltype(_impl_.bounce_count_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_pose()) {
    _this->_impl_.pose_ = new ::spatial::v1::Pose(*from._impl_.pose_);
  }
  if (from._internal_has_velocity()) {
    _this->_impl_.velocity_ = new ::spatial::v1::Vec3(*from._impl_.velocity_);
  }
  _this->_impl_.bounce_count_ = from._impl_.bounce_count_;
  // @@protoc_insertion_point(copy_constructor:telemetry.v2.DiscState)
}

inline void DiscState::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.pose_){nullptr}
    , decltype(_impl_.velocity_){nullptr}
    , decltype(_impl_.bounce_count_){0u}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

DiscState::~DiscState() {
  // @@protoc_insertion_point(destructor:telemetry.v2.DiscState)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DiscState::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.pose_;
  if (this != internal_default_instance()) delete _impl_.velocity_;
}

void DiscState::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DiscState::Clear() {
// @@protoc_insertion_point(message_clear_start:telemetry.v2.DiscState)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.pose_ != nullptr) {
    delete _impl_.pose_;
  }
  _impl_.pose_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.velocity_ != nullptr) {
    delete _impl_.velocity_;
  }
  _impl_.velocity_ = nullptr;
  _impl_.bounce_count_ = 0u;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DiscState::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .spatial.v1.Pose pose = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_pose(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .spatial.v1.Vec3 velocity = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_velocity(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 bounce_count = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.bounce_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DiscState::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:telemetry.v2.DiscState)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .spatial.v1.Pose pose = 1;
  if (this->_internal_has_pose()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::pose(this),
        _Internal::pose(this).GetCachedSize(), target, stream);
  }

  // .spatial.v1.Vec3 velocity = 2;
  if (this->_internal_has_velocity()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::velocity(this),
        _Internal::velocity(this).GetCachedSize(), target, stream);
  }

  // uint32 bounce_count = 3;
  if (this->_internal_bounce_count() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_bounce_count(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:telemetry.v2.DiscState)
  return target;
}

size_t DiscState::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:telemetry.v2.DiscState)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .spatial.v1.Pose pose = 1;
  if (this->_internal_has_pose()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.pose_);
  }

  // .spatial.v1.Vec3 velocity = 2;
  if (this->_internal_has_velocity()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.velocity_);
  }

  // uint32 bounce_count = 3;
  if (this->_internal_bounce_count() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_bounce_count());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DiscState::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    DiscState::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DiscState::GetClassData() const { return &_class_data_; }


void DiscState::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<DiscState*>(&to_msg);
  auto& from = static_cast<const DiscState&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:telemetry.v2.DiscState)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_pose()) {
    _this->_internal_mutable_pose()->::spatial::v1::Pose::MergeFrom(
        from._internal_pose());
  }
  if (from._internal_has_velocity()) {
    _this->_internal_mutable_velocity()->::spatial::v1::Vec3::MergeFrom(
        from._internal_velocity());
  }
  if (from._internal_bounce_count() != 0) {
    _this->_internal_set_bounce_count(from._internal_bounce_count());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void DiscState::CopyFrom(const DiscState& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:telemetry.v2.DiscState)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DiscState::IsInitialized() const {
  return true;
}

void DiscState::InternalSwap(DiscState* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(DiscState, _impl_.bounce_count_)
      + sizeof(DiscState::_impl_.bounce_count_)
      - PROTOBUF_FIELD_OFFSET(DiscState, _impl_.pose_)>(
          reinterpret_cast<char*>(&_impl_.pose_),
          reinterpret_cast<char*>(&other->_impl_.pose_));
}

::PROTOBUF_NAMESPACE_ID::Metadata DiscState::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_telemetry_2fv2_2fframe_2eproto_getter, &descriptor_table_telemetry_2fv2_2fframe_2eproto_once,
      file_level_metadata_telemetry_2fv2_2fframe_2eproto[3]);
}

// ===================================================================

class PlayerState::_Internal {
 public:
  static const ::spatial::v1::Pose& head(const PlayerState* msg);
  static const ::spatial::v1::Pose& body(const PlayerState* msg);
  static const ::spatial::v1::Pose& left_hand(const PlayerState* msg);
  static const ::spatial::v1::Pose& right_hand(const PlayerState* msg);
  static const ::spatial::v1::Vec3& velocity(const PlayerState* msg);
};

const ::spatial::v1::Pose&
PlayerState::_Internal::head(const PlayerState* msg) {
  return *msg->_impl_.head_;
}
const ::spatial::v1::Pose&
PlayerState::_Internal::body(const PlayerState* msg) {
  return *msg->_impl_.body_;
}
const ::spatial::v1::Pose&
PlayerState::_Internal::left_hand(const PlayerState* msg) {
  return *msg->_impl_.left_hand_;
}
const ::spatial::v1::Pose&
PlayerState::_Internal::right_hand(const PlayerState* msg) {
  return *msg->_impl_.right_hand_;
}
const ::spatial::v1::Vec3&
PlayerState::_Internal::velocity(const PlayerState* msg) {
  return *msg->_impl_.velocity_;
}
void PlayerState::clear_head() {
  if (GetArenaForAllocation() == nullptr && _impl_.head_ != nullptr) {
    delete _impl_.head_;
  }
  _impl_.head_ = nullptr;
}
void PlayerState::clear_body() {
  if (GetArenaForAllocation() == nullptr && _impl_.body_ != nullptr) {
    delete _impl_.body_;
  }
  _impl_.body_ = nullptr;
}
void PlayerState::clear_left_hand() {
  if (GetArenaForAllocation() == nullptr && _impl_.left_hand_ != nullptr) {
    delete _impl_.left_hand_;
  }
  _impl_.left_hand_ = nullptr;
}
void PlayerState::clear_right_hand() {
  if (GetArenaForAllocation() == nullptr && _impl_.right_hand_ != nullptr) {
    delete _impl_.right_hand_;
  }
  _impl_.right_hand_ = nullptr;
}
void PlayerState::clear_velocity() {
  if (GetArenaForAllocation() == nullptr && _impl_.velocity_ != nullptr) {
    delete _impl_.velocity_;
  }
  _impl_.velocity_ = nullptr;
}
PlayerState::PlayerState(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:telemetry.v2.PlayerState)
}
PlayerState::PlayerState(const PlayerState& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PlayerState* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.head_){nullptr}
    , decltype(_impl_.body_){nullptr}
    , decltype(_impl_.left_hand_){nullptr}
    , decltype(_impl_.right_hand_){nullptr}
    , decltype(_impl_.velocity_){nullptr}
    , decltype(_impl_.slot_){}
    , decltype(_impl_.flags_){}
    , decltype(_impl_.ping_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_head()) {
    _this->_impl_.head_ = new ::spatial::v1::Pose(*from._impl_.head_);
  }
  if (from._internal_has_body()) {
    _this->_impl_.body_ = new ::spatial::v1::Pose(*from._impl_.body_);
  }
  if (from._internal_has_left_hand()) {
    _this->_impl_.left_hand_ = new ::spatial::v1::Pose(*from._impl_.left_hand_);
  }
  if (from._internal_has_right_hand()) {
    _this->_impl_.right_hand_ = new ::spatial::v1::Pose(*from._impl_.right_hand_);
  }
  if (from._internal_has_velocity()) {
    _this->_impl_.velocity_ = new ::spatial::v1::Vec3(*from._impl_.velocity_);
  }
  ::memcpy(&_impl_.slot_, &from._impl_.slot_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.ping_) -
    reinterpret_cast<char*>(&_impl_.slot_)) + sizeof(_impl_.ping_));
  // @@protoc_insertion_point(copy_constructor:telemetry.v2.PlayerState)
}

inline void PlayerState::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.head_){nullptr}
    , decltype(_impl_.body_){nullptr}
    , decltype(_impl_.left_hand_){nullptr}
    , decltype(_impl_.right_hand_){nullptr}
    , decltype(_impl_.velocity_){nullptr}
    , decltype(_impl_.slot_){0}
    , decltype(_impl_.flags_){0u}
    , decltype(_impl_.ping_){0u}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

PlayerState::~PlayerState() {
  // @@protoc_insertion_point(destructor:telemetry.v2.PlayerState)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PlayerState::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.head_;
  if (this != internal_default_instance()) delete _impl_.body_;
  if (this != internal_default_instance()) delete _impl_.left_hand_;
  if (this != internal_default_instance()) delete _impl_.right_hand_;
  if (this != internal_default_instance()) delete _impl_.velocity_;
}

void PlayerState::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PlayerState::Clear() {
// @@protoc_insertion_point(message_clear_start:telemetry.v2.PlayerState)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.head_ != nullptr) {
    delete _impl_.head_;
  }
  _impl_.head_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.body_ != nullptr) {
    delete _impl_.body_;
  }
  _impl_.body_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.left_hand_ != nullptr) {
    delete _impl_.left_hand_;
  }
  _impl_.left_hand_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.right_hand_ != nullptr) {
    delete _impl_.right_hand_;
  }
  _impl_.right_hand_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.velocity_ != nullptr) {
    delete _impl_.velocity_;
  }
  _impl_.velocity_ = nullptr;
  ::memset(&_impl_.slot_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.ping_) -
      reinterpret_cast<char*>(&_impl_.slot_)) + sizeof(_impl_.ping_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PlayerState::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 slot = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.slot_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .spatial.v1.Pose head = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_head(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .spatial.v1.Pose body = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_body(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .spatial.v1.Pose left_hand = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_left_hand(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .spatial.v1.Pose right_hand = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_right_hand(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .spatial.v1.Vec3 velocity = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_velocity(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 flags = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _impl_.flags_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 ping = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _impl_.ping_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PlayerState::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:telemetry.v2.PlayerState)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 slot = 1;
  if (this->_internal_slot() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_slot(), target);
  }

  // .spatial.v1.Pose head = 2;
  if (this->_internal_has_head()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::head(this),
        _Internal::head(this).GetCachedSize(), target, stream);
  }

  // .spatial.v1.Pose body = 3;
  if (this->_internal_has_body()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::body(this),
        _Internal::body(this).GetCachedSize(), target, stream);
  }

  // .spatial.v1.Pose left_hand = 4;
  if (this->_internal_has_left_hand()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::left_hand(this),
        _Internal::left_hand(this).GetCachedSize(), target, stream);
  }

  // .spatial.v1.Pose right_hand = 5;
  if (this->_internal_has_right_hand()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::right_hand(this),
        _Internal::right_hand(this).GetCachedSize(), target, stream);
  }

  // .spatial.v1.Vec3 velocity = 6;
  if (this->_internal_has_velocity()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::velocity(this),
        _Internal::velocity(this).GetCachedSize(), target, stream);
  }

  // uint32 flags = 7;
  if (this->_internal_flags() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(7, this->_internal_flags(), target);
  }

  // uint32 ping = 8;
  if (this->_internal_ping() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(8, this->_internal_ping(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:telemetry.v2.PlayerState)
  return target;
}

size_t PlayerState::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:telemetry.v2.PlayerState)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .spatial.v1.Pose head = 2;
  if (this->_internal_has_head()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.head_);
  }

  // .spatial.v1.Pose body = 3;
  if (this->_internal_has_body()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.body_);
  }

  // .spatial.v1.Pose left_hand = 4;
  if (this->_internal_has_left_hand()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.left_hand_);
  }

  // .spatial.v1.Pose right_hand = 5;
  if (this->_internal_has_right_hand()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.right_hand_);
  }

  // .spatial.v1.Vec3 velocity = 6;
  if (this->_internal_has_velocity()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.velocity_);
  }

  // int32 slot = 1;
  if (this->_internal_slot() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_slot());
  }

  // uint32 flags = 7;
  if (this->_internal_flags() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_flags());
  }

  // uint32 ping = 8;
  if (this->_internal_ping() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_ping());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PlayerState::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PlayerState::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PlayerState::GetClassData() const { return &_class_data_; }


void PlayerState::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PlayerState*>(&to_msg);
  auto& from = static_cast<const PlayerState&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:telemetry.v2.PlayerState)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_head()) {
    _this->_internal_mutable_head()->::spatial::v1::Pose::MergeFrom(
        from._internal_head());
  }
  if (from._internal_has_body()) {
    _this->_internal_mutable_body()->::spatial::v1::Pose::MergeFrom(
        from._internal_body());
  }
  if (from._internal_has_left_hand()) {
    _this->_internal_mutable_left_hand()->::spatial::v1::Pose::MergeFrom(
        from._internal_left_hand());
  }
  if (from._internal_has_right_hand()) {
    _this->_internal_mutable_right_hand()->::spatial::v1::Pose::MergeFrom(
        from._internal_right_hand());
  }
  if (from._internal_has_velocity()) {
    _this->_internal_mutable_velocity()->::spatial::v1::Vec3::MergeFrom(
        from._internal_velocity());
  }
  if (from._internal_slot() != 0) {
    _this->_internal_set_slot(from._internal_slot());
  }
  if (from._internal_flags() != 0) {
    _this->_internal_set_flags(from._internal_flags());
  }
  if (from._internal_ping() != 0) {
    _this->_internal_set_ping(from._internal_ping());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PlayerState::CopyFrom(const PlayerState& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:telemetry.v2.PlayerState)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PlayerState::IsInitialized() const {
  return true;
}

void PlayerState::InternalSwap(PlayerState* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PlayerState, _impl_.ping_)
      + sizeof(PlayerState::_impl_.ping_)
      - PROTOBUF_FIELD_OFFSET(PlayerState, _impl_.head_)>(
          reinterpret_cast<char*>(&_impl_.head_),
          reinterpret_cast<char*>(&other->_impl_.head_));
}

::PROTOBUF_NAMESPACE_ID::Metadata PlayerState::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_telemetry_2fv2_2fframe_2eproto_getter, &descriptor_table_telemetry_2fv2_2fframe_2eproto_once,
      file_level_metadata_telemetry_2fv2_2fframe_2eproto[4]);
}

// ===================================================================

class PlayerBones::_Internal {
 public:
};

PlayerBones::PlayerBones(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:telemetry.v2.PlayerBones)
}
PlayerBones::PlayerBones(const PlayerBones& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PlayerBones* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.transforms_){}
    , decltype(_impl_.orientations_){}
    , decltype(_impl_.slot_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.transforms_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.transforms_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_transforms().empty()) {
    _this->_impl_.transforms_.Set(from._internal_transforms(), 
      _this->GetArenaForAllocation());
  }
  _impl_.orientations_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.orientations_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_orientations().empty()) {
    _this->_impl_.orientations_.Set(from._internal_orientations(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.slot_ = from._impl_.slot_;
  // @@protoc_insertion_point(copy_constructor:telemetry.v2.PlayerBones)
}

inline void PlayerBones::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.transforms_){}
    , decltype(_impl_.orientations_){}
    , decltype(_impl_.slot_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.transforms_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.transforms_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.orientations_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.orientations_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

PlayerBones::~PlayerBones() {
  // @@protoc_insertion_point(destructor:telemetry.v2.PlayerBones)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PlayerBones::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.transforms_.Destroy();
  _impl_.orientations_.Destroy();
}

void PlayerBones::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PlayerBones::Clear() {
// @@protoc_insertion_point(message_clear_start:telemetry.v2.PlayerBones)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.transforms_.ClearToEmpty();
  _impl_.orientations_.ClearToEmpty();
  _impl_.slot_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PlayerBones::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 slot = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.slot_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bytes transforms = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_transforms();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bytes orientations = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_orientations();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PlayerBones::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:telemetry.v2.PlayerBones)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 slot = 1;
  if (this->_internal_slot() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_slot(), target);
  }

  // bytes transforms = 2;
  if (!this->_internal_transforms().empty()) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_transforms(), target);
  }

  // bytes orientations = 3;
  if (!this->_internal_orientations().empty()) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_orientations(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:telemetry.v2.PlayerBones)
  return target;
}

size_t PlayerBones::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:telemetry.v2.PlayerBones)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bytes transforms = 2;
  if (!this->_internal_transforms().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_transforms());
  }

  // bytes orientations = 3;
  if (!this->_internal_orientations().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_orientations());
  }

  // int32 slot = 1;
  if (this->_internal_slot() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_slot());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PlayerBones::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PlayerBones::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PlayerBones::GetClassData() const { return &_class_data_; }


void PlayerBones::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PlayerBones*>(&to_msg);
  auto& from = static_cast<const PlayerBones&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:telemetry.v2.PlayerBones)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_transforms().empty()) {
    _this->_internal_set_transforms(from._internal_transforms());
  }
  if (!from._internal_orientations().empty()) {
    _this->_internal_set_orientations(from._internal_orientations());
  }
  if (from._internal_slot() != 0) {
    _this->_internal_set_slot(from._internal_slot());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PlayerBones::CopyFrom(const PlayerBones& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:telemetry.v2.PlayerBones)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PlayerBones::IsInitialized() const {
  return true;
}

void PlayerBones::InternalSwap(PlayerBones* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.transforms_, lhs_arena,
      &other->_impl_.transforms_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.orientations_, lhs_arena,
      &other->_impl_.orientations_, rhs_arena
  );
  swap(_impl_.slot_, other->_impl_.slot_);
}

::PROTOBUF_NAMESPACE_ID::Metadata PlayerBones::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_telemetry_2fv2_2fframe_2eproto_getter, &descriptor_table_telemetry_2fv2_2fframe_2eproto_once,
      file_level_metadata_telemetry_2fv2_2fframe_2eproto[5]);
}

// ===================================================================

class Frame::_Internal {
 public:
  static const ::telemetry::v2::DiscState& disc(const Frame* msg);
  static const ::spatial::v1::Pose& vr_root(const Frame* msg);
};

const ::telemetry::v2::DiscState&
Frame::_Internal::disc(const Frame* msg) {
  return *msg->_impl_.disc_;
}
const ::spatial::v1::Pose&
Frame::_Internal::vr_root(const Frame* msg) {
  return *msg->_impl_.vr_root_;
}
void Frame::clear_events() {
  _impl_.events_.Clear();
}
void Frame::clear_vr_root() {
  if (GetArenaForAllocation() == nullptr && _impl_.vr_root_ != nullptr) {
    delete _impl_.vr_root_;
  }
  _impl_.vr_root_ = nullptr;
}
Frame::Frame(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:telemetry.v2.Frame)
}
Frame::Frame(const Frame& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Frame* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.players_){from._impl_.players_}
    , decltype(_impl_.player_bones_){from._impl_.player_bones_}
    , decltype(_impl_.events_){from._impl_.events_}
    , decltype(_impl_.disc_){nullptr}
    , decltype(_impl_.vr_root_){nullptr}
    , decltype(_impl_.frame_index_){}
    , decltype(_impl_.timestamp_offset_ms_){}
    , decltype(_impl_.game_status_){}
    , decltype(_impl_.game_clock_){}
    , decltype(_impl_.disc_holder_slot_){}
    , decltype(_impl_.blue_points_){}
    , decltype(_impl_.orange_points_){}
    , decltype(_impl_.round_number_){}
    , decltype(_impl_.pause_state_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_disc()) {
    _this->_impl_.disc_ = new ::telemetry::v2::DiscState(*from._impl_.disc_);
  }
  if (from._internal_has_vr_root()) {
    _this->_impl_.vr_root_ = new ::spatial::v1::Pose(*from._impl_.vr_root_);
  }
  ::memcpy(&_impl_.frame_index_, &from._impl_.frame_index_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.pause_state_) -
    reinterpret_cast<char*>(&_impl_.frame_index_)) + sizeof(_impl_.pause_state_));
  // @@protoc_insertion_point(copy_constructor:telemetry.v2.Frame)
}

inline void Frame::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.players_){arena}
    , decltype(_impl_.player_bones_){arena}
    , decltype(_impl_.events_){arena}
    , decltype(_impl_.disc_){nullptr}
    , decltype(_impl_.vr_root_){nullptr}
    , decltype(_impl_.frame_index_){0u}
    , decltype(_impl_.timestamp_offset_ms_){0u}
    , decltype(_impl_.game_status_){0}
    , decltype(_impl_.game_clock_){0}
    , decltype(_impl_.disc_holder_slot_){0}
    , decltype(_impl_.blue_points_){0}
    , decltype(_impl_.orange_points_){0}
    , decltype(_impl_.round_number_){0}
    , decltype(_impl_.pause_state_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Frame::~Frame() {
  // @@protoc_insertion_point(destructor:telemetry.v2.Frame)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Frame::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.players_.~RepeatedPtrField();
  _impl_.player_bones_.~RepeatedPtrField();
  _impl_.events_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.disc_;
  if (this != internal_default_instance()) delete _impl_.vr_root_;
}

void Frame::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Frame::Clear() {
// @@protoc_insertion_point(message_clear_start:telemetry.v2.Frame)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.players_.Clear();
  _impl_.player_bones_.Clear();
  _impl_.events_.Clear();
  if (GetArenaForAllocation() == nullptr && _impl_.disc_ != nullptr) {
    delete _impl_.disc_;
  }
  _impl_.disc_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.vr_root_ != nullptr) {
    delete _impl_.vr_root_;
  }
  _impl_.vr_root_ = nullptr;
  ::memset(&_impl_.frame_index_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.pause_state_) -
      reinterpret_cast<char*>(&_impl_.frame_index_)) + sizeof(_impl_.pause_state_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Frame::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 frame_index = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.frame_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 timestamp_offset_ms = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.timestamp_offset_ms_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .telemetry.v2.GameStatus game_status = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_game_status(static_cast<::telemetry::v2::GameStatus>(val));
        } else
          goto handle_unusual;
        continue;
      // float game_clock = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 37)) {
          _impl_.game_clock_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // .telemetry.v2.DiscState disc = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_disc(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .telemetry.v2.PlayerState players = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_players(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<50>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .telemetry.v2.PlayerBones player_bones = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_player_bones(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<58>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .telemetry.v1.LobbySessionEvent events = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_events(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<66>(ptr));
        } else
          goto handle_unusual;
        continue;
      // sint32 disc_holder_slot = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _impl_.disc_holder_slot_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarintZigZag32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .spatial.v1.Pose vr_root = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_vr_root(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 blue_points = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _impl_.blue_points_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 orange_points = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _impl_.orange_points_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 round_number = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 104)) {
          _impl_.round_number_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .telemetry.v2.PauseState pause_state = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 112)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_pause_state(static_cast<::telemetry::v2::PauseState>(val));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Frame::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:telemetry.v2.Frame)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 frame_index = 1;
  if (this->_internal_frame_index() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_frame_index(), target);
  }

  // uint32 timestamp_offset_ms = 2;
  if (this->_internal_timestamp_offset_ms() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_timestamp_offset_ms(), target);
  }

  // .telemetry.v2.GameStatus game_status = 3;
  if (this->_internal_game_status() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      3, this->_internal_game_status(), target);
  }

  // float game_clock = 4;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_game_clock = this->_internal_game_clock();
  uint32_t raw_game_clock;
  memcpy(&raw_game_clock, &tmp_game_clock, sizeof(tmp_game_clock));
  if (raw_game_clock != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(4, this->_internal_game_clock(), target);
  }

  // .telemetry.v2.DiscState disc = 5;
  if (this->_internal_has_disc()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::disc(this),
        _Internal::disc(this).GetCachedSize(), target, stream);
  }

  // repeated .telemetry.v2.PlayerState players = 6;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_players_size()); i < n; i++) {
    const auto& repfield = this->_internal_players(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(6, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .telemetry.v2.PlayerBones player_bones = 7;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_player_bones_size()); i < n; i++) {
    const auto& repfield = this->_internal_player_bones(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(7, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .telemetry.v1.LobbySessionEvent events = 8;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_events_size()); i < n; i++) {
    const auto& repfield = this->_internal_events(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(8, repfield, repfield.GetCachedSize(), target, stream);
  }

  // sint32 disc_holder_slot = 9;
  if (this->_internal_disc_holder_slot() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteSInt32ToArray(9, this->_internal_disc_holder_slot(), target);
  }

  // .spatial.v1.Pose vr_root = 10;
  if (this->_internal_has_vr_root()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(10, _Internal::vr_root(this),
        _Internal::vr_root(this).GetCachedSize(), target, stream);
  }

  // int32 blue_points = 11;
  if (this->_internal_blue_points() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(11, this->_internal_blue_points(), target);
  }

  // int32 orange_points = 12;
  if (this->_internal_orange_points() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(12, this->_internal_orange_points(), target);
  }

  // int32 round_number = 13;
  if (this->_internal_round_number() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(13, this->_internal_round_number(), target);
  }

  // .telemetry.v2.PauseState pause_state = 14;
  if (this->_internal_pause_state() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      14, this->_internal_pause_state(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:telemetry.v2.Frame)
  return target;
}

size_t Frame::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:telemetry.v2.Frame)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .telemetry.v2.PlayerState players = 6;
  total_size += 1UL * this->_internal_players_size();
  for (const auto& msg : this->_impl_.players_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .telemetry.v2.PlayerBones player_bones = 7;
  total_size += 1UL * this->_internal_player_bones_size();
  for (const auto& msg : this->_impl_.player_bones_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .telemetry.v1.LobbySessionEvent events = 8;
  total_size += 1UL * this->_internal_events_size();
  for (const auto& msg : this->_impl_.events_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // .telemetry.v2.DiscState disc = 5;
  if (this->_internal_has_disc()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.disc_);
  }

  // .spatial.v1.Pose vr_root = 10;
  if (this->_internal_has_vr_root()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.vr_root_);
  }

  // uint32 frame_index = 1;
  if (this->_internal_frame_index() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_frame_index());
  }

  // uint32 timestamp_offset_ms = 2;
  if (this->_internal_timestamp_offset_ms() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_timestamp_offset_ms());
  }

  // .telemetry.v2.GameStatus game_status = 3;
  if (this->_internal_game_status() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_game_status());
  }

  // float game_clock = 4;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_game_clock = this->_internal_game_clock();
  uint32_t raw_game_clock;
  memcpy(&raw_game_clock, &tmp_game_clock, sizeof(tmp_game_clock));
  if (raw_game_clock != 0) {
    total_size += 1 + 4;
  }

  // sint32 disc_holder_slot = 9;
  if (this->_internal_disc_holder_slot() != 0) {
    total_size += ::_pbi::WireFormatLite::SInt32SizePlusOne(this->_internal_disc_holder_slot());
  }

  // int32 blue_points = 11;
  if (this->_internal_blue_points() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_blue_points());
  }

  // int32 orange_points = 12;
  if (this->_internal_orange_points() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_orange_points());
  }

  // int32 round_number = 13;
  if (this->_internal_round_number() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_round_number());
  }

  // .telemetry.v2.PauseState pause_state = 14;
  if (this->_internal_pause_state() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_pause_state());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Frame::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Frame::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Frame::GetClassData() const { return &_class_data_; }


void Frame::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Frame*>(&to_msg);
  auto& from = static_cast<const Frame&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:telemetry.v2.Frame)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.players_.MergeFrom(from._impl_.players_);
  _this->_impl_.player_bones_.MergeFrom(from._impl_.player_bones_);
  _this->_impl_.events_.MergeFrom(from._impl_.events_);
  if (from._internal_has_disc()) {
    _this->_internal_mutable_disc()->::telemetry::v2::DiscState::MergeFrom(
        from._internal_disc());
  }
  if (from._internal_has_vr_root()) {
    _this->_internal_mutable_vr_root()->::spatial::v1::Pose::MergeFrom(
        from._internal_vr_root());
  }
  if (from._internal_frame_index() != 0) {
    _this->_internal_set_frame_index(from._internal_frame_index());
  }
  if (from._internal_timestamp_offset_ms() != 0) {
    _this->_internal_set_timestamp_offset_ms(from._internal_timestamp_offset_ms());
  }
  if (from._internal_game_status() != 0) {
    _this->_internal_set_game_status(from._internal_game_status());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_game_clock = from._internal_game_clock();
  uint32_t raw_game_clock;
  memcpy(&raw_game_clock, &tmp_game_clock, sizeof(tmp_game_clock));
  if (raw_game_clock != 0) {
    _this->_internal_set_game_clock(from._internal_game_clock());
  }
  if (from._internal_disc_holder_slot() != 0) {
    _this->_internal_set_disc_holder_slot(from._internal_disc_holder_slot());
  }
  if (from._internal_blue_points() != 0) {
    _this->_internal_set_blue_points(from._internal_blue_points());
  }
  if (from._internal_orange_points() != 0) {
    _this->_internal_set_orange_points(from._internal_orange_points());
  }
  if (from._internal_round_number() != 0) {
    _this->_internal_set_round_number(from._internal_round_number());
  }
  if (from._internal_pause_state() != 0) {
    _this->_internal_set_pause_state(from._internal_pause_state());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Frame::CopyFrom(const Frame& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:telemetry.v2.Frame)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Frame::IsInitialized() const {
  return true;
}

void Frame::InternalSwap(Frame* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.players_.InternalSwap(&other->_impl_.players_);
  _impl_.player_bones_.InternalSwap(&other->_impl_.player_bones_);
  _impl_.events_.InternalSwap(&other->_impl_.events_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Frame, _impl_.pause_state_)
      + sizeof(Frame::_impl_.pause_state_)
      - PROTOBUF_FIELD_OFFSET(Frame, _impl_.disc_)>(
          reinterpret_cast<char*>(&_impl_.disc_),
          reinterpret_cast<char*>(&other->_impl_.disc_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Frame::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_telemetry_2fv2_2fframe_2eproto_getter, &descriptor_table_telemetry_2fv2_2fframe_2eproto_once,
      file_level_metadata_telemetry_2fv2_2fframe_2eproto[6]);
}

// ===================================================================

class EnvelopeV2::_Internal {
 public:
  static const ::telemetry::v2::CaptureHeader& header_v2(const EnvelopeV2* msg);
  static const ::telemetry::v2::Frame& frame_v2(const EnvelopeV2* msg);
  static const ::telemetry::v1::TelemetryHeader& header_v1(const EnvelopeV2* msg);
  static const ::telemetry::v1::LobbySessionStateFrame& frame_v1(const EnvelopeV2* msg);
};

const ::telemetry::v2::CaptureHeader&
EnvelopeV2::_Internal::header_v2(const EnvelopeV2* msg) {
  return *msg->_impl_.message_.header_v2_;
}
const ::telemetry::v2::Frame&
EnvelopeV2::_Internal::frame_v2(const EnvelopeV2* msg) {
  return *msg->_impl_.message_.frame_v2_;
}
const ::telemetry::v1::TelemetryHeader&
EnvelopeV2::_Internal::header_v1(const EnvelopeV2* msg) {
  return *msg->_impl_.message_.header_v1_;
}
const ::telemetry::v1::LobbySessionStateFrame&
EnvelopeV2::_Internal::frame_v1(const EnvelopeV2* msg) {
  return *msg->_impl_.message_.frame_v1_;
}
void EnvelopeV2::set_allocated_header_v2(::telemetry::v2::CaptureHeader* header_v2) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_message();
  if (header_v2) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(header_v2);
    if (message_arena != submessage_arena) {
      header_v2 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header_v2, submessage_arena);
    }
    set_has_header_v2();
    _impl_.message_.header_v2_ = header_v2;
  }
  // @@protoc_insertion_point(field_set_allocated:telemetry.v2.EnvelopeV2.header_v2)
}
void EnvelopeV2::set_allocated_frame_v2(::telemetry::v2::Frame* frame_v2) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_message();
  if (frame_v2) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(frame_v2);
    if (message_arena != submessage_arena) {
      frame_v2 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, frame_v2, submessage_arena);
    }
    set_has_frame_v2();
    _impl_.message_.frame_v2_ = frame_v2;
  }
  // @@protoc_insertion_point(field_set_allocated:telemetry.v2.EnvelopeV2.frame_v2)
}
void EnvelopeV2::set_allocated_header_v1(::telemetry::v1::TelemetryHeader* header_v1) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_message();
  if (header_v1) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_v1));
    if (message_arena != submessage_arena) {
      header_v1 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header_v1, submessage_arena);
    }
    set_has_header_v1();
    _impl_.message_.header_v1_ = header_v1;
  }
  // @@protoc_insertion_point(field_set_allocated:telemetry.v2.EnvelopeV2.header_v1)
}
void EnvelopeV2::clear_header_v1() {
  if (_internal_has_header_v1()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.message_.header_v1_;
    }
    clear_has_message();
  }
}
void EnvelopeV2::set_allocated_frame_v1(::telemetry::v1::LobbySessionStateFrame* frame_v1) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_message();
  if (frame_v1) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(frame_v1));
    if (message_arena != submessage_arena) {
      frame_v1 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, frame_v1, submessage_arena);
    }
    set_has_frame_v1();
    _impl_.message_.frame_v1_ = frame_v1;
  }
  // @@protoc_insertion_point(field_set_allocated:telemetry.v2.EnvelopeV2.frame_v1)
}
void EnvelopeV2::clear_frame_v1() {
  if (_internal_has_frame_v1()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.message_.frame_v1_;
    }
    clear_has_message();
  }
}
EnvelopeV2::EnvelopeV2(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:telemetry.v2.EnvelopeV2)
}
EnvelopeV2::EnvelopeV2(const EnvelopeV2& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  EnvelopeV2* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.message_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  clear_has_message();
  switch (from.message_case()) {
    case kHeaderV2: {
      _this->_internal_mutable_header_v2()->::telemetry::v2::CaptureHeader::MergeFrom(
          from._internal_header_v2());
      break;
    }
    case kFrameV2: {
      _this->_internal_mutable_frame_v2()->::telemetry::v2::Frame::MergeFrom(
          from._internal_frame_v2());
      break;
    }
    case kHeaderV1: {
      _this->_internal_mutable_header_v1()->::telemetry::v1::TelemetryHeader::MergeFrom(
          from._internal_header_v1());
      break;
    }
    case kFrameV1: {
      _this->_internal_mutable_frame_v1()->::telemetry::v1::LobbySessionStateFrame::MergeFrom(
          from._internal_frame_v1());
      break;
    }
    case MESSAGE_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:telemetry.v2.EnvelopeV2)
}

inline void EnvelopeV2::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.message_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_message();
}

EnvelopeV2::~EnvelopeV2() {
  // @@protoc_insertion_point(destructor:telemetry.v2.EnvelopeV2)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void EnvelopeV2::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_message()) {
    clear_message();
  }
}

void EnvelopeV2::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void EnvelopeV2::clear_message() {
// @@protoc_insertion_point(one_of_clear_start:telemetry.v2.EnvelopeV2)
  switch (message_case()) {
    case kHeaderV2: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.message_.header_v2_;
      }
      break;
    }
    case kFrameV2: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.message_.frame_v2_;
      }
      break;
    }
    case kHeaderV1: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.message_.header_v1_;
      }
      break;
    }
    case kFrameV1: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.message_.frame_v1_;
      }
      break;
    }
    case MESSAGE_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = MESSAGE_NOT_SET;
}


void EnvelopeV2::Clear() {
// @@protoc_insertion_point(message_clear_start:telemetry.v2.EnvelopeV2)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_message();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* EnvelopeV2::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .telemetry.v2.CaptureHeader header_v2 = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_header_v2(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .telemetry.v2.Frame frame_v2 = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_frame_v2(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .telemetry.v1.TelemetryHeader header_v1 = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_header_v1(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .telemetry.v1.LobbySessionStateFrame frame_v1 = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr = ctx->ParseMessage(_internal_mutable_frame_v1(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* EnvelopeV2::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:telemetry.v2.EnvelopeV2)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .telemetry.v2.CaptureHeader header_v2 = 1;
  if (_internal_has_header_v2()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::header_v2(this),
        _Internal::header_v2(this).GetCachedSize(), target, stream);
  }

  // .telemetry.v2.Frame frame_v2 = 2;
  if (_internal_has_frame_v2()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::frame_v2(this),
        _Internal::frame_v2(this).GetCachedSize(), target, stream);
  }

  // .telemetry.v1.TelemetryHeader header_v1 = 10;
  if (_internal_has_header_v1()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(10, _Internal::header_v1(this),
        _Internal::header_v1(this).GetCachedSize(), target, stream);
  }

  // .telemetry.v1.LobbySessionStateFrame frame_v1 = 11;
  if (_internal_has_frame_v1()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(11, _Internal::frame_v1(this),
        _Internal::frame_v1(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:telemetry.v2.EnvelopeV2)
  return target;
}

size_t EnvelopeV2::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:telemetry.v2.EnvelopeV2)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (message_case()) {
    // .telemetry.v2.CaptureHeader header_v2 = 1;
    case kHeaderV2: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.message_.header_v2_);
      break;
    }
    // .telemetry.v2.Frame frame_v2 = 2;
    case kFrameV2: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.message_.frame_v2_);
      break;
    }
    // .telemetry.v1.TelemetryHeader header_v1 = 10;
    case kHeaderV1: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.message_.header_v1_);
      break;
    }
    // .telemetry.v1.LobbySessionStateFrame frame_v1 = 11;
    case kFrameV1: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.message_.frame_v1_);
      break;
    }
    case MESSAGE_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData EnvelopeV2::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    EnvelopeV2::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*EnvelopeV2::GetClassData() const { return &_class_data_; }


void EnvelopeV2::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<EnvelopeV2*>(&to_msg);
  auto& from = static_cast<const EnvelopeV2&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:telemetry.v2.EnvelopeV2)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.message_case()) {
    case kHeaderV2: {
      _this->_internal_mutable_header_v2()->::telemetry::v2::CaptureHeader::MergeFrom(
          from._internal_header_v2());
      break;
    }
    case kFrameV2: {
      _this->_internal_mutable_frame_v2()->::telemetry::v2::Frame::MergeFrom(
          from._internal_frame_v2());
      break;
    }
    case kHeaderV1: {
      _this->_internal_mutable_header_v1()->::telemetry::v1::TelemetryHeader::MergeFrom(
          from._internal_header_v1());
      break;
    }
    case kFrameV1: {
      _this->_internal_mutable_frame_v1()->::telemetry::v1::LobbySessionStateFrame::MergeFrom(
          from._internal_frame_v1());
      break;
    }
    case MESSAGE_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void EnvelopeV2::CopyFrom(const EnvelopeV2& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:telemetry.v2.EnvelopeV2)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EnvelopeV2::IsInitialized() const {
  return true;
}

void EnvelopeV2::InternalSwap(EnvelopeV2* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.message_, other->_impl_.message_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata EnvelopeV2::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_telemetry_2fv2_2fframe_2eproto_getter, &descriptor_table_telemetry_2fv2_2fframe_2eproto_once,
      file_level_metadata_telemetry_2fv2_2fframe_2eproto[7]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace v2
}  // namespace telemetry
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::telemetry::v2::CaptureHeader_MetadataEntry_DoNotUse*
Arena::CreateMaybeMessage< ::telemetry::v2::CaptureHeader_MetadataEntry_DoNotUse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::telemetry::v2::CaptureHeader_MetadataEntry_DoNotUse >(arena);
}
template<> PROTOBUF_NOINLINE ::telemetry::v2::CaptureHeader*
Arena::CreateMaybeMessage< ::telemetry::v2::CaptureHeader >(Arena* arena) {
  return Arena::CreateMessageInternal< ::telemetry::v2::CaptureHeader >(arena);
}
template<> PROTOBUF_NOINLINE ::telemetry::v2::PlayerInfo*
Arena::CreateMaybeMessage< ::telemetry::v2::PlayerInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::telemetry::v2::PlayerInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::telemetry::v2::DiscState*
Arena::CreateMaybeMessage< ::telemetry::v2::DiscState >(Arena* arena) {
  return Arena::CreateMessageInternal< ::telemetry::v2::DiscState >(arena);
}
template<> PROTOBUF_NOINLINE ::telemetry::v2::PlayerState*
Arena::CreateMaybeMessage< ::telemetry::v2::PlayerState >(Arena* arena) {
  return Arena::CreateMessageInternal< ::telemetry::v2::PlayerState >(arena);
}
template<> PROTOBUF_NOINLINE ::telemetry::v2::PlayerBones*
Arena::CreateMaybeMessage< ::telemetry::v2::PlayerBones >(Arena* arena) {
  return Arena::CreateMessageInternal< ::telemetry::v2::PlayerBones >(arena);
}
template<> PROTOBUF_NOINLINE ::telemetry::v2::Frame*
Arena::CreateMaybeMessage< ::telemetry::v2::Frame >(Arena* arena) {
  return Arena::CreateMessageInternal< ::telemetry::v2::Frame >(arena);
}
template<> PROTOBUF_NOINLINE ::telemetry::v2::EnvelopeV2*
Arena::CreateMaybeMessage< ::telemetry::v2::EnvelopeV2 >(Arena* arena) {
  return Arena::CreateMessageInternal< ::telemetry::v2::EnvelopeV2 >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
